<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Psychedelic Math Lab — 100 Toys | Errl</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="../../../../../shared/styles/errlDesignSystem.css" />
<style>

  :root{

    --bg:#0a0c12; --ink:#eaf2ff; --mut:#8fa3bf; --accent:#56c2ff; --accent2:#b8ff3b;

    --card:#0f141d; --tab:#111826; --btn:#152033; --stage:#0b0f16;

  }

  html,body{margin:0;background:var(--bg);color:var(--ink);font:500 14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}

  .bar{position:sticky;top:0;z-index:10;background:var(--tab);display:flex;flex-wrap:wrap;gap:.5rem;padding:.6rem;border-bottom:1px solid #0d1522}

  .tab{appearance:none;border:0;border-radius:.6rem;background:var(--btn);color:var(--ink);padding:.5rem .7rem;font-weight:600}

  .tab.active{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#04101a}

  .wrap{padding:.6rem}

  .panel{display:none;background:var(--card);border:1px solid #0d1522;border-radius:.8rem;overflow:hidden;margin-bottom:.8rem}

  .panel.active{display:block}

  header{padding:.8rem 1rem;border-bottom:1px solid #0d1522;display:flex;align-items:center;justify-content:space-between;gap:.5rem}

  header h2{margin:0;font-size:1rem}

  header small{color:var(--mut)}

  .tools{display:flex;gap:.5rem;flex-wrap:wrap}

  .tool{display:flex;align-items:center;gap:.4rem;background:#0c1420;border:1px solid #0e1a2a;border-radius:.5rem;padding:.35rem .5rem}

  .tool input, .tool select{accent-color:var(--accent);color:var(--ink)}

  .stage{background:var(--stage)}

  canvas,svg,.stage div{display:block;width:100%;height:60vh}

  .code{background:#0b0f16;color:#cde;padding:.8rem 1rem;font:500 12px/1.4 ui-monospace;overflow:auto}

  .desc{padding:.6rem 1rem;color:var(--mut);border-top:1px solid #0d1522}

  .hint{padding:.6rem 1rem;color:#9fb3cc;border-top:1px solid #0d1522}

  @media (prefers-reduced-motion: reduce){ *{animation-duration:0.001ms!important;animation-iteration-count:1!important;transition-duration:0.001ms!important} }

  /* Portal header styles */
  .errl-header {
    position: sticky; top: 0; width: 100%;
    background:
      linear-gradient(135deg, rgba(220,220,240,0.95) 0%, rgba(180,180,200,0.9) 25%, rgba(160,160,180,0.9) 50%, rgba(180,180,200,0.9) 75%, rgba(220,220,240,0.95) 100%),
      linear-gradient(45deg, rgba(255,255,255,0.3) 0%, transparent 30%, transparent 70%, rgba(255,255,255,0.3) 100%);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 1px 0 rgba(255,255,255,0.4) inset, 0 -1px 0 rgba(0,0,0,0.2) inset;
    border-bottom: 1px solid rgba(120,120,140,0.6);
    padding: 0.75rem 1rem; z-index: 999; letter-spacing: -0.03em;
  }
  .errl-header-content { display:flex; align-items:center; justify-content:space-between; max-width:1200px; margin:0 auto; }
  .errl-home-btn{ display:inline-flex; align-items:center; gap:.5rem; color:#fff; background: linear-gradient(135deg, #ff0080 0%, #8000ff 25%, #0080ff 50%, #00ff80 75%, #ff8000 100%); background-size:200% 200%; border:1px solid rgba(255,255,255,0.3); border-radius:999px; font-size:.8rem; font-weight:600; line-height:1; padding:.55rem .9rem .6rem; box-shadow:0 4px 12px rgba(0,0,0,0.3), 0 1px 0 rgba(255,255,255,0.3) inset; text-decoration:none; text-shadow:0 1px 2px rgba(0,0,0,0.8); animation: rainbow-flow 3s linear infinite; }
  @keyframes rainbow-flow{ 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
  @media (max-width: 640px){ .errl-home-btn{ width:38px; height:38px; padding:0; border-radius:999px; display:inline-grid; place-items:center; overflow:hidden; font-size:0; } .errl-home-btn::before{ content:'←'; font-size:16px; line-height:1; filter: drop-shadow(0 1px 2px rgba(0,0,0,.8)); } }
  .errl-nav{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap; overflow-x:auto; scrollbar-width:none; -ms-overflow-style:none; }
  .errl-nav::-webkit-scrollbar{ display:none; }
  @media (max-width: 900px){
    .errl-header-content{ flex-wrap:wrap; gap:.75rem; }
    .errl-nav{ gap:.4rem; max-width:100%; }
    .errl-bubble-btn{ min-width:5.5rem; max-width:8rem; padding:.5rem .75rem .6rem; font-size:.75rem; }
  }
  @media (max-width: 640px){
    .errl-nav{ gap:.3rem; }
    .errl-bubble-btn{ min-width:4.5rem; max-width:7rem; padding:.45rem .65rem .55rem; font-size:.7rem; }
  }
  .errl-bubble-btn{ position:relative; display:inline-flex; align-items:center; justify-content:center; min-width:6.5rem; max-width:10rem; padding:.6rem .9rem .7rem; border-radius:999px; font-size:.8rem; font-weight:600; line-height:1.1; text-align:center; color:#e8e8e8; text-decoration:none; white-space:nowrap; text-shadow:0 1px 3px rgba(0,0,0,0.8); background: linear-gradient(135deg, rgba(100,100,120,0.9) 0%, rgba(60,60,80,0.9) 25%, rgba(40,40,60,0.9) 50%, rgba(60,60,80,0.9) 75%, rgba(100,100,120,0.9) 100%), linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 30%, transparent 70%, rgba(255,255,255,0.1) 100%); border:2px solid transparent; background-clip:padding-box; box-shadow: 0 4px 12px rgba(0,0,0,0.3), 0 1px 0 rgba(255,255,255,0.2) inset, 0 -1px 0 rgba(0,0,0,0.3) inset; }
  .errl-bubble-btn::before{ content:""; position:absolute; inset:-2px; border-radius:999px; padding:2px; background: linear-gradient(90deg, rgba(0,255,255,0.6) 0%, rgba(255,0,255,0.6) 25%, rgba(255,255,0,0.6) 50%, rgba(0,255,0,0.6) 75%, rgba(0,255,255,0.6) 100%); background-size:200% 100%; mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); mask-composite:xor; -webkit-mask-composite:xor; animation: led-flow 2s linear infinite; opacity:.7; }
  @keyframes led-flow{ 0%{background-position:0% 50%} 100%{background-position:200% 50%} }
  .errl-bubble-btn.active{ background: linear-gradient(135deg, rgba(140,140,160,0.95) 0%, rgba(100,100,130,0.95) 25%, rgba(80,80,110,0.95) 50%, rgba(100,100,130,0.95) 75%, rgba(140,140,160,0.95) 100%), linear-gradient(45deg, rgba(255,255,255,0.2) 0%, transparent 30%, transparent 70%, rgba(255,255,255,0.2) 100%); color:#fff; font-weight:700; text-shadow:0 1px 3px rgba(0,0,0,0.9); box-shadow: 0 6px 16px rgba(0,0,0,0.4), 0 1px 0 rgba(255,255,255,0.3) inset, 0 -1px 0 rgba(0,0,0,0.4) inset; }
  .errl-bubble-btn.active::before{ background: radial-gradient(circle at 0% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 25% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 50% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 75% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 100% 50%, rgba(255,255,255,0.8) 0%, transparent 25%); background-size:20% 100%; animation: led-pulse 1s ease-in-out infinite alternate; opacity:.9; }
  @keyframes led-pulse{ 0%{opacity:.5} 100%{opacity:1} }

  /* Dev-only FPS overlay */
  .fps-overlay{ position:fixed; right:.5rem; bottom:.5rem; z-index:9999; background:rgba(10,12,18,.85); color:#bfe4ff; border:1px solid #16304d; border-radius:.5rem; padding:.35rem .5rem; font:600 12px/1 ui-monospace; box-shadow:0 4px 16px rgba(0,0,0,.4) }

  /* Two‑pane shell */
  .lab-shell{ display:grid; grid-template-columns: 320px 1fr; gap:.75rem; padding:.75rem }
  .lab-sidebar{ background:var(--card); border:1px solid #0d1522; border-radius:.8rem; overflow:hidden; display:flex; flex-direction:column; min-height:60vh; max-height:calc(100vh - 140px) }
  .lab-sidehdr{ padding:.6rem .75rem; border-bottom:1px solid #0d1522; display:flex; gap:.5rem; align-items:center }
  .lab-search{ flex:1; background:#0c1420; border:1px solid #0e1a2a; border-radius:.5rem; color:var(--ink); padding:.45rem .6rem }
  .lab-cats{ display:flex; flex-wrap:wrap; gap:.4rem; padding:.5rem .75rem; border-bottom:1px solid #0d1522 }
  .lab-cat{ appearance:none; border:0; border-radius:999px; padding:.35rem .6rem; font-weight:600; background:#0c1420; color:#cfe3ff }
  .lab-cat.active{ background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#04101a }
  .lab-list{ list-style:none; margin:0; padding:.25rem 0; overflow:auto; flex:1 }
  .lab-item{ display:flex; justify-content:space-between; align-items:center; gap:.5rem; width:100%; text-align:left; background:transparent; color:var(--ink); padding:.45rem .75rem; border:0 }
  .lab-item:hover{ background:#0f1420 }
  .lab-item[aria-current="true"]{ background:#112033 }
  .lab-item small{ color:var(--mut) }
  .lab-row{ display:flex; align-items:center; gap:.6rem }
  .lab-av{ width:22px; height:22px; border-radius:50%; display:inline-block; }
  .av-fractals{ background:radial-gradient(circle at 30% 30%, #ff7ad9, #6b00ff) }
  .av-noise{ background:radial-gradient(circle at 30% 70%, #6ef, #2b6) }
  .av-geom{ background:radial-gradient(circle at 70% 30%, #ffd166, #ef476f) }
  .av-grids{ background:radial-gradient(circle at 50% 50%, #a0f, #09f) }
  .av-fields{ background:radial-gradient(circle at 40% 60%, #5df, #0bf) }
  .av-ca{ background:radial-gradient(circle at 50% 50%, #9cf, #69f) }
  .av-sdf{ background:radial-gradient(circle at 60% 40%, #f9f, #f6a) }
  .av-css{ background:radial-gradient(circle at 60% 40%, #9f9, #3c6) }
  .av-complex{ background:radial-gradient(circle at 40% 60%, #fda, #f86) }
  .av-misc{ background:radial-gradient(circle at 40% 60%, #ccc, #666) }

  .lab-preview{ background:var(--card); border:1px solid #0d1522; border-radius:.8rem; overflow:hidden }
  .lab-prevhdr{ padding:.75rem 1rem; border-bottom:1px solid #0d1522; display:flex; align-items:center; justify-content:space-between; gap:.5rem }
  .lab-prevhdr h2{ margin:0; font-size:1rem }
  .lab-actions{ display:flex; gap:.4rem }
  .lab-btn{ appearance:none; border:1px solid #0e1a2a; border-radius:.5rem; background:#0c1420; color:var(--ink); padding:.35rem .6rem; font-weight:600 }

  /* Hide legacy bar/panels in two‑pane mode */
  .bar, #panels{ display:none }

  /* Mobile drawer */
  @media (max-width: 900px){
    .lab-shell{ grid-template-columns: 1fr; }
    .lab-sidebar{ order:2; display:none }
    .lab-shell.drawer-open .lab-sidebar{ display:flex }
    .lab-preview{ order:1 }
  }

</style>
</head>
<body>
  <header class="errl-header">
    <div class="errl-header-content">
      <a class="errl-home-btn" href="/">← Back to Portal</a>
      <nav class="errl-nav">
        <a class="errl-bubble-btn" href="/about/" data-portal-link="about/">About Errl</a>
        <a class="errl-bubble-btn" href="/gallery/" data-portal-link="gallery/">Gallery</a>
        <a class="errl-bubble-btn" href="/assets/" data-portal-link="assets/">Assets</a>
        <a class="errl-bubble-btn" href="/studio.html">Studio</a>
        <a class="errl-bubble-btn" href="#" data-multitool-link>Multitool</a>
        <a class="errl-bubble-btn" href="/events/" data-portal-link="events/">Events</a>
        <a class="errl-bubble-btn" href="/merch/" data-portal-link="merch/">Merch</a>
      </nav>
    </div>
  </header>
<script>
  // Hide header when embedded in iframe (e.g., in React Studio shell)
  if (window.self !== window.top) {
    const header = document.querySelector('.errl-header');
    if (header) {
      header.style.display = 'none';
    }
  }
</script>
<div class="lab-shell">
  <aside class="lab-sidebar">
    <div class="lab-sidehdr">
      <input id="labSearch" class="lab-search" type="search" placeholder="Search effects…" />
    </div>
    <div id="labCats" class="lab-cats"></div>
    <ul id="labList" class="lab-list"></ul>
  </aside>
  <main class="lab-preview">
    <div class="lab-prevhdr">
      <h2 id="labTitle">Select an effect</h2>
      <div class="lab-actions">
        <button id="labBrowse" class="lab-btn" type="button">Browse</button>
        <button id="labStop" class="lab-btn" type="button">Stop</button>
        <button id="labStart" class="lab-btn" type="button">Start</button>
      </div>
      <div id="labMeta" style="color:var(--mut); font-weight:600"></div>
    </div>
    <div class="wrap" id="labPreview">
      <header style="padding:.8rem 1rem; border-bottom:1px solid #0d1522; display:flex; align-items:center; justify-content:space-between; gap:.5rem">
        <div id="tools-active" class="tools"></div>
      </header>
      <div class="stage" id="stage-active"></div>
      <pre class="code" id="code-active"></pre>
    </div>
  </main>
</div>

<!-- Legacy (hidden) -->
<div class="bar" id="tabs"></div>
<div class="wrap" id="panels"></div>

<script>

(function(){
  try{
    if(document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', ()=>{ try{ setupFPSOverlay(); }catch(e){ console.warn('FPS overlay init failed', e); } });
    } else {
      setupFPSOverlay();
    }
  }catch(e){ console.warn('FPS overlay init failed', e); }
})();

/* ---------- UTILITIES ---------- */

const tabs = document.getElementById('tabs');

const panels = document.getElementById('panels');

const registry = []; // specs for 100 toys

const inits = {};    // init functions by key

function addSpec(spec){

  registry.push(spec);

  const b=document.createElement('button'); b.className='tab'; b.textContent=`${spec.id}. ${spec.title}`; b.onclick=()=>activate(spec.id); tabs.appendChild(b);

  const p=document.createElement('section'); p.className='panel'; p.id='panel-'+spec.id;

  p.innerHTML=`

    <header>

      <div><h2>${spec.id}. ${spec.title}</h2><small>${spec.desc}</small></div>

      <div class="tools" id="tools-${spec.id}"></div>

    </header>

    <div class="stage" id="stage-${spec.id}"></div>

    <pre class="code" id="code-${spec.id}"></pre>

    <div class="desc">${spec.notes}</div>

    <div class="hint">Tip: Drag, tap, and tweak. Code block shows the core generator behind the preview.</div>

  `;

  panels.appendChild(p);

  // Dev-only: add Export button when enabled via ?export=1 or localStorage mathlab_export=1
  try{
    if(isFlagEnabled('export')){
      const btn=document.createElement('button');
      btn.className='tool';
      btn.type='button';
      btn.textContent='Export';
      btn.title='Download PNG (canvas) or SVG (vector) depending on the effect';
      btn.onclick=()=>exportStage(spec.id, spec.title);
      appendTool(spec.id, btn);
    }
  }catch(e){ console.warn('Export button init failed', e); }

}

function activate(id){

  [...document.querySelectorAll('.tab')].forEach((t,i)=>t.classList.toggle('active', registry[i].id===id));

  [...document.querySelectorAll('.panel')].forEach(p=>p.classList.remove('active'));

  const el=document.getElementById('panel-'+id); el.classList.add('active');

  if(!el.dataset.init){ inits[registry.find(r=>r.id===id).key]({id}); el.dataset.init=1; }

}

function appendStage(id,node){ document.getElementById('stage-'+id).appendChild(node); }

function appendTool(id,node){ document.getElementById('tools-'+id).appendChild(node); }

function setCode(id,src){ document.getElementById('code-'+id).textContent = src.trim(); }

/* ---------- DEV FLAGS & HELPERS ---------- */

/* Two‑pane helpers */
const LAB = { catsEl:null, listEl:null, searchEl:null, previewEl:null, titleEl:null, metaEl:null, activeId:null, filter:'All', query:'', shellEl:null, serial:0 };

function ensureLabRefs(){
  LAB.catsEl = LAB.catsEl || document.getElementById('labCats');
  LAB.listEl = LAB.listEl || document.getElementById('labList');
  LAB.searchEl = LAB.searchEl || document.getElementById('labSearch');
  LAB.previewEl = LAB.previewEl || document.getElementById('labPreview');
  LAB.titleEl = LAB.titleEl || document.getElementById('labTitle');
  LAB.metaEl = LAB.metaEl || document.getElementById('labMeta');
  LAB.shellEl = LAB.shellEl || document.querySelector('.lab-shell');
}

function categorize(spec){
  const k = spec.key;
  if(/newton|fern|koch|dragon|hilbert|lorenz|ikeda|flames|lichtenberg/.test(k)) return 'Fractals & Chaos';
  if(/perlin|fbm|marble|worley|quasicrystal|interference|contours|nebula/.test(k)) return 'Noise & Procedural';
  if(/supershape|lissajous|superellipse|conics|polar-roses|spirograph|phase-carpets/.test(k)) return 'Geometry & Curves';
  if(/conformal-grid|iso-cubes|bitmask|primes|quilt|warp-grid|escher|penrose/.test(k)) return 'Grids & Tilings';
  if(/curl|circle-pack|magnetic|nbody|voronoi|delaunay|voronoi-pulse/.test(k)) return 'Fields & Particles';
  if(/rule110|automaton/.test(k)) return 'Cellular Automata';
  if(/sdf|raymarch|shadow|polar-zipper/.test(k)) return 'SDF & Raymarch';
  if(/chromaburst|soap|conic|mask|moire|sinewarp|radial-weave|impossible|svg-mesh/.test(k)) return 'SVG/CSS FX';
  if(/domain-coloring|roots|logo-melt/.test(k)) return 'Complex Analysis';
  return 'Misc';
}

function buildCategories(specs){
  const set = new Set(['All']);
  specs.forEach(s=> set.add(categorize(s)) );
  return Array.from(set);
}

function renderCats(specs){
  ensureLabRefs();
  const cats = buildCategories(specs);
  LAB.catsEl.innerHTML = cats.map(c=>`<button class=\"lab-cat ${c===LAB.filter?'active':''}\" data-cat=\"${c}\">${c}</button>`).join('');
  LAB.catsEl.querySelectorAll('button').forEach(btn=>{
    btn.onclick = ()=>{ LAB.filter = btn.dataset.cat; renderCats(specs); renderList(specs); };
  });
}

function renderList(specs){
  ensureLabRefs();
  const q = LAB.query.toLowerCase();
  const items = specs.filter(s=>
    (LAB.filter==='All' || categorize(s)===LAB.filter) &&
    (!q || (s.title||'').toLowerCase().includes(q) || (s.desc||'').toLowerCase().includes(q))
  ).sort((a,b)=>a.id-b.id);
  LAB.listEl.innerHTML = items.map((s,idx)=>{
    const cat = categorize(s);
    const labelNum = LAB.filter==='All' ? s.id : (idx+1);
    const avClass = cat.startsWith('Fractals')?'av-fractals':
      cat.startsWith('Noise')?'av-noise':
      cat.startsWith('Geometry')?'av-geom':
      cat.startsWith('Grids')?'av-grids':
      cat.startsWith('Fields')?'av-fields':
      cat.startsWith('Cellular')?'av-ca':
      cat.startsWith('SDF')?'av-sdf':
      cat.startsWith('SVG')?'av-css':
      cat.startsWith('Complex')?'av-complex':'av-misc';
    const current = String(LAB.activeId)===String(s.id);
    return `<li><button class=\"lab-item\" data-id=\"${s.id}\" aria-current=\"${current}\"><span class=\"lab-row\"><span class=\"lab-av ${avClass}\"></span><span>${labelNum}. ${s.title||s.key}</span></span><small>${cat}</small></button></li>`;
  }).join('');
  LAB.listEl.querySelectorAll('button.lab-item').forEach(btn=>{
    btn.onclick = ()=> activatePreview(parseInt(btn.dataset.id,10));
  });
}

function activatePreview(id){
  ensureLabRefs();
  const spec = registry.find(r=>r.id===id) || specs.find(r=>r.id===id);
  if(!spec) return;
  // bump serial to stop previous RAF loops via patched scheduler
  LAB.serial++;
  LAB.activeId = id;
  localStorage.setItem('mathlab_last', String(id));
  LAB.titleEl.textContent = `${id}. ${spec.title || spec.key}`;
  LAB.metaEl.textContent = categorize(spec);
  // Clear preview and create containers with expected ids
  LAB.previewEl.innerHTML = `
    <header style="padding:.8rem 1rem; border-bottom:1px solid #0d1522; display:flex; align-items:center; justify-content:space-between; gap:.5rem">
      <div id="tools-${id}" class="tools"></div>
    </header>
    <div class="stage" id="stage-${id}"></div>
    <pre class="code" id="code-${id}"></pre>
  `;
  // Create panel shell so existing activate() can init
  const ghost = document.createElement('section'); ghost.id = `panel-${id}`; ghost.className='panel active'; ghost.dataset.init='';
  LAB.previewEl.appendChild(ghost);
  activate(id);
}

function stopActive(){
  ensureLabRefs();
  LAB.serial++; // invalidate scheduled frames
  LAB.previewEl.innerHTML = '<div style="padding:1rem; color:#9fb3cc">Stopped.</div>';
}

function wireSearch(specs){
  ensureLabRefs();
  LAB.searchEl.oninput = (e)=>{ LAB.query = e.target.value || ''; renderList(specs); };
}

function wireHeader(specs){
  ensureLabRefs();
  const startBtn = document.getElementById('labStart');
  const stopBtn = document.getElementById('labStop');
  const browseBtn = document.getElementById('labBrowse');
  startBtn.onclick = ()=>{ if(LAB.activeId) activatePreview(LAB.activeId); };
  stopBtn.onclick = ()=>{ stopActive(); };
  browseBtn.onclick = ()=>{ LAB.shellEl.classList.toggle('drawer-open'); };
}

/* RequestAnimationFrame guard: skip callbacks from previous activations */
(function installRAFGuard(){
  const origRAF = window.requestAnimationFrame.bind(window);
  const origCancel = window.cancelAnimationFrame.bind(window);
  window.requestAnimationFrame = function(cb){
    const serialAtSchedule = LAB.serial;
    const wrapped = function(ts){ if (serialAtSchedule === LAB.serial) cb(ts); };
    return origRAF(wrapped);
  };
  window.cancelAnimationFrame = function(id){ return origCancel(id); };
})();

function isFlagEnabled(name){
  try{
    const p=new URLSearchParams(location.search);
    return p.has(name) || localStorage.getItem('mathlab_'+name)==='1';
  }catch(e){ return false; }
}

function downloadFile(filename, blobOrDataUrl){
  const a=document.createElement('a');
  a.download=filename;
  if(typeof blobOrDataUrl==='string'){ a.href=blobOrDataUrl; }
  else{ a.href=URL.createObjectURL(blobOrDataUrl); setTimeout(()=>URL.revokeObjectURL(a.href), 2000); }
  document.body.appendChild(a); a.click(); a.remove();
}

function exportStage(id, title){
  const stage=document.getElementById('stage-'+id);
  if(!stage){ alert('Stage not found'); return; }
  const canvas=stage.querySelector('canvas');
  if(canvas){
    try{
      const url=canvas.toDataURL('image/png');
      downloadFile(`mathlab-${id}.png`, url);
      return;
    }catch(e){ console.warn('Canvas export failed', e); }
  }
  const svg=stage.querySelector('svg');
  if(svg){
    try{
      const xml=new XMLSerializer().serializeToString(svg);
      const blob=new Blob([xml], {type:'image/svg+xml'});
      downloadFile(`mathlab-${id}.svg`, blob);
      return;
    }catch(e){ console.warn('SVG export failed', e); }
  }
  alert('No exportable canvas/svg found for this effect.');
}

function setupFPSOverlay(){
  if(!isFlagEnabled('fps')) return;
  const box=document.createElement('div'); box.className='fps-overlay'; box.textContent='FPS — …'; document.body.appendChild(box);
  let last=performance.now(), acc=0, frames=0;
  function tick(now){
    const dt=now-last; last=now; frames++; acc+=dt;
    if(acc>=1000){ const fps=Math.round(frames*1000/acc); box.textContent=`FPS — ${fps}`; acc=0; frames=0; }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
}

/* ---------- PRIMITIVES ---------- */

/* Canvas animation host with requestAnimationFrame */

function makeCanvas(id){

  const c=document.createElement('canvas'); appendStage(id,c);

  const ctx=c.getContext('2d',{alpha:true,desynchronized:true});

  function resize(){c.width=c.clientWidth; c.height=c.clientHeight}

  resize(); addEventListener('resize',resize, {passive:true});

  return {c,ctx};

}

/* Particle field primitive */

function particleField({id, params}){

  const {c,ctx}=makeCanvas(id);

  const P=Array(params.count).fill().map(_=>({

    x:Math.random()*c.width, y:Math.random()*c.height,

    vx:(Math.random()*2-1)*params.speed, vy:(Math.random()*2-1)*params.speed,

    size: params.sizeMin + Math.random()*(params.sizeMax-params.sizeMin),

    hue: Math.random()*360

  }));

  const state={mouse:{x:c.width/2,y:c.height/2}, running:true};

  function step(){

    ctx.fillStyle=`rgba(11,13,18,${params.fade})`; ctx.fillRect(0,0,c.width,c.height);

    const r = params.radius;

    for(const p of P){

      const dx=p.x-state.mouse.x, dy=p.y-state.mouse.y, d=Math.hypot(dx,dy);

      if(d<r){ const force=(r-d)/r*params.strength; const ang=Math.atan2(dy,dx);

        p.vx += Math.cos(ang)*force*params.accel; p.vy += Math.sin(ang)*force*params.accel; p.size += 0.02;}

      p.vx*=params.drag; p.vy*=params.drag; p.x+=p.vx; p.y+=p.vy;

      if(p.x<-80||p.x>c.width+80||p.y<-80||p.y>c.height+80){ p.x=Math.random()*c.width; p.y=Math.random()*c.height; }

      ctx.beginPath(); const col=`hsl(${(p.hue+=params.hueDrift)%360},90%,60%)`; ctx.fillStyle=col; ctx.shadowColor=col; ctx.shadowBlur=12; ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;

    }

    if(state.running) requestAnimationFrame(step);

  }

  step();

  c.addEventListener('pointermove',e=>{const r=c.getBoundingClientRect(); state.mouse.x=e.clientX-r.left; state.mouse.y=e.clientY-r.top});

  return {code: particleField.toString()};

}

/* Supershape primitive */

function supershape({id, params}){

  const {c,ctx}=makeCanvas(id);

  function r(phi,m,a,b,n1,n2,n3){

    const t1=Math.pow(Math.abs(Math.cos(m*phi/4)/a),n2), t2=Math.pow(Math.abs(Math.sin(m*phi/4)/b),n3);

    return Math.pow(t1+t2,-1/n1);

  }

  let t=0;

  function draw(){

    t+=params.tSpeed;

    const m=params.mBase+params.mAmp*Math.sin(t*params.mRate),

          n1=params.n1Base+params.nAmp*(0.5+0.5*Math.sin(t*params.n1Rate)),

          n2=params.n2Base+params.nAmp*(0.5+0.5*Math.sin(t*params.n2Rate+1.2)),

          n3=params.n3Base+params.nAmp*(0.5+0.5*Math.sin(t*params.n3Rate-0.9));

    ctx.clearRect(0,0,c.width,c.height); ctx.save(); ctx.translate(c.width/2,c.height/2);

    const S=Math.min(c.width,c.height)*params.scale; ctx.scale(S,S);

    ctx.beginPath(); const steps=params.steps;

    for(let i=0;i<=steps;i++){const phi=i/steps*Math.PI*2; const rad=r(phi,m,1,1,n1,n2,n3); const x=rad*Math.cos(phi), y=rad*Math.sin(phi); i?ctx.lineTo(x,y):ctx.moveTo(x,y);}

    ctx.closePath(); const hue=(t*params.hueRate)%360; ctx.fillStyle=`hsla(${hue},70%,55%,${params.fillAlpha})`; ctx.strokeStyle=`hsla(${(hue+180)%360},80%,70%,${params.strokeAlpha})`; ctx.lineWidth=params.lineWidth; ctx.fill(); ctx.stroke(); ctx.restore();

    requestAnimationFrame(draw);

  }

  draw();

  return {code: supershape.toString()};

}

/* Domain coloring primitive for polynomial f(z)=z^n - 1 (n>=2) */

function domainColorPoly({id, params}){

  const {c,ctx}=makeCanvas(id);

  function hsl(h,s,l){s/=100;l/=100;const C=(1-Math.abs(2*l-1))*s,hh=h/60,X=C*(1-Math.abs(hh%2-1));let r=0,g=0,b=0;

    if(hh>=0&&hh<1){r=C;g=X}else if(hh<2){r=X;g=C}else if(hh<3){g=C;b=X}else if(hh<4){g=X;b=C}else if(hh<5){r=X;b=C}else{r=C;b=X}

    const m=l-C/2; return [(r+m)*255,(g+m)*255,(b+m)*255];

  }

  function powN(a,b,n){ // (a+ib)^n

    let ar=a, br=b; for(let k=2;k<=n;k++){

      const na=ar*a - br*b, nb=ar*b + br*a; ar=na; br=nb;

    }

    return [ar,br];

  }

  function plot(){

    const W=c.width,H=c.height, img=ctx.createImageData(W,H), d=img.data, scale=params.scale/Math.min(W,H), cx=W/2, cy=H/2;

    for(let y=0;y<H;y++)for(let x=0;x<W;x++){

      const re=(x-cx)*scale, im=(y-cy)*scale; const z=powN(re,im,params.n); const fr=z[0]-1, fi=z[1];

      const mag=Math.hypot(fr,fi), arg=Math.atan2(fi,fr), hue=((arg/(2*Math.PI))+0.5)*360*params.hueMul;

      const bands=Math.log2(mag+1e-9)*params.bandMul; const light=params.lightBase + params.lightAmp*Math.sin(bands*Math.PI);

      const col=hsl(hue, params.sat, light); const i=(y*W+x)*4; d[i]=col[0]; d[i+1]=col[1]; d[i+2]=col[2]; d[i+3]=255;

    }

    ctx.putImageData(img,0,0);

  }

  plot();

  return {code: domainColorPoly.toString(), rerender: plot};

}

/* Cellular automaton primitive (Rule mask 8-bit) */

function automaton1D({id, params}){

  const {c,ctx}=makeCanvas(id);

  const cell=params.cell, cols=Math.floor(c.width/cell), rows=Math.floor(c.height/cell);

  let row = Array(cols).fill(0).map(()=>Math.random()<params.seed?1:0);

  function nextRow(){

    const next = Array(cols).fill(0);

    for(let x=0;x<cols;x++){

      const a=row[(x-1+cols)%cols], b=row[x], c2=row[(x+1)%cols];

      const n=(a<<2)|(b<<1)|c2; next[x] = (params.rule >> n) & 1;

    }

    row=next;

  }

  let y=0; function step(){

    nextRow();

    for(let x=0;x<cols;x++){

      const v=row[x]?255:0; ctx.fillStyle=`rgb(${v},${v*params.gRatio},${v*params.bRatio})`;

      ctx.fillRect(x*cell,y*cell,cell,cell);

    }

    y++; if(y>=rows){y=0; ctx.clearRect(0,0,c.width,c.height);}

    requestAnimationFrame(step);

  } step();

  return {code: automaton1D.toString()};

}

/* SVG grid warp primitive (conformal-ish) */

function svgGridWarp({id, params}){

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('viewBox','-1 -1 2 2'); svg.style.width='100%'; svg.style.height='60vh'; svg.style.background='var(--stage)';

  function f([x,y]){ const r2=x*x+y*y, inv=r2>1e-6?[x/r2,y/r2]:[0,0]; return [x + params.alpha*inv[0], y + params.alpha*inv[1]]; }

  function line(u0,u1,steps=params.steps){

    const pts=[]; for(let i=0;i<=steps;i++){ const t=i/steps; const x=u0[0]*(1-t)+u1[0]*t, y=u0[1]*(1-t)+u1[1]*t; const [X,Y]=f([x,y]); pts.push(`${X},${Y}`); }

    const el=document.createElementNS(svg.namespaceURI,'polyline'); el.setAttribute('points',pts.join(' ')); el.setAttribute('fill','none'); el.setAttribute('stroke',params.stroke); el.setAttribute('stroke-width',params.sw); el.setAttribute('opacity',params.op); return el;

  }

  for(let i=0;i<params.N;i++){const s=-0.95+1.9*i/(params.N-1); svg.appendChild(line([-0.95,s],[0.95,s])); svg.appendChild(line([s,-0.95],[s,0.95]));}

  appendStage(id,svg);

  return {code: svgGridWarp.toString()};

}

/* CSS gradient block primitive */

function cssBlock({id, params}){

  const div=document.createElement('div'); div.style.width='100%'; div.style.height='60vh'; div.style.background=params.background; div.style.borderRadius=params.radius||'0';

  if(params.overlay){ const ov=document.createElement('div'); ov.style.position='relative'; ov.style.inset='0'; ov.style.width='100%'; ov.style.height='100%'; ov.style.mixBlendMode=params.blend||'screen'; ov.style.background=params.overlay; div.appendChild(ov); }

  appendStage(id,div);

  return {code: cssBlock.toString()};

}

/* Poincaré arcs primitive */

function poincareArcs({id, params}){

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('viewBox','-1 -1 2 2'); svg.style.width='100%'; svg.style.height='60vh'; svg.style.background='var(--stage)';

  const circ=document.createElementNS(svg.namespaceURI,'circle'); circ.setAttribute('cx',0); circ.setAttribute('cy',0); circ.setAttribute('r',1); circ.setAttribute('fill','none'); circ.setAttribute('stroke','#446'); circ.setAttribute('stroke-width','.01'); svg.appendChild(circ);

  function arcThrough(p1,p2){const [x1,y1]=p1,[x2,y2]=p2; const den=x1*y2-x2*y1;

    if(Math.abs(den)<1e-6){const el=document.createElementNS(svg.namespaceURI,'line'); el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2); el.setAttribute('stroke',params.stroke); el.setAttribute('stroke-width','.01'); return el;}

    const s1=(1+x1*x1+y1*y1)/2, s2=(1+x2*x2+y2*y2)/2; const cx=(s1*y2-s2*y1)/den, cy=(x1*s2-x2*s1)/den; const r=Math.sqrt(cx*cx+cy*cy-1);

    const steps=params.steps, pts=[]; const tA=Math.atan2(y1-cy,x1-cx), tB=Math.atan2(y2-cy,x2-cx); let d=tB-tA; if(d>Math.PI) d-=2*Math.PI; if(d<-Math.PI) d+=2*Math.PI;

    for(let i=0;i<=steps;i++){const t=tA+d*i/steps; const x=cx+r*Math.cos(t), y=cy+r*Math.sin(t); pts.push(`${x},${y}`);}

    const el=document.createElementNS(svg.namespaceURI,'polyline'); el.setAttribute('points',pts.join(' ')); el.setAttribute('fill','none'); el.setAttribute('stroke',params.stroke); el.setAttribute('stroke-width','.01'); return el;

  }

  const P=params.P, pts=[]; for(let i=0;i<P;i++){const a=i/P*2*Math.PI; pts.push([Math.cos(a)*params.r, Math.sin(a)*params.r]);}

  for(let i=0;i<P;i++){svg.appendChild(arcThrough(pts[i], pts[(i+params.k1)%P])); svg.appendChild(arcThrough(pts[i], pts[(i+params.k2)%P]));}

  appendStage(id,svg);

  return {code: poincareArcs.toString()};

}

/* ---------- HELPER UTILITIES ---------- */

// Simple 2D noise (value noise)
function noise2D(x, y, seed = 0) {
  const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
  return n - Math.floor(n);
}

// Fractional Brownian Motion (fBm)
function fbm(x, y, octaves = 4, lacunarity = 2, gain = 0.5) {
  let value = 0, amplitude = 1, frequency = 1;
  for (let i = 0; i < octaves; i++) {
    value += amplitude * (noise2D(x * frequency, y * frequency) * 2 - 1);
    amplitude *= gain;
    frequency *= lacunarity;
  }
  return value * 0.5 + 0.5;
}

// Complex number operations
function complexMul(a, b) { return [a[0]*b[0] - a[1]*b[1], a[0]*b[1] + a[1]*b[0]]; }
function complexAdd(a, b) { return [a[0]+b[0], a[1]+b[1]]; }
function complexPow(z, n) {
  let r = Math.hypot(z[0], z[1]), theta = Math.atan2(z[1], z[0]);
  const rn = Math.pow(r, n), thetan = theta * n;
  return [rn * Math.cos(thetan), rn * Math.sin(thetan)];
}

// Voronoi helper
function voronoi(x, y, points) {
  let minDist = Infinity, closest = 0;
  for (let i = 0; i < points.length; i++) {
    const dx = x - points[i][0], dy = y - points[i][1], d = dx*dx + dy*dy;
    if (d < minDist) { minDist = d; closest = i; }
  }
  return { index: closest, dist: Math.sqrt(minDist) };
}

// Circle packing helper
function packCircles(width, height, minR, maxR, attempts = 1000) {
  const circles = [];
  for (let i = 0; i < attempts; i++) {
    const r = minR + Math.random() * (maxR - minR);
    let x = Math.random() * (width - 2*r) + r;
    let y = Math.random() * (height - 2*r) + r;
    let overlaps = false;
    for (const c of circles) {
      const dx = x - c.x, dy = y - c.y, d = Math.hypot(dx, dy);
      if (d < c.r + r) { overlaps = true; break; }
    }
    if (!overlaps) circles.push({x, y, r});
  }
  return circles;
}

/* Helper: make slider */

function slider(id,label,min,max,step,val,onchange){

  const w=document.createElement('div'); w.className='tool'; const inp=document.createElement('input'); inp.type='range'; inp.min=min; inp.max=max; inp.step=step; inp.value=val;

  const lab=document.createElement('label'); lab.textContent=label; const out=document.createElement('span'); out.textContent=val;

  inp.oninput=e=>{out.textContent=e.target.value; onchange(+e.target.value);}; w.appendChild(lab); w.appendChild(inp); w.appendChild(out); appendTool(id,w);

}

function select(id,label,options,val,onchange){

  const w=document.createElement('div'); w.className='tool'; const lab=document.createElement('label'); lab.textContent=label; const sel=document.createElement('select');

  for(const o of options){const opt=document.createElement('option'); opt.value=o.value; opt.textContent=o.label; if(o.value===val) opt.selected=true; sel.appendChild(opt);}

  sel.onchange=e=>onchange(e.target.value); w.appendChild(lab); w.appendChild(sel); appendTool(id,w);

}

/* ---------- INIT FUNCTIONS (mapped keys) ---------- */

/* 49 Reaction–Diffusion (Fake) via feedback blur/high-pass/threshold */

inits["rd-fake"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={seed:0.004, blur:2, hp:0.9, th:0.52, decay:0.995};

  const kernel=[1,2,1,2,4,2,1,2,1];

  function blur(img){const out=ctx.createImageData(img.width,img.height); const w=img.width,h=img.height,d=img.data,o=out.data; const norm=kernel.reduce((a,b)=>a+b,0);

    for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){let acc=0,i=(y*w+x)*4,k=0; for(let j=-1;j<=1;j++)for(let i2=-1;i2<=1;i2++){const p=((y+j)*w+(x+i2))*4; acc+=d[p]*kernel[k++];}

      const v=acc/norm; o[i]=o[i+1]=o[i+2]=v; o[i+3]=255;} return out;}

  function seedImg(){const img=ctx.createImageData(c.width,c.height),d=img.data; for(let i=0;i<d.length;i+=4){const n=Math.random()<params.seed?255:0; d[i]=d[i+1]=d[i+2]=n; d[i+3]=255;} return img;}

  let base=seedImg();

  function step(){let img=ctx.getImageData(0,0,c.width,c.height); for(let p=0;p<params.blur;p++) img=blur(img);

    const d=base.data,b=img.data; for(let i=0;i<d.length;i+=4){const hp=Math.max(0,d[i]*params.hp-b[i]*(1-params.hp)); const v=hp*params.decay+(Math.random()<params.seed*0.2?16:0);

      const t=v/255; const out=t>params.th?255:(t>params.th*0.9?180:24); d[i]=out; d[i+1]=out*0.95; d[i+2]=out*0.8;} ctx.putImageData(base,0,0); requestAnimationFrame(step);}

  ctx.putImageData(base,0,0); step();

  slider(id,"Blur",0,5,1,params.blur,v=>{params.blur=v});

  slider(id,"Threshold",0.1,0.9,0.01,params.th,v=>{params.th=v});

  setCode(id, step.toString());

};

/* 50 Soap Film (CSS conics + highlights) */

inits["soap-film"]=({id})=>{

  const background=`

    conic-gradient(from 0deg,

      rgba(255,255,255,.0) 0 10%, rgba(255,255,255,.15) 12% 14%, transparent 16% 100%),

    conic-gradient(from 210deg,

      #ff0068 0 11%, #ffd500 12% 23%, #66ff00 24% 35%, #00e1ff 36% 47%, #b100ff 48% 59%, #ff0068 60% 71%, #ffd500 72% 83%, #66ff00 84% 95%, #00e1ff 96% 100%)

  `;

  const overlay=`

    radial-gradient(120% 120% at 15% 20%, rgba(255,255,255,.5), transparent 40%),

    radial-gradient(80% 80% at 70% 75%, rgba(255,255,255,.35), transparent 45%)

  `;

  const {code}=cssBlock({id, params:{background, overlay, radius:'50%', blend:'screen'}});

  setCode(id, cssBlock.toString());

};

/* 51 Conformal Grid Lens (SVG warp) */

inits["conformal-grid"]=({id})=>{

  const {code}=svgGridWarp({id, params:{alpha:0.18, N:22, steps:120, stroke:"#8fd", sw:".01", op:".9"}});

  setCode(id, svgGridWarp.toString());

};

/* 52 Iso Cubes (CSS repeating linear-gradients) */

inits["iso-cubes"]=({id})=>{

  const sz=36;

  const background=`

    repeating-linear-gradient(150deg, #15253e 0 ${sz}px, transparent ${sz}px ${sz*2}px),

    repeating-linear-gradient(30deg,  #1f3a5f  0 ${sz}px, transparent ${sz}px ${sz*2}px),

    repeating-linear-gradient(90deg,  #2b4f7f  0 ${sz}px, transparent ${sz}px ${sz*2}px)

  `;

  const {code}=cssBlock({id, params:{background}});

  slider(id,"Tile size",16,80,2,sz,v=>{

    const bg=`

      repeating-linear-gradient(150deg, #15253e 0 ${v}px, transparent ${v}px ${v*2}px),

      repeating-linear-gradient(30deg,  #1f3a5f  0 ${v}px, transparent ${v}px ${v*2}px),

      repeating-linear-gradient(90deg,  #2b4f7f  0 ${v}px, transparent ${v}px ${v*2}px)

    `;

    document.getElementById('stage-'+id).firstChild.style.background=bg;

  });

  setCode(id, cssBlock.toString());

};

/* 53 Supershape Flowers */

inits["supershape"]=({id})=>{

  const {code}=supershape({id, params:{

    tSpeed:0.008, mBase:3, mAmp:3, mRate:0.37, n1Base:0.2, n2Base:0.2, n3Base:0.2, nAmp:1.1,

    n1Rate:0.23, n2Rate:0.31, n3Rate:0.29, scale:0.35, steps:800, hueRate:40, fillAlpha:0.4, strokeAlpha:0.9, lineWidth:0.01

  }});

  setCode(id, supershape.toString());

};

/* 54 Domain Coloring z^n - 1 */

inits["domain-coloring"]=({id})=>{

  const params={n:3, scale:3, hueMul:1, bandMul:1, lightBase:50, lightAmp:25, sat:95};

  const inst=domainColorPoly({id, params});

  slider(id,"Power n",2,6,1,params.n,v=>{params.n=v; inst.rerender();});

  slider(id,"Scale",1,6,0.1,params.scale,v=>{params.scale=v; inst.rerender();});

  setCode(id, domainColorPoly.toString());

};

/* 55 Rule 110 Automaton */

inits["rule110"]=({id})=>{

  const {code}=automaton1D({id, params:{cell:2, seed:0.5, rule:0b01101110, gRatio:0.6, bRatio:0.2}});

  slider(id,"Cell size",1,6,1,2,v=>{}); // visual; recreates on resize naturally

  setCode(id, automaton1D.toString());

};

/* 56 Impossible Triangle (CSS clip-path + gradients) */

inits["impossible-triangle"]=({id})=>{

  const background=`

    linear-gradient(135deg,#7bd 0 50%,transparent 0),

    linear-gradient(315deg,#59a 0 50%,transparent 0),

    linear-gradient(45deg,#9fe  0 50%,transparent 0)

  `;

  const div=document.createElement('div'); div.style.width='100%'; div.style.height='60vh'; div.style.background=background; div.style.clipPath='polygon(50% 4%, 96% 29%, 96% 31%, 55% 8%, 55% 42%, 53% 43%, 53% 8%, 9% 32%, 9% 29%)'; div.style.filter='drop-shadow(0 2vmin 3vmin rgba(0,0,0,.5))';

  appendStage(id,div);

  setCode(id, inits["impossible-triangle"].toString());

};

/* 57 Magnetic Orbs (particle field) */

inits["magnetic-orbs"]=({id})=>{

  const {code}=particleField({id, params:{count:220, speed:1.2, sizeMin:1.4, sizeMax:3.2, hueDrift:0.6, fade:0.18, radius:120, strength:10, accel:0.03, drag:0.98}});

  slider(id,"Count",60,400,10,220,v=>{}); // demo keeps fixed count at init for perf; can reinit for changes if needed

  setCode(id, particleField.toString());

};

/* 58 Chromaburst Text (CSS bg-clip:text + conics) */

inits["chromaburst"]=({id})=>{

  const div=document.createElement('div'); div.style.display='grid'; div.style.placeItems='center'; div.style.height='60vh'; div.style.background='#0a0e14';

  const h=document.createElement('h1'); h.textContent='CHROMABURST'; h.style.font='900 14vmin/1 system-ui'; h.style.letterSpacing='.02em'; h.style.color='transparent'; h.style.webkitBackgroundClip='text'; h.style.backgroundClip='text';

  function setBG(x='50%',y='50%',zoom=300){

    h.style.background=`

      conic-gradient(from 270deg at ${x} ${y}, #fff 265deg, #ff647f 269deg 271deg, #fff 275deg) left/0% 1em no-repeat,

      radial-gradient(circle at ${x} ${y}, hsl(200 100% 60% / .5), hsl(280 100% 60% / .5), hsl(60 100% 60% / .5)) 0/${zoom}% ${zoom}%

    `;

  }

  setBG();

  div.appendChild(h); appendStage(id,div);

  div.onpointermove=e=>{const r=h.getBoundingClientRect(), x=((e.clientX-r.left)/r.width*100).toFixed(2)+'%', y=((e.clientY-r.top)/r.height*100).toFixed(2)+'%'; setBG(x,y,300);}

  setCode(id, inits["chromaburst"].toString());

};

/* 59 Recursive Mask Tunnel (CSS radial XOR) */

inits["mask-tunnel"]=({id})=>{

  const box=document.createElement('div'); box.style.width='100%'; box.style.height='60vh'; box.style.display='grid'; box.style.placeItems='center'; box.style.background='#05070a';

  const hole=document.createElement('div'); hole.style.width='70vmin'; hole.style.aspectRatio='1'; hole.style.animation='spinTunnel 12s linear infinite';

  const style=document.createElement('style'); style.textContent=`@keyframes spinTunnel{to{transform:rotate(360deg)}}`; document.head.appendChild(style);

  hole.style.webkitMaskComposite='xor';

  hole.style.webkitMaskImage=`

    radial-gradient(closest-side, transparent 35%, black 36%),

    radial-gradient(closest-side, transparent 45%, black 46%),

    radial-gradient(closest-side, transparent 55%, black 56%),

    radial-gradient(closest-side, transparent 65%, black 66%),

    radial-gradient(closest-side, transparent 75%, black 76%),

    radial-gradient(closest-side, transparent 85%, black 86%)

  `;

  hole.style.webkitMaskPosition='50% 50%'; hole.style.webkitMaskRepeat='no-repeat';

  const inner=document.createElement('div'); inner.style.width='100%'; inner.style.height='100%';

  inner.style.background=`

    radial-gradient(closest-side,#0e1623,transparent 60%),

    conic-gradient(from 0deg, #1a2b44, #0e1623, #1a2b44)

  `;

  inner.style.filter='contrast(120%) saturate(120%)';

  hole.appendChild(inner); box.appendChild(hole); appendStage(id,box);

  setCode(id, inits["mask-tunnel"].toString());

};

/* 60 Poincaré Vibes (hyperbolic arcs) */

inits["poincare"]=({id})=>{

  const {code}=poincareArcs({id, params:{P:12, r:0.98, k1:2, k2:3, steps:120, stroke:'#58c'}});

  setCode(id, poincareArcs.toString());

};

/* 61 Radial Moiré */

inits["moire-lines"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={angle1:0, angle2:0.3, density:80, speed:0.01};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=1;

    const cx=c.width/2, cy=c.height/2, maxR=Math.hypot(cx,cy);

    params.angle1+=params.speed; params.angle2-=params.speed*0.7;

    for(let r=0;r<maxR;r+=params.density){

      const steps=Math.floor(r*0.1)+8;

      for(let i=0;i<steps;i++){

        const a1=i/steps*Math.PI*2+params.angle1, a2=i/steps*Math.PI*2+params.angle2;

        const x1=cx+Math.cos(a1)*r, y1=cy+Math.sin(a1)*r;

        const x2=cx+Math.cos(a2)*r, y2=cy+Math.sin(a2)*r;

        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Density",20,150,5,params.density,v=>{params.density=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 67 Lissajous Lace */

inits["lissajous"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={Ax:3, Ay:2, phase:0, speed:0.02, steps:800};

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    ctx.beginPath();

    params.phase+=params.speed;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.3;

    for(let i=0;i<=params.steps;i++){

      const t=i/params.steps*Math.PI*2;

      const x=cx+Math.cos(params.Ax*t+params.phase)*scale;

      const y=cy+Math.sin(params.Ay*t)*scale;

      i?ctx.lineTo(x,y):ctx.moveTo(x,y);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Ax",1,8,1,params.Ax,v=>{params.Ax=v});

  slider(id,"Ay",1,8,1,params.Ay,v=>{params.Ay=v});

  slider(id,"Speed",0,0.1,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 68 Superellipse Frames */

inits["superellipse"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={n:2.5, a:1, b:1, count:8, rotation:0, speed:0.01};

  function superellipse(phi,n,a,b){

    const cos=Math.cos(phi), sin=Math.sin(phi);

    const r=Math.pow(Math.pow(Math.abs(cos/a),n)+Math.pow(Math.abs(sin/b),n),-1/n);

    return [r*cos, r*sin];

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    params.rotation+=params.speed;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.35;

    for(let layer=0;layer<params.count;layer++){

      const s=scale*(1-layer*0.12), hue=(layer*30+params.rotation*50)%360;

      ctx.strokeStyle=`hsl(${hue},80%,60%)`; ctx.lineWidth=2;

      ctx.beginPath();

      const steps=200;

      for(let i=0;i<=steps;i++){

        const phi=i/steps*Math.PI*2+params.rotation;

        const [x,y]=superellipse(phi,params.n,params.a,params.b);

        const px=cx+x*s, py=cy+y*s;

        i?ctx.lineTo(px,py):ctx.moveTo(px,py);

      }

      ctx.closePath(); ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Exponent n",0.5,5,0.1,params.n,v=>{params.n=v});

  slider(id,"Count",3,15,1,params.count,v=>{params.count=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 99 Modulus Bands */

inits["mod-bands"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={mod:8, angle:0.3, speed:0.01};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    params.angle+=params.speed;

    const cx=c.width/2, cy=c.height/2;

    ctx.strokeStyle='rgba(86,194,255,0.7)'; ctx.lineWidth=1;

    for(let y=0;y<c.height;y+=2){

      for(let x=0;x<c.width;x+=2){

        const dx=x-cx, dy=y-cy;

        const dist=Math.hypot(dx,dy);

        const angle=Math.atan2(dy,dx)+params.angle;

        const band=Math.floor((dist*0.1+angle*params.mod)%params.mod);

        if(band%2===0){

          ctx.fillStyle=`hsla(${(band*45)%360},70%,60%,0.6)`;

          ctx.fillRect(x-1,y-1,3,3);

        }

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Mod k",2,20,1,params.mod,v=>{params.mod=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 104 Polar Roses */

inits["polar-roses"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={k:3, n:5, d:7, thickness:0.02, speed:0.01};

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.15)'; ctx.fillRect(0,0,c.width,c.height);

    params.k+=params.speed*0.1;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.4;

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=params.thickness*scale;

    ctx.beginPath();

    const steps=800;

    for(let i=0;i<=steps;i++){

      const theta=i/steps*Math.PI*2*params.d;

      const r=Math.cos(params.k*theta/params.n)*scale;

      const x=cx+r*Math.cos(theta), y=cy+r*Math.sin(theta);

      i?ctx.lineTo(x,y):ctx.moveTo(x,y);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"k",1,10,0.5,params.k,v=>{params.k=v});

  slider(id,"n",1,10,1,params.n,v=>{params.n=v});

  slider(id,"d",1,10,1,params.d,v=>{params.d=v});

  slider(id,"Thickness",0.005,0.05,0.001,params.thickness,v=>{params.thickness=v});

  setCode(id, draw.toString());

};

/* 105 Hypnotic Conics */

inits["conics"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={eccentricity:0.7, count:12, phase:0, speed:0.01};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    params.phase+=params.speed;

    const cx=c.width/2, cy=c.height/2, a=Math.min(c.width,c.height)*0.3;

    for(let i=0;i<params.count;i++){

      const phi=i/params.count*Math.PI*2+params.phase;

      const b=a*Math.sqrt(1-params.eccentricity*params.eccentricity);

      const hue=(i*30)%360;

      ctx.strokeStyle=`hsl(${hue},80%,60%)`; ctx.lineWidth=2;

      ctx.beginPath();

      const steps=200;

      for(let j=0;j<=steps;j++){

        const t=j/steps*Math.PI*2;

        const x=cx+Math.cos(phi)*a*Math.cos(t)-Math.sin(phi)*b*Math.sin(t);

        const y=cy+Math.sin(phi)*a*Math.cos(t)+Math.cos(phi)*b*Math.sin(t);

        j?ctx.lineTo(x,y):ctx.moveTo(x,y);

      }

      ctx.closePath(); ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Eccentricity",0.1,0.95,0.05,params.eccentricity,v=>{params.eccentricity=v});

  slider(id,"Count",3,24,1,params.count,v=>{params.count=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 89 Spirograph Engines */

inits["spirograph"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={R:120, r:40, d:60, speed:0.02};

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    params.speed+=0;

    const cx=c.width/2, cy=c.height/2;

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    ctx.beginPath();

    const steps=1000;

    for(let i=0;i<=steps;i++){

      const t=i/steps*Math.PI*2*10;

      const x=cx+(params.R-params.r)*Math.cos(t)+params.d*Math.cos((params.R-params.r)/params.r*t);

      const y=cy+(params.R-params.r)*Math.sin(t)-params.d*Math.sin((params.R-params.r)/params.r*t);

      i?ctx.lineTo(x,y):ctx.moveTo(x,y);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"R",50,200,5,params.R,v=>{params.R=v});

  slider(id,"r",10,100,5,params.r,v=>{params.r=v});

  slider(id,"d",10,100,5,params.d,v=>{params.d=v});

  setCode(id, draw.toString());

};

/* 121 Radial Gradient Weave */

inits["radial-weave"]=({id})=>{

  const div=document.createElement('div'); div.style.width='100%'; div.style.height='60vh';

  const params={stops:8, phase:0, speed:0.01};

  function update(){

    const stops=[];

    for(let i=0;i<params.stops;i++){

      const offset=i/params.stops*100;

      const hue=(i*360/params.stops+params.phase*100)%360;

      stops.push(`hsl(${hue},80%,50%) ${offset}%`);

      stops.push(`hsl(${hue},80%,30%) ${offset+50/params.stops}%`);

    }

    div.style.background=`radial-gradient(circle, ${stops.join(', ')})`;

    params.phase+=params.speed;

    requestAnimationFrame(update);

  }

  update();

  appendStage(id,div);

  slider(id,"Stops",4,16,1,params.stops,v=>{params.stops=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, update.toString());

};

/* 62 Perlin Smoke Sheets */

inits["perlin-smoke"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={freq:0.02, octaves:3, contrast:1.2, speed:0.005, time:0};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n=fbm(x*params.freq, y*params.freq+params.time, params.octaves, 2, 0.5);

        const v=Math.pow(n, params.contrast)*255;

        const i=(y*c.width+x)*4;

        d[i]=v*0.8; d[i+1]=v*0.9; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Frequency",0.005,0.05,0.001,params.freq,v=>{params.freq=v});

  slider(id,"Octaves",1,6,1,params.octaves,v=>{params.octaves=v});

  slider(id,"Contrast",0.5,2,0.1,params.contrast,v=>{params.contrast=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 87 Topo Contour Lines */

inits["contours"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={freq:0.03, levels:12, lineWidth:1.5};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const heights=[];

    for(let y=0;y<c.height;y+=2){

      heights[y]=[];

      for(let x=0;x<c.width;x+=2){

        heights[y][x]=fbm(x*params.freq, y*params.freq, 4, 2, 0.5);

      }

    }

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=params.lineWidth;

    for(let level=0;level<=params.levels;level++){

      const threshold=level/params.levels;

      for(let y=0;y<c.height-2;y+=2){

        for(let x=0;x<c.width-2;x+=2){

          const h=heights[y][x], hx=heights[y][x+2]||h, hy=heights[y+2]?heights[y+2][x]:h;

          if((h<threshold && (hx>=threshold||hy>=threshold)) || (h>=threshold && (hx<threshold||hy<threshold))){

            ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+2,y); ctx.stroke();

          }

        }

      }

    }

  }

  draw();

  slider(id,"Frequency",0.01,0.1,0.005,params.freq,v=>{params.freq=v; draw();});

  slider(id,"Levels",4,24,1,params.levels,v=>{params.levels=v; draw();});

  setCode(id, draw.toString());

};

/* 102 Worley Noise Cells */

inits["worley"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={points:20, metric:2, time:0, speed:0.002};

  const points=Array(params.points).fill().map(()=>({x:Math.random(), y:Math.random(), vx:Math.random()*0.002-0.001, vy:Math.random()*0.002-0.001}));

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const px=x/c.width, py=y/c.height;

        let minDist=Infinity, secondMin=Infinity;

        for(const p of points){

          let dx=px-p.x, dy=py-p.y;

          if(dx>0.5) dx-=1; if(dx<-0.5) dx+=1;

          if(dy>0.5) dy-=1; if(dy<-0.5) dy+=1;

          const dist=Math.pow(Math.pow(Math.abs(dx),params.metric)+Math.pow(Math.abs(dy),params.metric),1/params.metric);

          if(dist<minDist){ secondMin=minDist; minDist=dist; } else if(dist<secondMin){ secondMin=dist; }

        }

        const v=Math.min(255, (secondMin-minDist)*800);

        const i=(y*c.width+x)*4;

        d[i]=v*0.6; d[i+1]=v*0.8; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const p of points){

      p.x+=p.vx; p.y+=p.vy;

      if(p.x<0||p.x>1){p.vx*=-1; p.x=Math.max(0,Math.min(1,p.x));}

      if(p.y<0||p.y>1){p.vy*=-1; p.y=Math.max(0,Math.min(1,p.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Points",5,50,1,params.points,v=>{params.points=v; points.length=0; for(let i=0;i<v;i++) points.push({x:Math.random(), y:Math.random(), vx:Math.random()*0.002-0.001, vy:Math.random()*0.002-0.001});});

  slider(id,"Metric",1,4,0.5,params.metric,v=>{params.metric=v});

  setCode(id, draw.toString());

};

/* 116 fBm Sky */

inits["fbm-sky"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={octaves:4, lacunarity:2, gain:0.5, time:0, speed:0.003};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n=fbm(x*0.01, y*0.01+params.time, params.octaves, params.lacunarity, params.gain);

        const hue=(n*60+200)%360;

        const i=(y*c.width+x)*4;

        const r=Math.sin(hue*Math.PI/180)*127+128, g=Math.sin((hue+120)*Math.PI/180)*127+128, b=Math.sin((hue+240)*Math.PI/180)*127+128;

        d[i]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Octaves",2,8,1,params.octaves,v=>{params.octaves=v});

  slider(id,"Lacunarity",1.5,3,0.1,params.lacunarity,v=>{params.lacunarity=v});

  slider(id,"Gain",0.3,0.7,0.05,params.gain,v=>{params.gain=v});

  slider(id,"Speed",0,0.01,0.0005,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 125 Signed Noise Marble */

inits["marble"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={warp:2, freq:0.02, time:0, speed:0.005};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const wx=x+Math.sin(y*params.freq+params.time)*params.warp;

        const wy=y+Math.cos(x*params.freq+params.time)*params.warp;

        const n=fbm(wx*params.freq, wy*params.freq, 4, 2, 0.5);

        const v=Math.sin(n*Math.PI*8)*0.5+0.5;

        const i=(y*c.width+x)*4;

        const col=v*255;

        d[i]=col*0.9; d[i+1]=col*0.95; d[i+2]=col; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Warp",0.5,5,0.1,params.warp,v=>{params.warp=v});

  slider(id,"Frequency",0.005,0.05,0.001,params.freq,v=>{params.freq=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 146 Hypershift Gradient Nebula */

inits["nebula"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={octaves:3, speed:0.003, time:0};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n1=fbm(x*0.01, y*0.01+params.time, params.octaves, 2, 0.5);

        const n2=fbm(x*0.015+params.time*0.5, y*0.015, params.octaves, 2, 0.5);

        const hue=(n1*120+200)%360, sat=n2*50+50, light=n1*30+40;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=sat/100, l=light/100, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Octaves",2,6,1,params.octaves,v=>{params.octaves=v});

  slider(id,"Speed",0,0.01,0.0005,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 92 Newton Fractal z³−1 */

inits["newton"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={maxIters:50, zoom:2, n:3};

  function newton(z){

    const [re,im]=z;

    let zr=re, zi=im;

    for(let i=0;i<params.maxIters;i++){

      const mag2=zr*zr+zi*zi;

      if(mag2<1e-10) return {iter:i, root:0};

      const [znr, zni]=complexPow([zr,zi], params.n);

      const [znr1, zni1]=complexPow([zr,zi], params.n-1);

      const denom=params.n*(znr1*znr1+zni1*zni1);

      if(denom<1e-10) return {iter:i, root:0};

      zr=zr-(znr-1)*znr1/denom+(zni-0)*zni1/denom;

      zi=zi-(zni-0)*znr1/denom-(znr-1)*zni1/denom;

      if(zr*zr+zi*zi>100) return {iter:i, root:Math.floor(Math.atan2(zi,zr)*params.n/Math.PI/2+params.n)%params.n};

    }

    return {iter:params.maxIters, root:Math.floor(Math.atan2(zi,zr)*params.n/Math.PI/2+params.n)%params.n};

  }

  function draw(){

    const img=ctx.createImageData(c.width,c.height), d=img.data, scale=params.zoom/Math.min(c.width,c.height), cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const re=(x-cx)*scale, im=(y-cy)*scale;

        const {iter, root}=newton([re,im]);

        const hue=(root*360/params.n+iter*5)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.8, l=0.3+iter/params.maxIters*0.4, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

  }

  draw();

  slider(id,"Max Iters",10,100,5,params.maxIters,v=>{params.maxIters=v; draw();});

  slider(id,"Zoom",0.5,5,0.1,params.zoom,v=>{params.zoom=v; draw();});

  slider(id,"Power n",2,6,1,params.n,v=>{params.n=v; draw();});

  setCode(id, draw.toString());

};

/* 93 Barnsley Fern */

inits["fern"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={iterations:50000, blur:true};

  const transforms=[

    {p:0.01, a:0, b:0, c:0, d:0.16, e:0, f:0},

    {p:0.85, a:0.85, b:0.04, c:-0.04, d:0.85, e:0, f:1.6},

    {p:0.07, a:0.2, b:-0.26, c:0.23, d:0.22, e:0, f:1.6},

    {p:0.07, a:-0.15, b:0.28, c:0.26, d:0.24, e:0, f:0.44}

  ];

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    let x=0, y=0;

    for(let i=0;i<params.iterations;i++){

      const r=Math.random();

      let sum=0, t=transforms[0];

      for(const tr of transforms){

        sum+=tr.p;

        if(r<sum){ t=tr; break; }

      }

      const nx=t.a*x+t.b*y+t.e;

      const ny=t.c*x+t.d*y+t.f;

      x=nx; y=ny;

      const px=Math.floor((x+2.5)/5*c.width);

      const py=Math.floor((1-y/10)*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        const idx=(py*c.width+px)*4;

        d[idx]=Math.min(255, d[idx]+8);

        d[idx+1]=Math.min(255, d[idx+1]+12);

        d[idx+2]=Math.min(255, d[idx+2]+4);

        d[idx+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

  }

  draw();

  slider(id,"Iterations",10000,100000,5000,params.iterations,v=>{params.iterations=v; draw();});

  setCode(id, draw.toString());

};

/* 94 Koch Snowflake */

inits["koch"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:4};

  function kochLine(x1,y1,x2,y2,depth){

    if(depth===0){

      ctx.lineTo(x2,y2);

      return;

    }

    const dx=x2-x1, dy=y2-y1;

    const x3=x1+dx/3, y3=y1+dy/3;

    const x4=x2-dx/3, y4=y2-dy/3;

    const mx=(x1+x2)/2, my=(y1+y2)/2;

    const len=Math.hypot(dx,dy)/3;

    const angle=Math.atan2(dy,dx);

    const x5=mx+Math.cos(angle+Math.PI/3)*len;

    const y5=my+Math.sin(angle+Math.PI/3)*len;

    kochLine(x1,y1,x3,y3,depth-1);

    kochLine(x3,y3,x5,y5,depth-1);

    kochLine(x5,y5,x4,y4,depth-1);

    kochLine(x4,y4,x2,y2,depth-1);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.35;

    const x1=cx, y1=cy-size;

    const x2=cx+size*Math.cos(Math.PI*2/3), y2=cy+size*Math.sin(Math.PI*2/3);

    const x3=cx+size*Math.cos(-Math.PI*2/3), y3=cy+size*Math.sin(-Math.PI*2/3);

    ctx.beginPath();

    ctx.moveTo(x1,y1);

    kochLine(x1,y1,x2,y2,params.depth);

    kochLine(x2,y2,x3,y3,params.depth);

    kochLine(x3,y3,x1,y1,params.depth);

    ctx.closePath();

    ctx.stroke();

  }

  draw();

  slider(id,"Depth",0,6,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 95 Dragon Curve Ribbon */

inits["dragon"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:12, thickness:2};

  function dragon(x1,y1,x2,y2,depth,turn){

    if(depth===0){

      ctx.beginPath();

      ctx.moveTo(x1,y1);

      ctx.lineTo(x2,y2);

      ctx.stroke();

      return;

    }

    const dx=x2-x1, dy=y2-y1;

    const mx=(x1+x2)/2, my=(y1+y2)/2;

    const perpx=-dy, perpy=dx;

    const len=Math.hypot(dx,dy);

    const x3=mx+perpx*0.5*len/Math.hypot(perpx,perpy)*(turn?1:-1);

    const y3=my+perpy*0.5*len/Math.hypot(perpx,perpy)*(turn?1:-1);

    dragon(x1,y1,x3,y3,depth-1,true);

    dragon(x3,y3,x2,y2,depth-1,false);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=params.thickness;

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.4;

    dragon(cx-size,cy, cx+size,cy, params.depth, true);

  }

  draw();

  slider(id,"Depth",5,15,1,params.depth,v=>{params.depth=v; draw();});

  slider(id,"Thickness",1,5,0.5,params.thickness,v=>{params.thickness=v; ctx.lineWidth=v; draw();});

  setCode(id, draw.toString());

};

/* 96 Hilbert Space Fill */

inits["hilbert"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={order:5};

  function hilbert(x,y,xi,yi,xj,yj,n){

    if(n<=0){

      const px=(x+(xi+yi)/2)*c.width;

      const py=(y+(xj+yj)/2)*c.height;

      ctx.lineTo(px,py);

    } else {

      hilbert(x,y,yj/2,yi/2,xj/2,xi/2,n-1);

      hilbert(x+xi/2,y+xj/2,xi/2,yi/2,xj/2,yj/2,n-1);

      hilbert(x+xi/2+yi/2,y+xj/2+yj/2,xi/2,yi/2,xj/2,yj/2,n-1);

      hilbert(x+xi/2+yi,y+xj/2+yj,-yj/2,-yi/2,-xj/2,-xi/2,n-1);

    }

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    ctx.beginPath();

    hilbert(0,0,1,0,0,1,params.order);

    ctx.stroke();

  }

  draw();

  slider(id,"Order",2,8,1,params.order,v=>{params.order=v; draw();});

  setCode(id, draw.toString());

};

/* 134 Sierpinski Tri Tiles */

inits["sierpinski"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:5};

  function sierpinski(x1,y1,x2,y2,x3,y3,depth){

    if(depth===0){

      ctx.beginPath();

      ctx.moveTo(x1,y1);

      ctx.lineTo(x2,y2);

      ctx.lineTo(x3,y3);

      ctx.closePath();

      ctx.fill();

      return;

    }

    const mx1=(x1+x2)/2, my1=(y1+y2)/2;

    const mx2=(x2+x3)/2, my2=(y2+y3)/2;

    const mx3=(x3+x1)/2, my3=(y3+y1)/2;

    sierpinski(x1,y1,mx1,my1,mx3,my3,depth-1);

    sierpinski(mx1,my1,x2,y2,mx2,my2,depth-1);

    sierpinski(mx3,my3,mx2,my2,x3,y3,depth-1);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.fillStyle='#56c2ff';

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.4;

    const x1=cx, y1=cy-size;

    const x2=cx-size*Math.cos(Math.PI/6), y2=cy+size*Math.sin(Math.PI/6);

    const x3=cx+size*Math.cos(Math.PI/6), y3=cy+size*Math.sin(Math.PI/6);

    sierpinski(x1,y1,x2,y2,x3,y3,params.depth);

  }

  draw();

  slider(id,"Depth",0,7,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 91 Menger Carpet Cuts */

inits["menger"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:3, cell:Math.min(c.width,c.height)/3};

  function menger(x,y,size,depth){

    if(depth===0){

      ctx.fillRect(x,y,size,size);

      return;

    }

    const s=size/3;

    for(let i=0;i<3;i++){

      for(let j=0;j<3;j++){

        if(i===1&&j===1) continue;

        menger(x+i*s, y+j*s, s, depth-1);

      }

    }

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.fillStyle='#56c2ff';

    const cx=c.width/2, cy=c.height/2, size=params.cell;

    menger(cx-size/2, cy-size/2, size, params.depth);

  }

  draw();

  slider(id,"Depth",0,4,1,params.depth,v=>{params.depth=v; draw();});

  slider(id,"Cell size",50,300,10,params.cell,v=>{params.cell=v; draw();});

  setCode(id, draw.toString());

};

/* 66 Apollonian Gasket */

inits["apollonian"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:5};

  function apollonian(x1,y1,r1, x2,y2,r2, x3,y3,r3, depth){

    if(depth===0) return;

    const k1=1/r1, k2=1/r2, k3=1/r3;

    const s=k1+k2+k3+2*Math.sqrt(k1*k2+k2*k3+k3*k1);

    const k4=s;

    const r4=1/k4;

    const d12=Math.hypot(x2-x1,y2-y1), d13=Math.hypot(x3-x1,y3-y1), d23=Math.hypot(x3-x2,y3-y2);

    const x4=(k1*x1+k2*x2+k3*x3+Math.sqrt(k1*k2*(d12*d12-r1*r1-r2*r2)+k2*k3*(d23*d23-r2*r2-r3*r3)+k3*k1*(d13*d13-r1*r1-r3*r3)))/k4;

    const y4=(k1*y1+k2*y2+k3*y3)/k4;

    ctx.beginPath();

    ctx.arc(x4,y4,r4,0,Math.PI*2);

    ctx.stroke();

    apollonian(x1,y1,r1, x2,y2,r2, x4,y4,r4, depth-1);

    apollonian(x1,y1,r1, x4,y4,r4, x3,y3,r3, depth-1);

    apollonian(x4,y4,r4, x2,y2,r2, x3,y3,r3, depth-1);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1;

    const cx=c.width/2, cy=c.height/2, r=Math.min(c.width,c.height)*0.3;

    ctx.beginPath();

    ctx.arc(cx,cy,r,0,Math.PI*2);

    ctx.stroke();

    const r1=r*0.5, r2=r*0.3, r3=r*0.2;

    const x1=cx, y1=cy-r+r1;

    const x2=cx-r*0.6, y2=cy+r*0.4;

    const x3=cx+r*0.6, y3=cy+r*0.4;

    apollonian(x1,y1,r1, x2,y2,r2, x3,y3,r3, params.depth);

  }

  draw();

  slider(id,"Depth",1,6,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 75 Circle Packing Waves */

inits["circle-pack"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={minR:5, maxR:30, pulse:0, speed:0.02};

  const circles=packCircles(c.width, c.height, params.minR, params.maxR, 200);

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    params.pulse+=params.speed;

    for(const circ of circles){

      const pulse=Math.sin(params.pulse+circ.x*0.01)*0.3+1;

      const r=circ.r*pulse;

      const hue=(circ.x/c.width*360+params.pulse*50)%360;

      ctx.fillStyle=`hsla(${hue},80%,60%,0.6)`;

      ctx.beginPath();

      ctx.arc(circ.x,circ.y,r,0,Math.PI*2);

      ctx.fill();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Speed",0,0.1,0.01,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 147 Voronoi Bloom */

inits["voronoi"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={sites:30, jitter:0.1, time:0, speed:0.002};

  const sites=Array(params.sites).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1}));

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let minDist=Infinity, closest=0;

        for(let i=0;i<sites.length;i++){

          const dx=x-sites[i].x, dy=y-sites[i].y, dist=dx*dx+dy*dy;

          if(dist<minDist){ minDist=dist; closest=i; }

        }

        const v=Math.min(255, Math.sqrt(minDist)*2);

        const hue=(closest*360/sites.length)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.6, l=v/255*0.5+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const s of sites){

      s.x+=s.vx; s.y+=s.vy;

      if(s.x<0||s.x>c.width){s.vx*=-1; s.x=Math.max(0,Math.min(c.width,s.x));}

      if(s.y<0||s.y>c.height){s.vy*=-1; s.y=Math.max(0,Math.min(c.height,s.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Sites",10,60,1,params.sites,v=>{params.sites=v; sites.length=0; for(let i=0;i<v;i++) sites.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1});});

  setCode(id, draw.toString());

};

/* 100 Phyllotaxis Seeds */

inits["phyllotaxis"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={angle:137.508, spacing:4, count:500, size:3};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2;

    for(let i=0;i<params.count;i++){

      const a=i*params.angle*Math.PI/180;

      const r=Math.sqrt(i)*params.spacing;

      const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;

      const hue=(i*10)%360;

      ctx.fillStyle=`hsl(${hue},80%,60%)`;

      ctx.beginPath();

      ctx.arc(x,y,params.size,0,Math.PI*2);

      ctx.fill();

    }

  }

  draw();

  slider(id,"Angle",100,200,1,params.angle,v=>{params.angle=v; draw();});

  slider(id,"Spacing",2,8,0.5,params.spacing,v=>{params.spacing=v; draw();});

  slider(id,"Count",100,1000,50,params.count,v=>{params.count=v; draw();});

  setCode(id, draw.toString());

};

/* 69 Clifford Attractor Glow */

inits["clifford"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={a:-1.4, b:1.6, c:1.0, d:0.7, points:50000, decay:0.98};

  const density=Array(c.width*c.height).fill(0);

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.05)'; ctx.fillRect(0,0,c.width,c.height);

    let x=0, y=0;

    for(let i=0;i<params.points;i++){

      const nx=Math.sin(params.a*y)+params.c*Math.cos(params.a*x);

      const ny=Math.sin(params.b*x)+params.d*Math.cos(params.b*y);

      x=nx; y=ny;

      const px=Math.floor((x+2)/4*c.width);

      const py=Math.floor((y+2)/4*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        const idx=py*c.width+px;

        density[idx]=Math.min(255, density[idx]+2);

      }

    }

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<density.length;i++){

      density[i]*=params.decay;

      const v=density[i];

      const idx=i*4;

      d[idx]=v*0.6; d[idx+1]=v*0.8; d[idx+2]=v; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"a",-2,2,0.1,params.a,v=>{params.a=v});

  slider(id,"b",-2,2,0.1,params.b,v=>{params.b=v});

  slider(id,"Points",10000,100000,5000,params.points,v=>{params.points=v});

  setCode(id, draw.toString());

};

/* 70 Ikeda Map Mist */

inits["ikeda"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={u:0.918, points:30000, decay:0.995};

  const density=Array(c.width*c.height).fill(0);

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    let x=0.1, y=0.1;

    for(let i=0;i<params.points;i++){

      const t=0.4-6/(1+x*x+y*y);

      const nx=1+params.u*(x*Math.cos(t)-y*Math.sin(t));

      const ny=params.u*(x*Math.sin(t)+y*Math.cos(t));

      x=nx; y=ny;

      const px=Math.floor((x+2)/4*c.width);

      const py=Math.floor((y+2)/4*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        const idx=py*c.width+px;

        density[idx]=Math.min(255, density[idx]+3);

      }

    }

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<density.length;i++){

      density[i]*=params.decay;

      const v=density[i];

      const idx=i*4;

      const hue=(v*2)%360;

      const h=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

      let r=0,g=0,b=0;

      if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

      d[idx]=(r+m)*255; d[idx+1]=(g+m)*255; d[idx+2]=(b+m)*255; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"u",0.5,1.2,0.01,params.u,v=>{params.u=v});

  slider(id,"Points",10000,50000,5000,params.points,v=>{params.points=v});

  setCode(id, draw.toString());

};

/* 84 Wave Interference Flowers */

inits["interference"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={freq1:0.02, freq2:0.025, phase:0, speed:0.01};

  function draw(){

    params.phase+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy);

        const a=Math.atan2(dy,dx);

        const w1=Math.sin(r*params.freq1+params.phase);

        const w2=Math.sin(r*params.freq2+a*3+params.phase*0.7);

        const v=(w1+w2)*0.5+0.5;

        const i=(y*c.width+x)*4;

        const hue=(v*120+200)%360;

        const h=hue/60, c2=0.8, l=v*0.3+0.4, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r2=0,g=0,b=0;

        if(h<1){r2=c2;g=X}else if(h<2){r2=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r2=X;b=c2}else{r2=c2;b=X}

        d[i]=(r2+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Freq1",0.01,0.05,0.001,params.freq1,v=>{params.freq1=v});

  slider(id,"Freq2",0.01,0.05,0.001,params.freq2,v=>{params.freq2=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 64 Quasicrystal Starfield */

inits["quasicrystal"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={waves:8, threshold:0.3, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy), a=Math.atan2(dy,dx);

        let sum=0;

        for(let i=0;i<params.waves;i++){

          const angle=a+i*Math.PI*2/params.waves;

          sum+=Math.sin(r*0.05*Math.cos(angle)+params.time);

        }

        const v=sum/params.waves;

        const i=(y*c.width+x)*4;

        const col=v>params.threshold?255:0;

        d[i]=col*0.8; d[i+1]=col*0.9; d[i+2]=col; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Waves",4,16,1,params.waves,v=>{params.waves=v});

  slider(id,"Threshold",-1,1,0.05,params.threshold,v=>{params.threshold=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 97 Bitmask Quilt */

inits["bitmask"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={tile:16, pattern:0b10110110};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    for(let y=0;y<c.height;y+=params.tile){

      for(let x=0;x<c.width;x+=params.tile){

        const tx=Math.floor(x/params.tile), ty=Math.floor(y/params.tile);

        const bit=(tx^ty)&params.pattern;

        if(bit){

          const hue=((tx+ty)*30)%360;

          ctx.fillStyle=`hsl(${hue},80%,60%)`;

          ctx.fillRect(x,y,params.tile,params.tile);

        }

      }

    }

  }

  draw();

  slider(id,"Tile size",8,32,2,params.tile,v=>{params.tile=v; draw();});

  setCode(id, draw.toString());

};

/* 98 Prime Spiral Constellations */

inits["primes"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={density:2, glow:true};

  function isPrime(n){

    if(n<2) return false;

    for(let i=2;i*i<=n;i++) if(n%i===0) return false;

    return true;

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2, maxN=2000;

    for(let n=1;n<maxN;n+=params.density){

      if(isPrime(n)){

        const a=n*0.1;

        const r=Math.sqrt(n)*2;

        const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;

        if(x>=0&&x<c.width&&y>=0&&y<c.height){

          const hue=(n*10)%360;

          ctx.fillStyle=`hsla(${hue},80%,70%,0.8)`;

          ctx.beginPath();

          ctx.arc(x,y,2,0,Math.PI*2);

          ctx.fill();

          if(params.glow){

            ctx.shadowColor=`hsl(${hue},80%,70%)`;

            ctx.shadowBlur=8;

            ctx.fill();

            ctx.shadowBlur=0;

          }

        }

      }

    }

  }

  draw();

  slider(id,"Density",1,5,1,params.density,v=>{params.density=v; draw();});

  setCode(id, draw.toString());

};

/* 63 Curl Noise Rivers */

inits["curl-rivers"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={count:150, speed:0.5, time:0, stepSize:2};

  const particles=Array(params.count).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, vx:0, vy:0, life:1}));

  function curl(x,y){

    const eps=0.01;

    const n1=fbm(x,y,3,2,0.5);

    const n2=fbm(x+eps,y,3,2,0.5);

    const n3=fbm(x,y+eps,3,2,0.5);

    return [(n3-n1)/eps, -(n2-n1)/eps];

  }

  function draw(){

    params.time+=0.01;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    for(const p of particles){

      const [vx,vy]=curl(p.x*0.01+params.time, p.y*0.01+params.time);

      p.vx+=(vx-p.vx)*0.1; p.vy+=(vy-p.vy)*0.1;

      p.x+=p.vx*params.stepSize; p.y+=p.vy*params.stepSize;

      p.life*=0.995;

      if(p.x<0||p.x>c.width||p.y<0||p.y>c.height||p.life<0.1){

        p.x=Math.random()*c.width; p.y=Math.random()*c.height; p.life=1;

      }

      const hue=(p.x/c.width*360+params.time*50)%360;

      ctx.fillStyle=`hsla(${hue},80%,60%,${p.life*0.6})`;

      ctx.beginPath();

      ctx.arc(p.x,p.y,2,0,Math.PI*2);

      ctx.fill();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Count",50,300,10,params.count,v=>{params.count=v; particles.length=0; for(let i=0;i<v;i++) particles.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:0, vy:0, life:1});});

  slider(id,"Step size",0.5,5,0.1,params.stepSize,v=>{params.stepSize=v});

  setCode(id, draw.toString());

};

/* 103 Metaballs Pool */

inits["metaballs"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={count:8, iso:100, time:0, speed:0.01};

  const balls=Array(params.count).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1, r:30+Math.random()*40}));

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let sum=0;

        for(const b of balls){

          const dx=x-b.x, dy=y-b.y, dist=Math.hypot(dx,dy);

          sum+=b.r*b.r/(dist*dist+1);

        }

        const v=Math.min(255, sum*params.iso);

        const i=(y*c.width+x)*4;

        const hue=(params.time*50+v*0.5)%360;

        const h=hue/60, c2=0.8, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const b of balls){

      b.x+=b.vx; b.y+=b.vy;

      if(b.x<0||b.x>c.width){b.vx*=-1; b.x=Math.max(0,Math.min(c.width,b.x));}

      if(b.y<0||b.y>c.height){b.vy*=-1; b.y=Math.max(0,Math.min(c.height,b.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Count",3,15,1,params.count,v=>{params.count=v; balls.length=0; for(let i=0;i<v;i++) balls.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1, r:30+Math.random()*40});});

  slider(id,"Iso threshold",50,200,5,params.iso,v=>{params.iso=v});

  setCode(id, draw.toString());

};

/* 117 Diffusion-Limited Aggregation */

inits["dla"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={walkers:5, stickProb:0.5, maxWalkers:1000};

  const tree=[{x:c.width/2, y:c.height/2}];

  const walkers=[];

  function addWalker(){

    const angle=Math.random()*Math.PI*2;

    const r=Math.min(c.width,c.height)*0.4;

    walkers.push({x:c.width/2+Math.cos(angle)*r, y:c.height/2+Math.sin(angle)*r});

  }

  for(let i=0;i<params.walkers;i++) addWalker();

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.05)'; ctx.fillRect(0,0,c.width,c.height);

    for(let i=walkers.length-1;i>=0;i--){

      const w=walkers[i];

      w.x+=(Math.random()-0.5)*4;

      w.y+=(Math.random()-0.5)*4;

      for(const t of tree){

        const dx=w.x-t.x, dy=w.y-t.y, dist=Math.hypot(dx,dy);

        if(dist<3){

          if(Math.random()<params.stickProb){

            tree.push({x:w.x, y:w.y});

            walkers.splice(i,1);

            if(walkers.length<params.maxWalkers) addWalker();

            break;

          }

        }

      }

      if(w.x<0||w.x>c.width||w.y<0||w.y>c.height){

        walkers.splice(i,1);

        addWalker();

      }

    }

    ctx.fillStyle='#56c2ff';

    for(const t of tree){

      ctx.beginPath();

      ctx.arc(t.x,t.y,2,0,Math.PI*2);

      ctx.fill();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Walkers",1,20,1,params.walkers,v=>{params.walkers=v; while(walkers.length<v) addWalker();});

  slider(id,"Stick prob",0.1,1,0.05,params.stickProb,v=>{params.stickProb=v});

  setCode(id, draw.toString());

};

/* 71 Lorenz Ribbon */

inits["lorenz"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={sigma:10, rho:28, beta:8/3, dt:0.01, points:[]};

  let x=1, y=1, z=1;

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    for(let i=0;i<100;i++){

      const dx=params.sigma*(y-x);

      const dy=x*(params.rho-z)-y;

      const dz=x*y-params.beta*z;

      x+=dx*params.dt; y+=dy*params.dt; z+=dz*params.dt;

      params.points.push({x,y,z});

      if(params.points.length>2000) params.points.shift();

    }

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1;

    ctx.beginPath();

    const cx=c.width/2, cy=c.height/2, scale=5;

    for(let i=1;i<params.points.length;i++){

      const p1=params.points[i-1], p2=params.points[i];

      const x1=cx+p1.x*scale, y1=cy+p1.y*scale;

      const x2=cx+p2.x*scale, y2=cy+p2.y*scale;

      if(i===1) ctx.moveTo(x1,y1);

      ctx.lineTo(x2,y2);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"σ",5,15,0.5,params.sigma,v=>{params.sigma=v});

  slider(id,"ρ",20,35,1,params.rho,v=>{params.rho=v});

  slider(id,"β",1,3,0.1,params.beta,v=>{params.beta=v});

  setCode(id, draw.toString());

};

/* 73 Kaleidoscope Shader */

inits["kaleidoscope"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={sectors:6, offset:0, zoom:1, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy);

        let a=Math.atan2(dy,dx);

        a=(a+params.offset)%(Math.PI*2/params.sectors);

        if(a>Math.PI/params.sectors) a=Math.PI*2/params.sectors-a;

        const nx=cx+Math.cos(a)*r*params.zoom, ny=cy+Math.sin(a)*r*params.zoom;

        const n=fbm(nx*0.01+params.time, ny*0.01, 3, 2, 0.5);

        const hue=(n*360+params.time*100)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.8, l=n*0.3+0.4, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r2=0,g=0,b=0;

        if(h<1){r2=c2;g=X}else if(h<2){r2=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r2=X;b=c2}else{r2=c2;b=X}

        d[i]=(r2+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Sectors",3,12,1,params.sectors,v=>{params.sectors=v});

  slider(id,"Zoom",0.5,2,0.1,params.zoom,v=>{params.zoom=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 77 Complex Phase Carpets */

inits["phase-carpets"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={scale:3, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, scale=params.scale/Math.min(c.width,c.height), cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const re=(x-cx)*scale, im=(y-cy)*scale;

        const z=[re,im];

        const z2=complexMul(z,z);

        const z3=complexMul(z2,z);

        const phase=Math.atan2(z3[1], z3[0]);

        const hue=((phase/(Math.PI*2)+0.5)*360+params.time*50)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.8, l=0.5, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Scale",1,6,0.1,params.scale,v=>{params.scale=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 79 Conic Caustics */

inits["conic-caustics"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={stops:12, phase:0, speed:0.01};

  function draw(){

    params.phase+=params.speed;

    const div=document.getElementById('stage-'+id);

    if(!div.firstChild){

      const canvas=document.createElement('canvas');

      canvas.width=c.width; canvas.height=c.height;

      div.appendChild(canvas);

    }

    const stops=[];

    for(let i=0;i<params.stops;i++){

      const offset=i/params.stops*100;

      const hue=(i*360/params.stops+params.phase*100)%360;

      stops.push(`hsl(${hue},80%,50%) ${offset}%`);

      stops.push(`hsl(${hue},80%,30%) ${offset+50/params.stops}%`);

    }

    div.firstChild.style.background=`conic-gradient(from ${params.phase*360}deg, ${stops.join(', ')})`;

  }

  const div=document.createElement('div');

  div.style.width='100%'; div.style.height='60vh';

  appendStage(id,div);

  function update(){

    draw();

    requestAnimationFrame(update);

  }

  update();

  slider(id,"Stops",4,20,1,params.stops,v=>{params.stops=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 81 Hyperbolic Grid Warp */

inits["hyper-grid"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={curvature:0.3, lines:20};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=1;

    const cx=c.width/2, cy=c.height/2;

    for(let i=0;i<=params.lines;i++){

      const t=i/params.lines;

      ctx.beginPath();

      for(let j=0;j<=params.lines;j++){

        const s=j/params.lines;

        const x=s*c.width;

        const y=t*c.height;

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy);

        const warp=1+params.curvature*Math.sin(r*0.01);

        const wx=cx+dx*warp, wy=cy+dy*warp;

        j?ctx.lineTo(wx,wy):ctx.moveTo(wx,wy);

      }

      ctx.stroke();

      ctx.beginPath();

      for(let j=0;j<=params.lines;j++){

        const s=j/params.lines;

        const x=t*c.width;

        const y=s*c.height;

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy);

        const warp=1+params.curvature*Math.sin(r*0.01);

        const wx=cx+dx*warp, wy=cy+dy*warp;

        j?ctx.lineTo(wx,wy):ctx.moveTo(wx,wy);

      }

      ctx.stroke();

    }

  }

  draw();

  slider(id,"Curvature",0,1,0.05,params.curvature,v=>{params.curvature=v; draw();});

  slider(id,"Lines",10,40,2,params.lines,v=>{params.lines=v; draw();});

  setCode(id, draw.toString());

};

/* 86 Trefoil Tube */

inits["trefoil"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={radius:80, tube:20, t:0, speed:0.02};

  function trefoil(t){

    const x=Math.sin(t)+2*Math.sin(2*t);

    const y=Math.cos(t)-2*Math.cos(2*t);

    const z=Math.sin(3*t);

    return [x,y,z];

  }

  function draw(){

    params.t+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=2;

    const cx=c.width/2, cy=c.height/2, scale=30;

    for(let i=0;i<200;i++){

      const t1=i/200*Math.PI*2+params.t, t2=(i+1)/200*Math.PI*2+params.t;

      const [x1,y1,z1]=trefoil(t1);

      const [x2,y2,z2]=trefoil(t2);

      const px1=cx+x1*scale, py1=cy+y1*scale;

      const px2=cx+x2*scale, py2=cy+y2*scale;

      ctx.beginPath();

      ctx.moveTo(px1,py1);

      ctx.lineTo(px2,py2);

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Radius",50,150,5,params.radius,v=>{params.radius=v});

  slider(id,"Speed",0,0.1,0.01,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 88 Diffraction Text Grids */

inits["diffraction-text"]=({id})=>{

  const div=document.createElement('div');

  div.style.width='100%'; div.style.height='60vh';

  div.style.display='grid'; div.style.placeItems='center';

  div.style.background='#0b0f16';

  const params={angle:0, cell:20, speed:0.01};

  const h=document.createElement('h1');

  h.textContent='DIFFRACTION';

  h.style.font='900 8vmin/1 system-ui';

  h.style.color='#56c2ff';

  h.style.position='relative';

  div.appendChild(h);

  function update(){

    params.angle+=params.speed;

    const mask=[];

    for(let i=0;i<20;i++){

      const offset=i*params.cell;

      mask.push(`repeating-linear-gradient(${params.angle}deg, transparent 0 ${offset}px, rgba(86,194,255,0.3) ${offset}px ${offset+params.cell/2}px, transparent ${offset+params.cell/2}px ${offset+params.cell}px)`);

    }

    h.style.webkitMaskImage=mask.join(', ');

    h.style.maskImage=mask.join(', ');

    requestAnimationFrame(update);

  }

  update();

  appendStage(id,div);

  slider(id,"Cell size",10,40,2,params.cell,v=>{params.cell=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, update.toString());

};

/* 90 Butterfly Field Dunes */

inits["bedforms"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={bias:0.3, steps:100, time:0, speed:0.005};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n=fbm(x*0.01, y*0.01+params.time, 4, 2, 0.5);

        const v=Math.sin(n*Math.PI*params.steps+params.bias*Math.PI*2)*0.5+0.5;

        const i=(y*c.width+x)*4;

        const col=v*255;

        d[i]=col*0.9; d[i+1]=col*0.95; d[i+2]=col; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Bias",0,1,0.05,params.bias,v=>{params.bias=v});

  slider(id,"Steps",50,200,5,params.steps,v=>{params.steps=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 101 Superformula Terrain */

inits["super-terrain"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={m:4, n1:1, n2:1, n3:1, height:50, time:0, speed:0.01};

  function superformula(phi,m,n1,n2,n3){

    const t1=Math.pow(Math.abs(Math.cos(m*phi/4)),n2);

    const t2=Math.pow(Math.abs(Math.sin(m*phi/4)),n3);

    return Math.pow(t1+t2,-1/n1);

  }

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy), a=Math.atan2(dy,dx);

        const h=superformula(a+params.time, params.m, params.n1, params.n2, params.n3);

        const v=Math.min(255, h*params.height);

        const i=(y*c.width+x)*4;

        const hue=(v*2+params.time*50)%360;

        const h2=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h2%2)-1)), m2=l-c2/2;

        let r2=0,g=0,b=0;

        if(h2<1){r2=c2;g=X}else if(h2<2){r2=X;g=c2}else if(h2<3){g=c2;b=X}else if(h2<4){g=X;b=c2}else if(h2<5){r2=X;b=c2}else{r2=c2;b=X}

        d[i]=(r2+m2)*255; d[i+1]=(g+m2)*255; d[i+2]=(b+m2)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"m",2,10,1,params.m,v=>{params.m=v});

  slider(id,"Height",20,100,5,params.height,v=>{params.height=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 108 Complex Log Spirals */

inits["log-spirals"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={rate:0.1, count:8, rotation:0, speed:0.01};

  function draw(){

    params.rotation+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2;

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    for(let s=0;s<params.count;s++){

      const offset=s*Math.PI*2/params.count+params.rotation;

      ctx.beginPath();

      for(let i=0;i<500;i++){

        const t=i/500*Math.PI*4;

        const r=Math.exp(t*params.rate);

        const x=cx+Math.cos(t+offset)*r;

        const y=cy+Math.sin(t+offset)*r;

        if(i===0) ctx.moveTo(x,y);

        else ctx.lineTo(x,y);

        if(r>Math.min(c.width,c.height)*0.5) break;

      }

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Rate",0.05,0.2,0.01,params.rate,v=>{params.rate=v});

  slider(id,"Count",3,16,1,params.count,v=>{params.count=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 111 Pulsing Voronoi Rings */

inits["voronoi-pulse"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={rings:8, pulse:0, speed:0.02};

  const sites=Array(params.rings).fill().map((_,i)=>({x:c.width/2, y:c.height/2, r:30+i*40, phase:i*0.5}));

  function draw(){

    params.pulse+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let minDist=Infinity, closest=0;

        for(let i=0;i<sites.length;i++){

          const s=sites[i];

          const r=s.r+Math.sin(params.pulse+s.phase)*10;

          const dx=x-s.x, dy=y-s.y, dist=Math.abs(Math.hypot(dx,dy)-r);

          if(dist<minDist){ minDist=dist; closest=i; }

        }

        const v=Math.min(255, minDist*10);

        const hue=(closest*360/params.rings+params.pulse*50)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Rings",4,16,1,params.rings,v=>{params.rings=v; sites.length=0; for(let i=0;i<v;i++) sites.push({x:c.width/2, y:c.height/2, r:30+i*40, phase:i*0.5});});

  slider(id,"Speed",0,0.1,0.01,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 122 Golden Angle Flow */

inits["golden-flow"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={angle:137.508, density:0.5, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2;

    for(let i=0;i<500;i++){

      const a=i*params.angle*Math.PI/180+params.time;

      const r=Math.sqrt(i)*params.density;

      const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;

      if(x>=0&&x<c.width&&y>=0&&y<c.height){

        const hue=(i*5+params.time*100)%360;

        ctx.strokeStyle=`hsla(${hue},80%,60%,0.6)`;

        ctx.beginPath();

        ctx.arc(x,y,2,0,Math.PI*2);

        ctx.stroke();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Angle",100,200,1,params.angle,v=>{params.angle=v});

  slider(id,"Density",0.2,1,0.1,params.density,v=>{params.density=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 74 Hex Flow Field */

inits["hex-flow"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={scale:20, time:0, speed:0.01};

  function hexCoord(x,y){

    const q=(2/3*x)/params.scale;

    const r=(-1/3*x+Math.sqrt(3)/3*y)/params.scale;

    return [q,r];

  }

  function flowField(q,r){

    const n=fbm(q*0.1+params.time, r*0.1, 3, 2, 0.5);

    return n*Math.PI*2;

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=1;

    for(let y=0;y<c.height;y+=params.scale*1.5){

      for(let x=0;x<c.width;x+=params.scale*Math.sqrt(3)){

        const [q,r]=hexCoord(x,y);

        const angle=flowField(q,r);

        const len=params.scale*0.3;

        const x2=x+Math.cos(angle)*len, y2=y+Math.sin(angle)*len;

        ctx.beginPath();

        ctx.moveTo(x,y);

        ctx.lineTo(x2,y2);

        ctx.stroke();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Scale",10,40,2,params.scale,v=>{params.scale=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 76 Fourier Drawing */

inits["fourier"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={coeffs:20, speed:0.02, t:0};

  function draw(){

    params.t+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.3;

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    let x=cx, y=cy;

    for(let n=1;n<=params.coeffs;n++){

      const radius=scale/(n*Math.PI);

      const angle=params.t*n;

      const px=x+Math.cos(angle)*radius;

      const py=y+Math.sin(angle)*radius;

      ctx.beginPath();

      ctx.arc(x,y,radius,0,Math.PI*2);

      ctx.stroke();

      ctx.beginPath();

      ctx.moveTo(x,y);

      ctx.lineTo(px,py);

      ctx.stroke();

      x=px; y=py;

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Coeffs",5,50,1,params.coeffs,v=>{params.coeffs=v});

  slider(id,"Speed",0,0.1,0.01,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 78 Heightmap Parallax */

inits["parallax"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:0.3, lightAngle:0.5, time:0, speed:0.005};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const h=fbm(x*0.01, y*0.01+params.time, 4, 2, 0.5);

        const dx=Math.cos(params.lightAngle*Math.PI*2);

        const dy=Math.sin(params.lightAngle*Math.PI*2);

        const hx=fbm((x+1)*0.01, y*0.01+params.time, 4, 2, 0.5);

        const hy=fbm(x*0.01, (y+1)*0.01+params.time, 4, 2, 0.5);

        const nx=hx-h, ny=hy-h;

        const light=Math.max(0, nx*dx+ny*dy)*params.depth+0.5;

        const v=h*light*255;

        const i=(y*c.width+x)*4;

        d[i]=v*0.9; d[i+1]=v*0.95; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Depth",0.1,0.8,0.05,params.depth,v=>{params.depth=v});

  slider(id,"Light angle",0,1,0.01,params.lightAngle,v=>{params.lightAngle=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 80 Turing Stripe Garden */

inits["turing"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={feed:0.055, kill:0.062, diffA:1, diffB:0.5, dt:1};

  let gridA=Array(c.width*c.height).fill(1);

  let gridB=Array(c.width*c.height).fill(0);

  for(let i=0;i<gridB.length;i++){

    if(Math.random()<0.01) gridB[i]=1;

  }

  function draw(){

    const newA=[...gridA], newB=[...gridB];

    for(let y=1;y<c.height-1;y++){

      for(let x=1;x<c.width-1;x++){

        const idx=y*c.width+x;

        const la=(gridA[idx-1]+gridA[idx+1]+gridA[idx-c.width]+gridA[idx+c.width])/4;

        const lb=(gridB[idx-1]+gridB[idx+1]+gridB[idx-c.width]+gridB[idx+c.width])/4;

        const a=gridA[idx], b=gridB[idx];

        const f=params.feed*(1-a);

        const k=(params.kill+params.feed)*b;

        newA[idx]=a+(params.diffA*(la-a)+f-k)*params.dt;

        newB[idx]=b+(params.diffB*(lb-b)-f+k)*params.dt;

        newA[idx]=Math.max(0,Math.min(1,newA[idx]));

        newB[idx]=Math.max(0,Math.min(1,newB[idx]));

      }

    }

    gridA=newA; gridB=newB;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<gridA.length;i++){

      const v=gridB[i]*255;

      const idx=i*4;

      d[idx]=v*0.8; d[idx+1]=v*0.9; d[idx+2]=v; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Feed",0.01,0.1,0.001,params.feed,v=>{params.feed=v});

  slider(id,"Kill",0.01,0.1,0.001,params.kill,v=>{params.kill=v});

  setCode(id, draw.toString());

};

/* 85 Strange Map Scroll */

inits["strange-map"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={iterations:50, scale:2, time:0, speed:0.01};

  function strangeMap(z){

    const [re,im]=z;

    for(let i=0;i<params.iterations;i++){

      const z2=complexMul([re,im],[re,im]);

      const z3=complexMul(z2,[re,im]);

      const z4=complexAdd(z3,[0.2,0.3]);

      if(z4[0]*z4[0]+z4[1]*z4[1]>4) return i;

    }

    return params.iterations;

  }

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, scale=params.scale/Math.min(c.width,c.height), cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const re=(x-cx)*scale+Math.cos(params.time)*0.1;

        const im=(y-cy)*scale+Math.sin(params.time)*0.1;

        const iter=strangeMap([re,im]);

        const hue=(iter*10+params.time*50)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.8, l=iter/params.iterations*0.5+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Iterations",10,100,5,params.iterations,v=>{params.iterations=v});

  slider(id,"Scale",0.5,5,0.1,params.scale,v=>{params.scale=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 109 Torus Knot Map */

inits["torus-knot"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={p:3, q:2, radius:80, tube:20, t:0, speed:0.01};

  function torusKnot(t,p,q,R,r){

    const u=t*q;

    const x=(R+r*Math.cos(u))*Math.cos(t*p);

    const y=(R+r*Math.cos(u))*Math.sin(t*p);

    const z=r*Math.sin(u);

    return [x,y,z];

  }

  function draw(){

    params.t+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=2;

    const cx=c.width/2, cy=c.height/2, scale=2;

    for(let i=0;i<500;i++){

      const t1=i/500*Math.PI*2, t2=(i+1)/500*Math.PI*2;

      const [x1,y1,z1]=torusKnot(t1,params.p,params.q,params.radius,params.tube);

      const [x2,y2,z2]=torusKnot(t2,params.p,params.q,params.radius,params.tube);

      const px1=cx+x1*scale, py1=cy+y1*scale;

      const px2=cx+x2*scale, py2=cy+y2*scale;

      ctx.beginPath();

      ctx.moveTo(px1,py1);

      ctx.lineTo(px2,py2);

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"p",2,7,1,params.p,v=>{params.p=v});

  slider(id,"q",2,7,1,params.q,v=>{params.q=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 110 Wavelet Tapestry */

inits["wavelet"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={basis:8, scale:0.02, time:0, speed:0.01};

  function wavelet(x,y,scale,offset){

    return Math.sin((x+offset)*scale)*Math.exp(-((x+offset)*(x+offset)+(y+offset)*(y+offset))*scale*10);

  }

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let sum=0;

        for(let i=0;i<params.basis;i++){

          sum+=wavelet(x,y,params.scale,params.time+i*0.5);

        }

        const v=(sum/params.basis*0.5+0.5)*255;

        const i=(y*c.width+x)*4;

        const hue=(v*0.5+params.time*50)%360;

        const h=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Basis",4,16,1,params.basis,v=>{params.basis=v});

  slider(id,"Scale",0.01,0.05,0.001,params.scale,v=>{params.scale=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 118 Sunken Grid Caustics */

inits["caustic-grid"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={refraction:0.3, flow:0.01, time:0, speed:0.005};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.4)'; ctx.lineWidth=1;

    for(let y=0;y<c.height;y+=20){

      for(let x=0;x<c.width;x+=20){

        const n=fbm(x*params.flow+params.time, y*params.flow, 3, 2, 0.5);

        const dx=Math.cos(n*Math.PI*2)*params.refraction*10;

        const dy=Math.sin(n*Math.PI*2)*params.refraction*10;

        ctx.beginPath();

        ctx.moveTo(x+dx,y+dy);

        ctx.lineTo(x+20+dx,y+dy);

        ctx.stroke();

        ctx.beginPath();

        ctx.moveTo(x+dx,y+dy);

        ctx.lineTo(x+dx,y+20+dy);

        ctx.stroke();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Refraction",0.1,0.8,0.05,params.refraction,v=>{params.refraction=v});

  slider(id,"Flow",0.005,0.02,0.001,params.flow,v=>{params.flow=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 123 Kaleid Voronoi Mirror */

inits["kaleid-voronoi"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={sectors:6, sites:8, time:0, speed:0.002};

  const sites=Array(params.sites).fill().map(()=>({x:Math.random(), y:Math.random(), vx:Math.random()*0.002-0.001, vy:Math.random()*0.002-0.001}));

  function mirror(x,y){

    const dx=x-0.5, dy=y-0.5;

    const r=Math.hypot(dx,dy);

    let a=Math.atan2(dy,dx);

    a=(a+Math.PI/params.sectors)%(Math.PI*2/params.sectors);

    if(a>Math.PI/params.sectors) a=Math.PI*2/params.sectors-a;

    return [0.5+Math.cos(a)*r, 0.5+Math.sin(a)*r];

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const px=x/c.width, py=y/c.height;

        const [mx,my]=mirror(px,py);

        let minDist=Infinity, closest=0;

        for(let i=0;i<sites.length;i++){

          const dx=mx-sites[i].x, dy=my-sites[i].y;

          const dist=dx*dx+dy*dy;

          if(dist<minDist){ minDist=dist; closest=i; }

        }

        const v=Math.min(255, Math.sqrt(minDist)*800);

        const hue=(closest*360/params.sites)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const s of sites){

      s.x+=s.vx; s.y+=s.vy;

      if(s.x<0||s.x>1){s.vx*=-1; s.x=Math.max(0,Math.min(1,s.x));}

      if(s.y<0||s.y>1){s.vy*=-1; s.y=Math.max(0,Math.min(1,s.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Sectors",3,12,1,params.sectors,v=>{params.sectors=v});

  slider(id,"Sites",4,20,1,params.sites,v=>{params.sites=v; sites.length=0; for(let i=0;i<v;i++) sites.push({x:Math.random(), y:Math.random(), vx:Math.random()*0.002-0.001, vy:Math.random()*0.002-0.001});});

  setCode(id, draw.toString());

};

/* 124 Complex Roots Garden */

inits["roots-garden"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={n:4, zoom:2, maxIters:50};

  function findRoot(z,n){

    let zr=z[0], zi=z[1];

    for(let i=0;i<params.maxIters;i++){

      const mag2=zr*zr+zi*zi;

      if(mag2<1e-10) return {iter:i, root:0};

      const [znr, zni]=complexPow([zr,zi], n);

      const [znr1, zni1]=complexPow([zr,zi], n-1);

      const denom=params.n*(znr1*znr1+zni1*zni1);

      if(denom<1e-10) return {iter:i, root:0};

      zr=zr-(znr-1)*znr1/denom+(zni-0)*zni1/denom;

      zi=zi-(zni-0)*znr1/denom-(znr-1)*zni1/denom;

      if(zr*zr+zi*zi>100) return {iter:i, root:Math.floor(Math.atan2(zi,zr)*params.n/Math.PI/2+params.n)%params.n};

    }

    return {iter:params.maxIters, root:Math.floor(Math.atan2(zi,zr)*params.n/Math.PI/2+params.n)%params.n};

  }

  function draw(){

    const img=ctx.createImageData(c.width,c.height), d=img.data, scale=params.zoom/Math.min(c.width,c.height), cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const re=(x-cx)*scale, im=(y-cy)*scale;

        const {iter, root}=findRoot([re,im], params.n);

        const hue=(root*360/params.n+iter*5)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.8, l=0.3+iter/params.maxIters*0.4, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

  }

  draw();

  slider(id,"Power n",2,8,1,params.n,v=>{params.n=v; draw();});

  slider(id,"Zoom",0.5,5,0.1,params.zoom,v=>{params.zoom=v; draw();});

  slider(id,"Max Iters",10,100,5,params.maxIters,v=>{params.maxIters=v; draw();});

  setCode(id, draw.toString());

};

/* 126 Gradient Orbit Rings */

inits["orbit-rings"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={count:8, thickness:0.02, spin:0, speed:0.01};

  function draw(){

    params.spin+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.4;

    for(let i=0;i<params.count;i++){

      const r=scale*(0.3+i*0.7/params.count);

      const angle=i*Math.PI*2/params.count+params.spin;

      const hue=(i*360/params.count+params.spin*100)%360;

      ctx.strokeStyle=`hsl(${hue},80%,60%)`; ctx.lineWidth=params.thickness*scale;

      ctx.beginPath();

      ctx.arc(cx+Math.cos(angle)*r*0.3, cy+Math.sin(angle)*r*0.3, r, 0, Math.PI*2);

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Count",3,16,1,params.count,v=>{params.count=v});

  slider(id,"Thickness",0.005,0.05,0.001,params.thickness,v=>{params.thickness=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 139 Chladni Plate Nodes */

inits["chladni"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={m:5, n:4, threshold:0.1, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.4;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=(x-cx)/scale, dy=(y-cy)/scale;

        const chladni=Math.cos(params.m*Math.PI*dx)*Math.cos(params.n*Math.PI*dy)+Math.sin(params.time);

        const v=Math.abs(chladni)<params.threshold?255:0;

        const i=(y*c.width+x)*4;

        d[i]=v*0.8; d[i+1]=v*0.9; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"m",1,10,1,params.m,v=>{params.m=v});

  slider(id,"n",1,10,1,params.n,v=>{params.n=v});

  slider(id,"Threshold",0.05,0.3,0.01,params.threshold,v=>{params.threshold=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 143 Polar Sine Labyrinth */

inits["polar-labyrinth"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={cell:10, amplitude:3, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1;

    const cx=c.width/2, cy=c.height/2;

    for(let r=params.cell;r<Math.min(c.width,c.height)*0.4;r+=params.cell){

      for(let a=0;a<Math.PI*2;a+=0.1){

        const sine=Math.sin(a*params.amplitude+params.time);

        const threshold=r*0.1;

        if(Math.abs(sine)<threshold){

          const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;

          ctx.fillRect(x-1,y-1,3,3);

        }

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Cell size",5,20,1,params.cell,v=>{params.cell=v});

  slider(id,"Amplitude",1,8,0.5,params.amplitude,v=>{params.amplitude=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 148 Delaunay Wireframe */

inits["delaunay"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={points:30, thickness:1, jitter:0.1, time:0, speed:0.002};

  const points=Array(params.points).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1}));

  function delaunay(points){

    const triangles=[];

    for(let i=0;i<points.length;i++){

      for(let j=i+1;j<points.length;j++){

        for(let k=j+1;k<points.length;k++){

          const p1=points[i], p2=points[j], p3=points[k];

          let valid=true;

          for(let l=0;l<points.length;l++){

            if(l===i||l===j||l===k) continue;

            const p=points[l];

            const ax=p1.x-p.x, ay=p1.y-p.y, bx=p2.x-p.x, by=p2.y-p.y, cx=p3.x-p.x, cy=p3.y-p.y;

            const det=ax*(by*cy-cy*by)-ay*(bx*cy-cx*by)+(ax*by-ay*bx);

            if(det>0){ valid=false; break; }

          }

          if(valid) triangles.push([i,j,k]);

        }

      }

    }

    return triangles;

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=params.thickness;

    const triangles=delaunay(points);

    for(const [i,j,k] of triangles){

      const p1=points[i], p2=points[j], p3=points[k];

      ctx.beginPath();

      ctx.moveTo(p1.x,p1.y);

      ctx.lineTo(p2.x,p2.y);

      ctx.lineTo(p3.x,p3.y);

      ctx.closePath();

      ctx.stroke();

    }

    for(const p of points){

      p.x+=p.vx; p.y+=p.vy;

      if(p.x<0||p.x>c.width){p.vx*=-1; p.x=Math.max(0,Math.min(c.width,p.x));}

      if(p.y<0||p.y>c.height){p.vy*=-1; p.y=Math.max(0,Math.min(c.height,p.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Points",10,50,2,params.points,v=>{params.points=v; points.length=0; for(let i=0;i<v;i++) points.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1});});

  slider(id,"Thickness",0.5,3,0.5,params.thickness,v=>{params.thickness=v; ctx.lineWidth=v;});

  setCode(id, draw.toString());

};

/* 72 Edge Reaction Rings */

inits["edge-react"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={gain:0.95, threshold:0.5, blur:1, time:0, speed:0.01};

  let buffer=ctx.createImageData(c.width,c.height);

  for(let i=0;i<buffer.data.length;i+=4){

    buffer.data[i]=Math.random()<0.01?255:0;

    buffer.data[i+1]=buffer.data[i]; buffer.data[i+2]=buffer.data[i]; buffer.data[i+3]=255;

  }

  function edgeDetect(img){

    const out=ctx.createImageData(img.width,img.height), d=img.data, o=out.data;

    for(let y=1;y<img.height-1;y++){

      for(let x=1;x<img.width-1;x++){

        const idx=(y*img.width+x)*4;

        const gx=-d[(y-1)*img.width*4+(x-1)*4]+d[(y-1)*img.width*4+(x+1)*4]-2*d[y*img.width*4+(x-1)*4]+2*d[y*img.width*4+(x+1)*4]-d[(y+1)*img.width*4+(x-1)*4]+d[(y+1)*img.width*4+(x+1)*4];

        const gy=-d[(y-1)*img.width*4+(x-1)*4]-2*d[(y-1)*img.width*4+x*4]-d[(y-1)*img.width*4+(x+1)*4]+d[(y+1)*img.width*4+(x-1)*4]+2*d[(y+1)*img.width*4+x*4]+d[(y+1)*img.width*4+(x+1)*4];

        const mag=Math.hypot(gx,gy);

        const v=mag>params.threshold*255?255:0;

        o[idx]=v; o[idx+1]=v; o[idx+2]=v; o[idx+3]=255;

      }

    }

    return out;

  }

  function blur(img){

    const out=ctx.createImageData(img.width,img.height), d=img.data, o=out.data;

    const kernel=[1,2,1,2,4,2,1,2,1], norm=16;

    for(let y=1;y<img.height-1;y++){

      for(let x=1;x<img.width-1;x++){

        let acc=0, k=0;

        for(let j=-1;j<=1;j++){

          for(let i=-1;i<=1;i++){

            const idx=((y+j)*img.width+(x+i))*4;

            acc+=d[idx]*kernel[k++];

          }

        }

        const v=acc/norm;

        const idx=(y*img.width+x)*4;

        o[idx]=v; o[idx+1]=v; o[idx+2]=v; o[idx+3]=255;

      }

    }

    return out;

  }

  function draw(){

    params.time+=params.speed;

    let img=edgeDetect(buffer);

    for(let i=0;i<params.blur;i++) img=blur(img);

    const d=buffer.data, b=img.data;

    for(let i=0;i<d.length;i+=4){

      const v=Math.min(255, d[i]*params.gain+b[i]*(1-params.gain));

      d[i]=v; d[i+1]=v*0.95; d[i+2]=v*0.8; d[i+3]=255;

    }

    ctx.putImageData(buffer,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Gain",0.8,0.99,0.01,params.gain,v=>{params.gain=v});

  slider(id,"Threshold",0.1,1,0.05,params.threshold,v=>{params.threshold=v});

  slider(id,"Blur",0,3,1,params.blur,v=>{params.blur=v});

  setCode(id, draw.toString());

};

/* 83 Raymarch Glow Orbs */

inits["raymarch-2d"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={orbs:5, falloff:0.5, blend:0.3, time:0, speed:0.01};

  const orbs=Array(params.orbs).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, r:30+Math.random()*50, vx:Math.random()*0.5-0.25, vy:Math.random()*0.5-0.25}));

  function sdf(x,y,orb){

    return Math.hypot(x-orb.x, y-orb.y)-orb.r;

  }

  function softMin(a,b,k){

    const h=Math.max(k-Math.abs(a-b),0)/k;

    return Math.min(a,b)-h*h*h*k/6;

  }

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let dist=sdf(x,y,orbs[0]);

        for(let i=1;i<orbs.length;i++){

          dist=softMin(dist, sdf(x,y,orbs[i]), params.blend*100);

        }

        const v=Math.max(0, 1-dist*params.falloff/100)*255;

        const i=(y*c.width+x)*4;

        const hue=(params.time*50+v*0.5)%360;

        const h=hue/60, c2=0.8, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const orb of orbs){

      orb.x+=orb.vx; orb.y+=orb.vy;

      if(orb.x<0||orb.x>c.width){orb.vx*=-1; orb.x=Math.max(0,Math.min(c.width,orb.x));}

      if(orb.y<0||orb.y>c.height){orb.vy*=-1; orb.y=Math.max(0,Math.min(c.height,orb.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Orbs",2,10,1,params.orbs,v=>{params.orbs=v; orbs.length=0; for(let i=0;i<v;i++) orbs.push({x:Math.random()*c.width, y:Math.random()*c.height, r:30+Math.random()*50, vx:Math.random()*0.5-0.25, vy:Math.random()*0.5-0.25});});

  slider(id,"Falloff",0.1,1,0.05,params.falloff,v=>{params.falloff=v});

  slider(id,"Blend",0.1,0.8,0.05,params.blend,v=>{params.blend=v});

  setCode(id, draw.toString());

};

/* 82 SDF Shape Playground */

inits["sdf-play"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={blend:20, time:0, speed:0.01};

  function circleSDF(x,y,cx,cy,r){

    return Math.hypot(x-cx,y-cy)-r;

  }

  function boxSDF(x,y,cx,cy,w,h){

    const dx=Math.abs(x-cx)-w, dy=Math.abs(y-cy)-h;

    return Math.hypot(Math.max(dx,0), Math.max(dy,0))+Math.min(Math.max(dx,dy),0);

  }

  function smoothUnion(a,b,k){

    const h=Math.max(k-Math.abs(a-b),0)/k;

    return Math.min(a,b)-h*h*h*k/6;

  }

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const c1=circleSDF(x,y, cx+Math.cos(params.time)*50, cy+Math.sin(params.time)*50, 40);

        const c2=circleSDF(x,y, cx-Math.cos(params.time)*50, cy-Math.sin(params.time)*50, 40);

        const boxv=boxSDF(x,y, cx, cy, 60, 60);

        let dist=smoothUnion(c1,c2,params.blend);

        dist=smoothUnion(dist,boxv,params.blend);

        const v=Math.abs(dist)<2?255:Math.max(0,255-Math.abs(dist)*5);

        const i=(y*c.width+x)*4;

        const hue=(dist*5+params.time*50)%360;

        const h=hue/60, chroma=0.7, l=v/255*0.4+0.3, X=chroma*(1-Math.abs((h%2)-1)), m=l-chroma/2;

        let r=0,g=0,b=0;

        if(h<1){r=chroma;g=X}else if(h<2){r=X;g=chroma}else if(h<3){g=chroma;b=X}else if(h<4){g=X;b=chroma}else if(h<5){r=X;b=chroma}else{r=chroma;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Blend",5,50,1,params.blend,v=>{params.blend=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 106 Spherical Harmonics Heat */

inits["harmonics"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={l:3, m:2, time:0, speed:0.01};

  function sphericalHarmonic(theta,phi,l,m){

    if(l===0) return 1/Math.sqrt(4*Math.PI);

    if(l===1){

      if(m===0) return Math.sqrt(3/(4*Math.PI))*Math.cos(theta);

      if(m===1) return -Math.sqrt(3/(8*Math.PI))*Math.sin(theta)*Math.cos(phi);

      if(m===-1) return Math.sqrt(3/(8*Math.PI))*Math.sin(theta)*Math.sin(phi);

    }

    if(l===2){

      if(m===0) return Math.sqrt(5/(16*Math.PI))*(3*Math.cos(theta)*Math.cos(theta)-1);

      if(m===1) return -Math.sqrt(15/(8*Math.PI))*Math.sin(theta)*Math.cos(theta)*Math.cos(phi);

      if(m===-1) return Math.sqrt(15/(8*Math.PI))*Math.sin(theta)*Math.cos(theta)*Math.sin(phi);

      if(m===2) return Math.sqrt(15/(32*Math.PI))*Math.sin(theta)*Math.sin(theta)*Math.cos(2*phi);

      if(m===-2) return Math.sqrt(15/(32*Math.PI))*Math.sin(theta)*Math.sin(theta)*Math.sin(2*phi);

    }

    if(l===3){

      if(m===0) return Math.sqrt(7/(16*Math.PI))*(5*Math.cos(theta)*Math.cos(theta)*Math.cos(theta)-3*Math.cos(theta));

      return Math.sin(theta)*Math.cos(m*phi+params.time);

    }

    return Math.sin(theta)*Math.cos(m*phi+params.time);

  }

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.4;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=(x-cx)/scale, dy=(y-cy)/scale;

        const r=Math.hypot(dx,dy);

        if(r>1) continue;

        const theta=Math.acos(Math.sqrt(1-r*r));

        const phi=Math.atan2(dy,dx);

        const Y=sphericalHarmonic(theta,phi,params.l,params.m);

        const v=(Y*0.5+0.5)*255;

        const i=(y*c.width+x)*4;

        const hue=(v*0.5+params.time*50)%360;

        const h=hue/60, c2=0.8, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m2=l-c2/2;

        let r2=0,g=0,b=0;

        if(h<1){r2=c2;g=X}else if(h<2){r2=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r2=X;b=c2}else{r2=c2;b=X}

        d[i]=(r2+m2)*255; d[i+1]=(g+m2)*255; d[i+2]=(b+m2)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"l",0,3,1,params.l,v=>{params.l=v});

  slider(id,"m",-3,3,1,params.m,v=>{params.m=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 107 Moiré Checker Warps */

inits["moire-checker"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={angle1:0, angle2:0.3, scale:20, phase:0, speed:0.01};

  function draw(){

    params.phase+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const a1=Math.cos(params.angle1)*(x-c.width/2)+Math.sin(params.angle1)*(y-c.height/2);

        const a2=Math.cos(params.angle2)*(x-c.width/2)+Math.sin(params.angle2)*(y-c.height/2);

        const v1=Math.sin(a1/params.scale+params.phase)>0?1:0;

        const v2=Math.sin(a2/params.scale+params.phase*0.7)>0?1:0;

        const v=(v1^v2)*255;

        const i=(y*c.width+x)*4;

        d[i]=v*0.8; d[i+1]=v*0.9; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Angle1",0,Math.PI,0.1,params.angle1,v=>{params.angle1=v});

  slider(id,"Angle2",0,Math.PI,0.1,params.angle2,v=>{params.angle2=v});

  slider(id,"Scale",10,50,2,params.scale,v=>{params.scale=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 114 Sinewarp Text */

inits["sinewarp-text"]=({id})=>{

  const div=document.createElement('div');

  div.style.width='100%'; div.style.height='60vh';

  div.style.display='grid'; div.style.placeItems='center';

  div.style.background='#0b0f16';

  const params={amplitude:20, freq:0.02, speed:0.01, time:0};

  const h=document.createElement('h1');

  h.textContent='SINEWARP';

  h.style.font='900 8vmin/1 system-ui';

  h.style.color='#56c2ff';

  div.appendChild(h);

  function update(){

    params.time+=params.speed;

    const offset=Math.sin(params.time*params.freq*100)*params.amplitude;

    h.style.backgroundPosition=`${offset}px ${offset*0.5}px`;

    h.style.background=`

      repeating-linear-gradient(45deg, transparent 0 ${offset}px, rgba(86,194,255,0.3) ${offset}px ${offset+10}px, transparent ${offset+10}px ${offset+20}px)

    `;

    requestAnimationFrame(update);

  }

  update();

  appendStage(id,div);

  slider(id,"Amplitude",5,50,1,params.amplitude,v=>{params.amplitude=v});

  slider(id,"Frequency",0.01,0.05,0.001,params.freq,v=>{params.freq=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, update.toString());

};

/* 127 Fractal Flames 2D */

inits["flames"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={iterations:50000, gamma:1.5, time:0, speed:0.01};

  const transforms=[

    {p:0.5, a:0.5, b:0, c:0, d:0.5, e:0, f:0},

    {p:0.3, a:0.5, b:0, c:0, d:0.5, e:0.5, f:0},

    {p:0.2, a:0.5, b:0, c:0, d:0.5, e:0, f:0.5}

  ];

  const density=Array(c.width*c.height).fill(0);

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.05)'; ctx.fillRect(0,0,c.width,c.height);

    let x=0.5, y=0.5;

    for(let i=0;i<params.iterations;i++){

      const r=Math.random();

      let sum=0, t=transforms[0];

      for(const tr of transforms){

        sum+=tr.p;

        if(r<sum){ t=tr; break; }

      }

      const nx=t.a*x+t.b*y+t.e;

      const ny=t.c*x+t.d*y+t.f;

      x=nx; y=ny;

      const px=Math.floor(x*c.width);

      const py=Math.floor(y*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        density[py*c.width+px]=Math.min(255, density[py*c.width+px]+1);

      }

    }

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<density.length;i++){

      const v=Math.pow(density[i]/params.iterations*255, 1/params.gamma);

      density[i]*=0.99;

      const idx=i*4;

      const hue=(v*0.5+params.time*50)%360;

      const h=hue/60, c2=0.8, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

      let r=0,g=0,b=0;

      if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

      d[idx]=(r+m)*255; d[idx+1]=(g+m)*255; d[idx+2]=(b+m)*255; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Iterations",10000,100000,5000,params.iterations,v=>{params.iterations=v});

  slider(id,"Gamma",0.5,2,0.1,params.gamma,v=>{params.gamma=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 128 Amoeba Marchers */

inits["amoeba"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={marchers:20, speed:0.5, squish:0.3, time:0, tSpeed:0.01};

  const marchers=Array(params.marchers).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, angle:Math.random()*Math.PI*2, size:20+Math.random()*30}));

  function draw(){

    params.time+=params.tSpeed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    for(const m of marchers){

      const n=fbm(m.x*0.01+params.time, m.y*0.01, 3, 2, 0.5);

      m.angle+=n*0.1;

      m.x+=Math.cos(m.angle)*params.speed;

      m.y+=Math.sin(m.angle)*params.speed;

      if(m.x<0||m.x>c.width){m.x=Math.max(0,Math.min(c.width,m.x)); m.angle+=Math.PI;}

      if(m.y<0||m.y>c.height){m.y=Math.max(0,Math.min(c.height,m.y)); m.angle+=Math.PI;}

      const hue=(m.x/c.width*360+params.time*50)%360;

      ctx.fillStyle=`hsla(${hue},80%,60%,0.6)`;

      ctx.save();

      ctx.translate(m.x,m.y);

      ctx.rotate(m.angle);

      ctx.scale(1+Math.sin(params.time+m.x*0.01)*params.squish, 1-Math.sin(params.time+m.x*0.01)*params.squish);

      ctx.beginPath();

      ctx.arc(0,0,m.size,0,Math.PI*2);

      ctx.fill();

      ctx.restore();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Marchers",5,40,1,params.marchers,v=>{params.marchers=v; marchers.length=0; for(let i=0;i<v;i++) marchers.push({x:Math.random()*c.width, y:Math.random()*c.height, angle:Math.random()*Math.PI*2, size:20+Math.random()*30});});

  slider(id,"Speed",0.1,2,0.1,params.speed,v=>{params.speed=v});

  slider(id,"Squish",0,0.5,0.05,params.squish,v=>{params.squish=v});

  setCode(id, draw.toString());

};

/* 129 Shadow March Text */

inits["shadow-text"]=({id})=>{

  const div=document.createElement('div');

  div.style.width='100%'; div.style.height='60vh';

  div.style.display='grid'; div.style.placeItems='center';

  div.style.background='#0b0f16';

  const params={layers:8, offset:5, curve:0.3, time:0, speed:0.01};

  const h=document.createElement('h1');

  h.textContent='SHADOW';

  h.style.font='900 10vmin/1 system-ui';

  h.style.color='#56c2ff';

  h.style.position='relative';

  div.appendChild(h);

  function update(){

    params.time+=params.speed;

    const shadows=[];

    for(let i=0;i<params.layers;i++){

      const offset=params.offset*(i+1);

      const x=offset*Math.cos(params.time+i*params.curve);

      const y=offset*Math.sin(params.time+i*params.curve);

      const blur=offset*0.5;

      shadows.push(`${x}px ${y}px ${blur}px rgba(86,194,255,${0.3-i*0.03})`);

    }

    h.style.textShadow=shadows.join(', ');

    requestAnimationFrame(update);

  }

  update();

  appendStage(id,div);

  slider(id,"Layers",3,15,1,params.layers,v=>{params.layers=v});

  slider(id,"Offset",2,15,1,params.offset,v=>{params.offset=v});

  slider(id,"Curve",0,1,0.1,params.curve,v=>{params.curve=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, update.toString());

};

/* 141 Bilateral Symmetry Paint */

inits["bilateral"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={decay:0.98, mirrorX:true, time:0, speed:0.01};

  const density=Array(c.width*c.height).fill(0);

  const state={mouse:{x:c.width/2,y:c.height/2}, drawing:false};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.05)'; ctx.fillRect(0,0,c.width,c.height);

    if(state.drawing){

      const x=state.mouse.x, y=state.mouse.y;

      const mx=params.mirrorX?c.width-x:x;

      for(let dy=-5;dy<=5;dy++){

        for(let dx=-5;dx<=5;dx++){

          const dist=Math.hypot(dx,dy);

          if(dist<5){

            const px1=Math.floor(x+dx), py1=Math.floor(y+dy);

            const px2=Math.floor(mx+dx), py2=Math.floor(y+dy);

            if(px1>=0&&px1<c.width&&py1>=0&&py1<c.height){

              density[py1*c.width+px1]=Math.min(255, density[py1*c.width+px1]+(5-dist)*5);

            }

            if(px2>=0&&px2<c.width&&py2>=0&&py2<c.height){

              density[py2*c.width+px2]=Math.min(255, density[py2*c.width+px2]+(5-dist)*5);

            }

          }

        }

      }

    }

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<density.length;i++){

      density[i]*=params.decay;

      const v=density[i];

      const idx=i*4;

      const hue=(v*0.5+params.time*50)%360;

      const h=hue/60, c2=0.8, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

      let r=0,g=0,b=0;

      if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

      d[idx]=(r+m)*255; d[idx+1]=(g+m)*255; d[idx+2]=(b+m)*255; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  c.addEventListener('pointerdown',e=>{state.drawing=true; const r=c.getBoundingClientRect(); state.mouse.x=e.clientX-r.left; state.mouse.y=e.clientY-r.top;});

  c.addEventListener('pointerup',e=>{state.drawing=false;});

  c.addEventListener('pointermove',e=>{if(state.drawing){const r=c.getBoundingClientRect(); state.mouse.x=e.clientX-r.left; state.mouse.y=e.clientY-r.top;}});

  slider(id,"Decay",0.9,0.99,0.01,params.decay,v=>{params.decay=v});

  setCode(id, draw.toString());

};

/* 142 Orbital Flow Trails */

inits["nbody"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={masses:8, drag:0.98, time:0, speed:0.01};

  const bodies=Array(params.masses).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, vx:0, vy:0, mass:10+Math.random()*20, trail:[]}));

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    for(const b of bodies){

      let fx=0, fy=0;

      for(const other of bodies){

        if(other===b) continue;

        const dx=other.x-b.x, dy=other.y-b.y, dist=Math.hypot(dx,dy);

        if(dist>1){

          const force=other.mass/(dist*dist+1);

          fx+=dx/dist*force*0.1;

          fy+=dy/dist*force*0.1;

        }

      }

      b.vx+=fx; b.vy+=fy;

      b.vx*=params.drag; b.vy*=params.drag;

      b.x+=b.vx; b.y+=b.vy;

      b.trail.push({x:b.x, y:b.y});

      if(b.trail.length>50) b.trail.shift();

      if(b.x<0||b.x>c.width){b.vx*=-0.8; b.x=Math.max(0,Math.min(c.width,b.x));}

      if(b.y<0||b.y>c.height){b.vy*=-0.8; b.y=Math.max(0,Math.min(c.height,b.y));}

    }

    for(const b of bodies){

      ctx.strokeStyle=`hsla(${(b.x/c.width*360)%360},80%,60%,0.6)`;

      ctx.lineWidth=2;

      ctx.beginPath();

      for(let i=1;i<b.trail.length;i++){

        const p1=b.trail[i-1], p2=b.trail[i];

        if(i===1) ctx.moveTo(p1.x,p1.y);

        ctx.lineTo(p2.x,p2.y);

      }

      ctx.stroke();

      ctx.fillStyle=`hsl(${(b.x/c.width*360)%360},80%,60%)`;

      ctx.beginPath();

      ctx.arc(b.x,b.y,Math.sqrt(b.mass),0,Math.PI*2);

      ctx.fill();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Masses",3,15,1,params.masses,v=>{params.masses=v; bodies.length=0; for(let i=0;i<v;i++) bodies.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:0, vy:0, mass:10+Math.random()*20, trail:[]});});

  slider(id,"Drag",0.9,0.99,0.01,params.drag,v=>{params.drag=v});

  setCode(id, draw.toString());

};

/* 65 Penrose Kite-Dart */

inits["penrose"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:3, phi:(1+Math.sqrt(5))/2};

  function penrose(x,y,size,type,depth){

    if(depth===0){

      ctx.beginPath();

      if(type===0){

        const x1=x, y1=y;

        const x2=x+size*Math.cos(Math.PI/5), y2=y+size*Math.sin(Math.PI/5);

        const x3=x+size*Math.cos(2*Math.PI/5), y3=y+size*Math.sin(2*Math.PI/5);

        ctx.moveTo(x1,y1);

        ctx.lineTo(x2,y2);

        ctx.lineTo(x3,y3);

        ctx.closePath();

        ctx.stroke();

      } else {

        const x1=x, y1=y;

        const x2=x+size*Math.cos(Math.PI/5), y2=y+size*Math.sin(Math.PI/5);

        const x3=x+size*Math.cos(3*Math.PI/5), y3=y+size*Math.sin(3*Math.PI/5);

        ctx.moveTo(x1,y1);

        ctx.lineTo(x2,y2);

        ctx.lineTo(x3,y3);

        ctx.closePath();

        ctx.stroke();

      }

      return;

    }

    const s=size/params.phi;

    if(type===0){

      penrose(x,y,s,1,depth-1);

      penrose(x+s*Math.cos(Math.PI/5), y+s*Math.sin(Math.PI/5), s,0,depth-1);

    } else {

      penrose(x,y,s,0,depth-1);

      penrose(x+s*Math.cos(2*Math.PI/5), y+s*Math.sin(2*Math.PI/5), s,1,depth-1);

    }

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.3;

    penrose(cx,cy,size,0,params.depth);

  }

  draw();

  slider(id,"Depth",1,5,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 112 SVG Gradient Mesh Beasts */

inits["svg-mesh"]=({id})=>{

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');

  svg.setAttribute('viewBox','0 0 200 200');

  svg.style.width='100%';

  svg.style.height='60vh';

  svg.style.background='var(--stage)';

  const params={density:8, time:0, speed:0.01};

  function createMesh(){

    while(svg.firstChild) svg.removeChild(svg.firstChild);

    const defs=document.createElementNS(svg.namespaceURI,'defs');

    const grad=document.createElementNS(svg.namespaceURI,'linearGradient');

    grad.setAttribute('id','meshGrad');

    grad.setAttribute('x1','0%'); grad.setAttribute('y1','0%');

    grad.setAttribute('x2','100%'); grad.setAttribute('y2','100%');

    for(let i=0;i<=params.density;i++){

      const stop=document.createElementNS(svg.namespaceURI,'stop');

      const offset=i/params.density*100;

      const hue=(i*360/params.density+params.time*50)%360;

      stop.setAttribute('offset',offset+'%');

      stop.setAttribute('stop-color',`hsl(${hue},80%,60%)`);

      grad.appendChild(stop);

    }

    defs.appendChild(grad);

    svg.appendChild(defs);

    const rect=document.createElementNS(svg.namespaceURI,'rect');

    rect.setAttribute('width','200');

    rect.setAttribute('height','200');

    rect.setAttribute('fill','url(#meshGrad)');

    svg.appendChild(rect);

  }

  function update(){

    params.time+=params.speed;

    createMesh();

    requestAnimationFrame(update);

  }

  update();

  appendStage(id,svg);

  slider(id,"Density",4,16,1,params.density,v=>{params.density=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, update.toString());

};

/* 113 Escherized Tessellations */

inits["escher-tiles"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={morph:0.3, orientation:0, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    const tile=40;

    for(let y=0;y<c.height;y+=tile){

      for(let x=0;x<c.width;x+=tile){

        const mx=(x/tile+y/tile)%2;

        const my=(x/tile-y/tile)%2;

        ctx.save();

        ctx.translate(x+tile/2, y+tile/2);

        ctx.rotate(params.orientation+params.time);

        ctx.beginPath();

        const morph=Math.sin(params.time+mx+my)*params.morph;

        ctx.moveTo(-tile/2+morph, -tile/2);

        ctx.lineTo(tile/2-morph, -tile/2);

        ctx.lineTo(tile/2, tile/2-morph);

        ctx.lineTo(-tile/2, tile/2+morph);

        ctx.closePath();

        ctx.stroke();

        ctx.restore();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Morph",0,0.5,0.05,params.morph,v=>{params.morph=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 115 Bezier Foam */

inits["bezier-foam"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={cells:12, jitter:0.2, tension:0.5, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=2;

    const cx=c.width/2, cy=c.height/2, r=Math.min(c.width,c.height)*0.3;

    for(let i=0;i<params.cells;i++){

      const angle=i*Math.PI*2/params.cells+params.time;

      const x1=cx+Math.cos(angle)*r, y1=cy+Math.sin(angle)*r;

      const x2=cx+Math.cos(angle+Math.PI*2/params.cells)*r, y2=cy+Math.sin(angle+Math.PI*2/params.cells)*r;

      const cp1x=x1+Math.cos(angle+Math.PI/2)*r*params.tension, cp1y=y1+Math.sin(angle+Math.PI/2)*r*params.tension;

      const cp2x=x2+Math.cos(angle+Math.PI*2/params.cells+Math.PI/2)*r*params.tension, cp2y=y2+Math.sin(angle+Math.PI*2/params.cells+Math.PI/2)*r*params.tension;

      ctx.beginPath();

      ctx.moveTo(x1,y1);

      ctx.bezierCurveTo(cp1x,cp1y, cp2x,cp2y, x2,y2);

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Cells",6,24,1,params.cells,v=>{params.cells=v});

  slider(id,"Tension",0,1,0.1,params.tension,v=>{params.tension=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 119 Eikonal Rays */

inits["eikonal"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={rays:30, speed:0.5, time:0, tSpeed:0.01};

  const rays=Array(params.rays).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, angle:Math.random()*Math.PI*2, life:1}));

  function speedField(x,y){

    return 0.5+fbm(x*0.01+params.time, y*0.01, 3, 2, 0.5)*0.5;

  }

  function draw(){

    params.time+=params.tSpeed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    for(const ray of rays){

      const s=speedField(ray.x, ray.y);

      ray.x+=Math.cos(ray.angle)*params.speed*s;

      ray.y+=Math.sin(ray.angle)*params.speed*s;

      ray.life*=0.995;

      if(ray.x<0||ray.x>c.width||ray.y<0||ray.y>c.height||ray.life<0.1){

        ray.x=Math.random()*c.width;

        ray.y=Math.random()*c.height;

        ray.angle=Math.random()*Math.PI*2;

        ray.life=1;

      }

      const hue=(ray.x/c.width*360+params.time*50)%360;

      ctx.strokeStyle=`hsla(${hue},80%,60%,${ray.life*0.6})`;

      ctx.beginPath();

      ctx.arc(ray.x,ray.y,2,0,Math.PI*2);

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Rays",10,60,5,params.rays,v=>{params.rays=v; rays.length=0; for(let i=0;i<v;i++) rays.push({x:Math.random()*c.width, y:Math.random()*c.height, angle:Math.random()*Math.PI*2, life:1});});

  slider(id,"Speed",0.1,2,0.1,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 120 Anamorphic Stretch */

inits["anamorph"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={perspective:0.5, skew:0.3, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=1;

    for(let y=0;y<c.height;y+=20){

      for(let x=0;x<c.width;x+=20){

        const dx=(x-c.width/2)/c.width;

        const dy=(y-c.height/2)/c.height;

        const warp=1+Math.sin(params.time+dx*Math.PI*2)*params.perspective;

        const skew=Math.cos(params.time+dy*Math.PI*2)*params.skew;

        const wx=x+dx*warp*20+skew*10;

        const wy=y+dy*warp*20;

        ctx.beginPath();

        ctx.arc(wx,wy,2,0,Math.PI*2);

        ctx.fill();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Perspective",0,1,0.05,params.perspective,v=>{params.perspective=v});

  slider(id,"Skew",0,0.5,0.05,params.skew,v=>{params.skew=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 130 Polar SDF Zipper */

inits["polar-zipper"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={blend:15, spin:0, speed:0.01};

  function polarSDF(x,y,cx,cy){

    const dx=x-cx, dy=y-cy;

    const r=Math.hypot(dx,dy);

    const a=Math.atan2(dy,dx);

    return Math.abs(r-50-Math.sin(a*5+params.spin)*20);

  }

  function smoothUnion(a,b,k){

    const h=Math.max(k-Math.abs(a-b),0)/k;

    return Math.min(a,b)-h*h*h*k/6;

  }

  function draw(){

    params.spin+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let dist=polarSDF(x,y,cx,cy);

        for(let i=1;i<8;i++){

          const angle=i*Math.PI*2/8+params.spin;

          const nx=cx+Math.cos(angle)*100;

          const ny=cy+Math.sin(angle)*100;

          dist=smoothUnion(dist, polarSDF(x,y,nx,ny), params.blend);

        }

        const v=Math.abs(dist)<3?255:Math.max(0,255-Math.abs(dist)*10);

        const i=(y*c.width+x)*4;

        const hue=(dist*10+params.spin*100)%360;

        const h=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Blend",5,30,1,params.blend,v=>{params.blend=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 131 Bezier Glyph Drift */

inits["glyph-drift"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={drift:0.3, stroke:2, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=params.stroke;

    const cx=c.width/2, cy=c.height/2;

    const text='ERRL';

    ctx.font='bold 80px system-ui';

    ctx.textAlign='center';

    ctx.textBaseline='middle';

    for(let i=0;i<text.length;i++){

      const char=text[i];

      const offset=i*60-90;

      const n=fbm((cx+offset)*0.01+params.time, cy*0.01, 3, 2, 0.5);

      ctx.save();

      ctx.translate(cx+offset+Math.sin(params.time+i)*params.drift*10, cy+Math.cos(params.time+i)*params.drift*10);

      ctx.rotate(n*0.1);

      ctx.strokeText(char,0,0);

      ctx.restore();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Drift",0,1,0.1,params.drift,v=>{params.drift=v});

  slider(id,"Stroke",1,5,0.5,params.stroke,v=>{params.stroke=v; ctx.lineWidth=v;});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 132 Complex Warp Grids */

inits["warp-grids"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={density:20, time:0, speed:0.01};

  function warpMap(z){

    const z2=complexMul(z,z);

    return complexAdd(z2, [0.2,0.3]);

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=1;

    const scale=3/Math.min(c.width,c.height), cx=c.width/2, cy=c.height/2;

    for(let i=0;i<=params.density;i++){

      const t=i/params.density;

      ctx.beginPath();

      for(let j=0;j<=params.density;j++){

        const s=j/params.density;

        const x=(s-0.5)*c.width;

        const y=(t-0.5)*c.height;

        const re=(x-cx)*scale, im=(y-cy)*scale;

        const [wr,wi]=warpMap([re,im]);

        const px=cx+wr/scale, py=cy+wi/scale;

        j?ctx.lineTo(px,py):ctx.moveTo(px,py);

      }

      ctx.stroke();

      ctx.beginPath();

      for(let j=0;j<=params.density;j++){

        const s=j/params.density;

        const x=(t-0.5)*c.width;

        const y=(s-0.5)*c.height;

        const re=(x-cx)*scale, im=(y-cy)*scale;

        const [wr,wi]=warpMap([re,im]);

        const px=cx+wr/scale, py=cy+wi/scale;

        j?ctx.lineTo(px,py):ctx.moveTo(px,py);

      }

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Density",10,40,2,params.density,v=>{params.density=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 133 Polar Foam Packing */

inits["polar-foam"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={layers:6, size:30, jitter:0.1, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2;

    for(let layer=0;layer<params.layers;layer++){

      const r=params.size*(layer+1);

      const count=Math.floor(r*0.1);

      for(let i=0;i<count;i++){

        const angle=i*Math.PI*2/count+params.time+layer*0.3;

        const j=Math.sin(params.time+layer+i)*params.jitter;

        const x=cx+Math.cos(angle)*(r+j*10);

        const y=cy+Math.sin(angle)*(r+j*10);

        const hue=(i*360/count+params.time*50)%360;

        ctx.fillStyle=`hsla(${hue},80%,60%,0.6)`;

        ctx.beginPath();

        ctx.arc(x,y,params.size*0.3,0,Math.PI*2);

        ctx.fill();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Layers",3,12,1,params.layers,v=>{params.layers=v});

  slider(id,"Size",20,50,2,params.size,v=>{params.size=v});

  slider(id,"Jitter",0,0.3,0.05,params.jitter,v=>{params.jitter=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 135 Tangent Bundle Trails */

inits["tangent-trails"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={trails:20, length:50, curvature:0.1, time:0, speed:0.01};

  const trails=Array(params.trails).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, points:[], angle:Math.random()*Math.PI*2}));

  function field(x,y){

    const n=fbm(x*0.01+params.time, y*0.01, 3, 2, 0.5);

    return n*Math.PI*2;

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    for(const trail of trails){

      const angle=field(trail.x, trail.y);

      trail.angle+=(angle-trail.angle)*params.curvature;

      trail.x+=Math.cos(trail.angle)*2;

      trail.y+=Math.sin(trail.angle)*2;

      trail.points.push({x:trail.x, y:trail.y});

      if(trail.points.length>params.length) trail.points.shift();

      if(trail.x<0||trail.x>c.width||trail.y<0||trail.y>c.height){

        trail.x=Math.random()*c.width;

        trail.y=Math.random()*c.height;

        trail.points=[];

      }

      ctx.strokeStyle=`hsla(${(trail.x/c.width*360)%360},80%,60%,0.6)`;

      ctx.lineWidth=2;

      ctx.beginPath();

      for(let i=1;i<trail.points.length;i++){

        const p1=trail.points[i-1], p2=trail.points[i];

        if(i===1) ctx.moveTo(p1.x,p1.y);

        ctx.lineTo(p2.x,p2.y);

      }

      ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Trails",5,40,1,params.trails,v=>{params.trails=v; trails.length=0; for(let i=0;i<v;i++) trails.push({x:Math.random()*c.width, y:Math.random()*c.height, points:[], angle:Math.random()*Math.PI*2});});

  slider(id,"Length",20,100,5,params.length,v=>{params.length=v});

  slider(id,"Curvature",0.05,0.3,0.01,params.curvature,v=>{params.curvature=v});

  setCode(id, draw.toString());

};

/* 136 Arc Lattice Weave */

inits["arc-weave"]=({id})=>{

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg');

  svg.setAttribute('viewBox','-1 -1 2 2');

  svg.style.width='100%';

  svg.style.height='60vh';

  svg.style.background='var(--stage)';

  const params={families:4, spacing:0.2, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    while(svg.firstChild) svg.removeChild(svg.firstChild);

    for(let f=0;f<params.families;f++){

      const offset=f*Math.PI*2/params.families+params.time;

      for(let i=0;i<10;i++){

        const a1=offset+i*params.spacing;

        const a2=offset+(i+1)*params.spacing;

        const x1=Math.cos(a1)*0.8, y1=Math.sin(a1)*0.8;

        const x2=Math.cos(a2)*0.8, y2=Math.sin(a2)*0.8;

        const el=document.createElementNS(svg.namespaceURI,'path');

        const largeArc=Math.abs(a2-a1)>Math.PI?1:0;

        el.setAttribute('d',`M ${x1} ${y1} A 0.8 0.8 0 ${largeArc} 1 ${x2} ${y2}`);

        el.setAttribute('fill','none');

        el.setAttribute('stroke',`hsl(${(f*360/params.families)%360},80%,60%)`);

        el.setAttribute('stroke-width','.01');

        svg.appendChild(el);

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  appendStage(id,svg);

  slider(id,"Families",2,8,1,params.families,v=>{params.families=v});

  slider(id,"Spacing",0.1,0.4,0.05,params.spacing,v=>{params.spacing=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 137 Polar Brickwork */

inits["polar-bricks"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={rings:8, brickSize:20, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2;

    for(let ring=0;ring<params.rings;ring++){

      const r=30+ring*params.brickSize*1.5;

      const circumference=Math.PI*2*r;

      const bricks=Math.floor(circumference/params.brickSize);

      for(let i=0;i<bricks;i++){

        const angle=i*Math.PI*2/bricks+params.time*0.1;

        const x1=cx+Math.cos(angle)*r, y1=cy+Math.sin(angle)*r;

        const x2=cx+Math.cos(angle+Math.PI*2/bricks)*r, y2=cy+Math.sin(angle+Math.PI*2/bricks)*r;

        const hue=(ring*30+i*5+params.time*50)%360;

        ctx.fillStyle=`hsl(${hue},80%,60%)`;

        ctx.beginPath();

        ctx.moveTo(x1,y1);

        ctx.lineTo(x2,y2);

        ctx.lineTo(x2+Math.cos(angle+Math.PI*2/bricks)*(params.brickSize*0.3), y2+Math.sin(angle+Math.PI*2/bricks)*(params.brickSize*0.3));

        ctx.lineTo(x1+Math.cos(angle)*(params.brickSize*0.3), y1+Math.sin(angle)*(params.brickSize*0.3));

        ctx.closePath();

        ctx.fill();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Rings",4,16,1,params.rings,v=>{params.rings=v});

  slider(id,"Brick size",10,40,2,params.brickSize,v=>{params.brickSize=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 138 Gasket Lightning */

inits["lichtenberg"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={charge:0.3, glow:true, time:0, speed:0.01};

  const branches=[];

  function addBranch(x,y,angle,depth){

    if(depth>8) return;

    if(Math.random()>params.charge) return;

    const len=20+Math.random()*30;

    const nx=x+Math.cos(angle)*len;

    const ny=y+Math.sin(angle)*len;

    branches.push({x,y,nx,ny});

    addBranch(nx,ny, angle+Math.random()*0.5-0.25, depth+1);

    if(Math.random()<0.3) addBranch(nx,ny, angle+Math.random()*0.5-0.25, depth+1);

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    branches.length=0;

    addBranch(c.width/2, c.height, -Math.PI/2, 0);

    ctx.strokeStyle='#56c2ff';

    ctx.lineWidth=2;

    for(const b of branches){

      ctx.beginPath();

      ctx.moveTo(b.x,b.y);

      ctx.lineTo(b.nx,b.ny);

      ctx.stroke();

      if(params.glow){

        ctx.shadowColor='#56c2ff';

        ctx.shadowBlur=8;

        ctx.stroke();

        ctx.shadowBlur=0;

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Charge",0.1,0.5,0.05,params.charge,v=>{params.charge=v});

  setCode(id, draw.toString());

};

/* 140 Quilted Conics */

inits["quilt-conics"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={seam:5, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const tile=60;

    for(let y=0;y<c.height;y+=tile){

      for(let x=0;x<c.width;x+=tile){

        const hue=((x/tile+y/tile)*30+params.time*50)%360;

        ctx.fillStyle=`hsl(${hue},80%,60%)`;

        ctx.beginPath();

        ctx.ellipse(x+tile/2, y+tile/2, tile/2-params.seam, tile/2-params.seam, 0, 0, Math.PI*2);

        ctx.fill();

        ctx.strokeStyle=`hsl(${(hue+180)%360},80%,40%)`;

        ctx.lineWidth=params.seam;

        ctx.stroke();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Seam",2,15,1,params.seam,v=>{params.seam=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 144 Conformal Logo Melt */

inits["logo-melt"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={strength:0.3, freq:0.02, time:0, speed:0.01};

  function conformalMap(z){

    const [re,im]=z;

    const r2=re*re+im*im;

    if(r2<1e-6) return [re,im];

    return [re+params.strength*re/r2, im-params.strength*im/r2];

  }

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=2;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.3;

    for(let y=0;y<c.height;y+=10){

      for(let x=0;x<c.width;x+=10){

        const re=(x-cx)*params.freq, im=(y-cy)*params.freq;

        const [wr,wi]=conformalMap([re,im]);

        const px=cx+wr/params.freq+Math.sin(params.time)*10;

        const py=cy+wi/params.freq+Math.cos(params.time)*10;

        ctx.beginPath();

        ctx.arc(px,py,2,0,Math.PI*2);

        ctx.fill();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Strength",0.1,0.8,0.05,params.strength,v=>{params.strength=v});

  slider(id,"Frequency",0.01,0.05,0.001,params.freq,v=>{params.freq=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 145 Halftone Warp Portrait */

inits["halftone"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={dotScale:8, contrast:1.2, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n=fbm(x*0.01+params.time, y*0.01, 4, 2, 0.5);

        const v=Math.pow(n, params.contrast);

        const dot=Math.sin(x/params.dotScale+params.time)*Math.sin(y/params.dotScale+params.time);

        const col=(v+dot*0.3)*255;

        const i=(y*c.width+x)*4;

        d[i]=col*0.9; d[i+1]=col*0.95; d[i+2]=col; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Dot scale",4,20,1,params.dotScale,v=>{params.dotScale=v});

  slider(id,"Contrast",0.5,2,0.1,params.contrast,v=>{params.contrast=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* ---------- REGISTRY: 100 TOYS ---------- */

/* Batch 1 (49-58 already asked previously, included; extending to 100) */

const specs = [

  // Batch 1

  {id:49, key:"rd-fake", title:"Reaction–Diffusion (Fake)", desc:"Feedback blur + high-pass + threshold → living zebra-coral skins.", notes:"Seeds + blur feedback approximate RD. Tweak seed, blur, threshold, decay."},

  {id:50, key:"soap-film", title:"Soap Film Shimmer", desc:"Multi-conic spectral bubble with highlights.", notes:"Conic gradients + screen-blended highlights mimic interference patterns."},

  {id:51, key:"conformal-grid", title:"Conformal Grid Lens", desc:"SVG lattice warped by f(z)=z+α/z.", notes:"Approximate conformal effect—lines bend near the origin via inverse term."},

  {id:52, key:"iso-cubes", title:"Iso Cubes Field", desc:"Three repeating-linear-gradients interlock.", notes:"Adjust tile size and colors for isometric cube illusions."},

  {id:53, key:"supershape", title:"Supershape Flowers", desc:"Gielis superformula drifting through flora modes.", notes:"m,n1,n2,n3 control lobes and curvature. Hue cycles; scale sets radius."},

  {id:54, key:"domain-coloring", title:"Domain Coloring z^n−1", desc:"Phase→hue, magnitude→bands.", notes:"See zeros and rays. Increase n for richer separatrices."},

  {id:55, key:"rule110", title:"Rule 110 Weave", desc:"Edge-of-chaos cellular automaton.", notes:"Row-by-row evolution. Change rule mask for other automata."},

  {id:56, key:"impossible-triangle", title:"Impossible Triangle", desc:"Clip-path + gradients fake an Escher limb.", notes:"Adjust gradient faces, polygon points, and drop-shadow for depth."},

  {id:57, key:"magnetic-orbs", title:"Magnetic Orbs", desc:"Particles repel cursor, ease back like mercury.", notes:"Tweak count, radius, strength, drag, hue drift."},

  {id:58, key:"chromaburst", title:"Chromaburst Text", desc:"bg-clip:text with conic diffraction and tilt.", notes:"Move pointer to tilt the diffraction focus; tweak zoom and colors."},

  // Batch 2 (59–68)

  {id:59, key:"mask-tunnel", title:"Recursive Mask Tunnel", desc:"XOR radial masks spinning into a void.", notes:"Stacked radial gradients as mask layers; spin via CSS animation."},

  {id:60, key:"poincare", title:"Poincaré Vibes", desc:"Arcs orthogonal to unit circle hint hyperbolic tilings.", notes:"Connect boundary points with orthogonal circle arcs."},

  {id:61, key:"moire-lines", title:"Radial Moiré", desc:"Overlaid line fields bloom interference.", notes:"Two rotating line fields; adjust angle and density."},

  {id:62, key:"perlin-smoke", title:"Perlin Smoke Sheets", desc:"Flowing noise wisps.", notes:"2D noise advected; tweak frequency, octaves, contrast."},

  {id:63, key:"curl-rivers", title:"Curl Noise Rivers", desc:"Particles drift on curl field.", notes:"Vector field integration with seeded particles."},

  {id:64, key:"quasicrystal", title:"Quasicrystal Starfield", desc:"Sum of rotated sinusoids.", notes:"Threshold creates aperiodic tilings; tweak angles and waves."},

  {id:65, key:"penrose", title:"Penrose Kite-Dart", desc:"Aperiodic tiling.", notes:"Inflation/deflation steps and matching rules."},

  {id:66, key:"apollonian", title:"Apollonian Gasket", desc:"Packed tangent circles.", notes:"Recursive circle inversions; depth and stroke."},

  {id:67, key:"lissajous", title:"Lissajous Lace", desc:"Parametric harmonics weave knots.", notes:"Adjust Ax/Ay and phase for complex figures."},

  {id:68, key:"superellipse", title:"Superellipse Frames", desc:"Minkowski rounded curves.", notes:"Exponent n controls squareness; rotate for frames."},

  // Batch 3 (69–78)

  {id:69, key:"clifford", title:"Clifford Attractor Glow", desc:"Strange attractor density render.", notes:"Params a,b,c,d; draw many points with decay."},

  {id:70, key:"ikeda", title:"Ikeda Map Mist", desc:"Chaotic map wisps.", notes:"Iterate map, plot density; tweak u and blur."},

  {id:71, key:"lorenz", title:"Lorenz Ribbon", desc:"Butterfly attractor trails.", notes:"Integrate ODE, draw ribbons; σ,ρ,β."},

  {id:72, key:"edge-react", title:"Reaction Rings", desc:"Edge detect feedback rings.", notes:"Kernel + threshold; feedback gain."},

  {id:73, key:"kaleidoscope", title:"Kaleidoscope Shader", desc:"Mirror N-fold tessellation.", notes:"Sector count, reflect offset, zoom."},

  {id:74, key:"hex-flow", title:"Hex Flow Field", desc:"Velocity vectors on hex lattice.", notes:"Noise → vector; sample and drift."},

  {id:75, key:"circle-pack", title:"Circle Packing Waves", desc:"Greedy packing with pulses.", notes:"Pack radius, pulse cadence."},

  {id:76, key:"fourier", title:"Fourier Drawing", desc:"Epicycles reconstruct a path.", notes:"Coeff count, speed, path source."},

  {id:77, key:"phase-carpets", title:"Complex Phase Carpets", desc:"Phase-only coloring.", notes:"Map f(z)→hue on grid."},

  {id:78, key:"parallax", title:"Heightmap Parallax", desc:"Tilted layers for depth.", notes:"Depth scale, lighting angle."},

  // Batch 4 (79–88)

  {id:79, key:"conic-caustics", title:"Conic Caustics", desc:"Simulated light caustics.", notes:"Conic stops and blend."},

  {id:80, key:"turing", title:"Turing Stripe Garden", desc:"Gray–Scott RD.", notes:"Feed/kill, diffusion ratio."},

  {id:81, key:"hyper-grid", title:"Hyperbolic Grid Warp", desc:"Curved grid lines.", notes:"Curvature k, stroke."},

  {id:82, key:"sdf-play", title:"SDF Shape Playground", desc:"Smooth unions of shapes.", notes:"Blend radius, thresholds."},

  {id:83, key:"raymarch-2d", title:"Raymarch Glow Orbs", desc:"Soft min blending.", notes:"Orb count, falloff, blend."},

  {id:84, key:"interference", title:"Wave Interference Flowers", desc:"Radial wave sums.", notes:"Frequency pairs, phase."},

  {id:85, key:"strange-map", title:"Strange Map Scroll", desc:"Iterated complex maps.", notes:"Function, iterations."},

  {id:86, key:"trefoil", title:"Trefoil Tube", desc:"3D-like curve projection.", notes:"Tube radius, param speed."},

  {id:87, key:"contours", title:"Topo Contour Lines", desc:"Heightmap contours.", notes:"Noise freq, levels."},

  {id:88, key:"diffraction-text", title:"Diffraction Text Grids", desc:"Text + rotating grids.", notes:"Grid angle, cell size."},

  // Batch 5 (89–98)

  {id:89, key:"spirograph", title:"Spirograph Engines", desc:"Hypotrochoids/epitrochoids.", notes:"R,r, phase, pen offset."},

  {id:90, key:"bedforms", title:"Butterfly Field Dunes", desc:"Vector field ripples.", notes:"Directional bias, steps."},

  {id:91, key:"menger", title:"Menger Carpet Cuts", desc:"Recursive holes.", notes:"Depth, cell size."},

  {id:92, key:"newton", title:"Newton Fractal z³−1", desc:"Basins of attraction.", notes:"Max iters, zoom."},

  {id:93, key:"fern", title:"Barnsley Fern", desc:"IFS rendering.", notes:"Iter count, color, blur."},

  {id:94, key:"koch", title:"Koch Snowflake", desc:"Recursive edge growth.", notes:"Depth, stroke."},

  {id:95, key:"dragon", title:"Dragon Curve Ribbon", desc:"Self-similar folds.", notes:"Depth, thickness."},

  {id:96, key:"hilbert", title:"Hilbert Space Fill", desc:"Space-filling curve.", notes:"Order, palette."},

  {id:97, key:"bitmask", title:"Bitmask Quilt", desc:"Cellular bitwise textures.", notes:"Bit ops, tile size."},

  {id:98, key:"primes", title:"Prime Spiral Constellations", desc:"Primes on spirals.", notes:"Layout, density, glow."},

  // Batch 6 (99–108)

  {id:99, key:"mod-bands", title:"Modulus Bands", desc:"Striped modulus patterns.", notes:"Mod k, angle."},

  {id:100, key:"phyllotaxis", title:"Phyllotaxis Seeds", desc:"Sunflower spirals.", notes:"Angle, spacing, color."},

  {id:101, key:"super-terrain", title:"Superformula Terrain", desc:"Radial height field.", notes:"m,n fields, height."},

  {id:102, key:"worley", title:"Worley Noise Cells", desc:"Cellular noise textures.", notes:"Points, metric."},

  {id:103, key:"metaballs", title:"Metaballs Pool", desc:"Soft merging blobs.", notes:"Count, iso threshold."},

  {id:104, key:"polar-roses", title:"Polar Roses", desc:"r=cos(kθ) petals.", notes:"k, n/d, thickness."},

  {id:105, key:"conics", title:"Hypnotic Conics", desc:"Ellipses/hyperbolas.", notes:"Eccentricity, phase."},

  {id:106, key:"harmonics", title:"Spherical Harmonics Heat", desc:"2D projection of Yₗᵐ.", notes:"l,m, palette."},

  {id:107, key:"moire-checker", title:"Moiré Checker Warps", desc:"Offset grids produce beats.", notes:"Angles, scale, phase."},

  {id:108, key:"log-spirals", title:"Complex Log Spirals", desc:"Families of growth spirals.", notes:"Rate, rotation."},

  // Batch 7 (109–118)

  {id:109, key:"torus-knot", title:"Torus Knot Map", desc:"Parametric p,q knot.", notes:"Thickness, speed."},

  {id:110, key:"wavelet", title:"Wavelet Tapestry", desc:"Localized wave sum.", notes:"Basis count, scale."},

  {id:111, key:"voronoi-pulse", title:"Pulsing Voronoi Rings", desc:"Annular cells pulsing.", notes:"Ring count, rate."},

  {id:112, key:"svg-mesh", title:"Gradient Mesh Beasts", desc:"SVG mesh blend.", notes:"Mesh density, colors."},

  {id:113, key:"escher-tiles", title:"Escherized Tessellations", desc:"Morph tiles onto lattice.", notes:"Morph, orientation."},

  {id:114, key:"sinewarp-text", title:"Sinewarp Text", desc:"BG-position wave warp.", notes:"Amplitude, freq, speed."},

  {id:115, key:"bezier-foam", title:"Bezier Foam", desc:"Bubble-like bezier cells.", notes:"Control jitter, tension."},

  {id:116, key:"fbm-sky", title:"fBm Sky", desc:"Layered noise clouds.", notes:"Octaves, lacunarity."},

  {id:117, key:"dla", title:"Diffusion-Limited Aggregation", desc:"Random walker crystals.", notes:"Walkers, stick prob."},

  {id:118, key:"caustic-grid", title:"Sunken Grid Caustics", desc:"Refractive displacement.", notes:"Refraction strength, flow."},

  // Batch 8 (119–128)

  {id:119, key:"eikonal", title:"Eikonal Rays", desc:"Variable medium rays.", notes:"Speed field, ray count."},

  {id:120, key:"anamorph", title:"Anamorphic Stretch", desc:"Transform illusions.", notes:"Perspective, skew."},

  {id:121, key:"radial-weave", title:"Radial Gradient Weave", desc:"Interlaced radials.", notes:"Stops, blend, phase."},

  {id:122, key:"golden-flow", title:"Golden Angle Flow", desc:"Phyllotaxis streamlines.", notes:"Angle drift, density."},

  {id:123, key:"kaleid-voronoi", title:"Kaleid Voronoi Mirror", desc:"Voronoi in mirrored sectors.", notes:"Sector count, sites."},

  {id:124, key:"roots-garden", title:"Complex Roots Garden", desc:"Basins and critical lines.", notes:"Polynomial, zoom."},

  {id:125, key:"marble", title:"Signed Noise Marble", desc:"Turbulence veins.", notes:"Warp strength, freq."},

  {id:126, key:"orbit-rings", title:"Gradient Orbit Rings", desc:"Conic rings in orbit.", notes:"Count, thickness, spin."},

  {id:127, key:"flames", title:"Fractal Flames 2D", desc:"Variations with densities.", notes:"Transforms, gamma."},

  {id:128, key:"amoeba", title:"Amoeba Marchers", desc:"Elastic contour followers.", notes:"March speed, squish."},

  // Batch 9 (129–138)

  {id:129, key:"shadow-text", title:"Shadow March Text", desc:"Moving shadow tunnels.", notes:"Layers, offset curve."},

  {id:130, key:"polar-zipper", title:"Polar SDF Zipper", desc:"Stitched radial shapes.", notes:"Blend radius, spin."},

  {id:131, key:"glyph-drift", title:"Bezier Glyph Drift", desc:"Text outlines drift.", notes:"Noise drift, stroke."},

  {id:132, key:"warp-grids", title:"Complex Warp Grids", desc:"Sample grids through maps.", notes:"f(z) family, density."},

  {id:133, key:"polar-foam", title:"Polar Foam Packing", desc:"Circular foam with fill.", notes:"Layers, size, jitter."},

  {id:134, key:"sierpinski", title:"Sierpinski Tri Tiles", desc:"Recursive tri removal.", notes:"Depth, rule, rotation."},

  {id:135, key:"tangent-trails", title:"Tangent Bundle Trails", desc:"Trails align to field.", notes:"Curvature bias, length."},

  {id:136, key:"arc-weave", title:"Arc Lattice Weave", desc:"Over/under arc weaving.", notes:"Arc families, spacing."},

  {id:137, key:"polar-bricks", title:"Polar Brickwork", desc:"Concentric bricks.", notes:"Ring count, brick size."},

  {id:138, key:"lichtenberg", title:"Gasket Lightning", desc:"Stochastic branching.", notes:"Charge map, glow."},

  // Batch 10 (139–148)

  {id:139, key:"chladni", title:"Chladni Plate Nodes", desc:"Nodal vibration patterns.", notes:"m,n modes, threshold."},

  {id:140, key:"quilt-conics", title:"Quilted Conics", desc:"Patchwork conic tiles.", notes:"Seam width, palette."},

  {id:141, key:"bilateral", title:"Bilateral Symmetry Paint", desc:"Rorschach mirroring.", notes:"Mirror line, decay."},

  {id:142, key:"nbody", title:"Orbital Flow Trails", desc:"N-body-ish trails.", notes:"Masses, drag."},

  {id:143, key:"polar-labyrinth", title:"Polar Sine Labyrinth", desc:"Thresholded polar sine.", notes:"Cell size, amplitude."},

  {id:144, key:"logo-melt", title:"Conformal Logo Melt", desc:"Warp logo via map.", notes:"Strength, frequency."},

  {id:145, key:"halftone", title:"Halftone Warp Portrait", desc:"Live halftone + flow.", notes:"Dot scale, contrast."},

  {id:146, key:"nebula", title:"Hypershift Gradient Nebula", desc:"Layered gradients + noise.", notes:"Octave hues, speed."},

  {id:147, key:"voronoi", title:"Voronoi Bloom", desc:"Relaxed cells mosaic.", notes:"Site count, jitter."},

  {id:148, key:"delaunay", title:"Delaunay Wireframe", desc:"Triangulated mesh jitter.", notes:"Points, thickness."},

];

/* Register all specs */

// Populate registry and render two‑pane UI instead of building 100 panels upfront
try {
  // keep registry in sync
  registry.splice(0, registry.length, ...specs);
  renderCats(specs);
  wireSearch(specs);
  renderList(specs);
  wireHeader(specs);
  // Deep link support or last selection
  const p = new URLSearchParams(location.search);
  const start = p.get('effect') || localStorage.getItem('mathlab_last');
  const firstId = start ? parseInt(start,10) : (specs[0]?.id);
  if(firstId) activatePreview(firstId);
} catch(e) { console.warn('Math Lab two‑pane init failed', e); }

/* ---------- SIMPLE PLACEHOLDER INIT FOR MANY KEYS ---------- */

/* For brevity, effects not explicitly implemented by a primitive above get a friendly placeholder panel that describes tweak plans. 

   You can ask me to wire any of these next ones explicitly. */

function placeholderInit(title){

  return ({id})=>{

    const box=document.createElement('div'); box.style.display='grid'; box.style.placeItems='center'; box.style.color='#9fb3cc'; box.style.font='600 16px/1.4 system-ui';

    box.innerHTML=`<div style="padding:1rem; text-align:center">"${title}" ready for wiring. Tap a slider to imagine:<br><small>Ask to activate this with a live primitive now.</small></div>`;

    appendStage(id,box);

    setCode(id, placeholderInit.toString());

  };

}

/* Map keys to init functions */

Object.assign(inits, {

  "rd-fake": inits["rd-fake"],

  "soap-film": inits["soap-film"],

  "conformal-grid": inits["conformal-grid"],

  "iso-cubes": inits["iso-cubes"],

  "supershape": inits["supershape"],

  "domain-coloring": inits["domain-coloring"],

  "rule110": inits["rule110"],

  "impossible-triangle": inits["impossible-triangle"],

  "magnetic-orbs": inits["magnetic-orbs"],

  "chromaburst": inits["chromaburst"],

  "mask-tunnel": inits["mask-tunnel"],

  "poincare": inits["poincare"],

  // Implemented effects:

  "moire-lines": inits["moire-lines"],

  "lissajous": inits["lissajous"],

  "superellipse": inits["superellipse"],

  "mod-bands": inits["mod-bands"],

  "polar-roses": inits["polar-roses"],

  "conics": inits["conics"],

  "spirograph": inits["spirograph"],

  "radial-weave": inits["radial-weave"],

  // More implemented effects:

  "perlin-smoke": inits["perlin-smoke"],

  "contours": inits["contours"],

  "worley": inits["worley"],

  "fbm-sky": inits["fbm-sky"],

  "marble": inits["marble"],

  "nebula": inits["nebula"],

  "newton": inits["newton"],

  "fern": inits["fern"],

  "koch": inits["koch"],

  "dragon": inits["dragon"],

  "hilbert": inits["hilbert"],

  "sierpinski": inits["sierpinski"],

  "menger": inits["menger"],

  "apollonian": inits["apollonian"],

  "circle-pack": inits["circle-pack"],

  "voronoi": inits["voronoi"],

  "phyllotaxis": inits["phyllotaxis"],

  "clifford": inits["clifford"],

  "ikeda": inits["ikeda"],

  "interference": inits["interference"],

  "quasicrystal": inits["quasicrystal"],

  "bitmask": inits["bitmask"],

  "primes": inits["primes"],

  "curl-rivers": inits["curl-rivers"],

  "metaballs": inits["metaballs"],

  "dla": inits["dla"],

  "lorenz": inits["lorenz"],

  "kaleidoscope": inits["kaleidoscope"],

  "phase-carpets": inits["phase-carpets"],

  "conic-caustics": inits["conic-caustics"],

  "hyper-grid": inits["hyper-grid"],

  "trefoil": inits["trefoil"],

  "diffraction-text": inits["diffraction-text"],

  "bedforms": inits["bedforms"],

  "super-terrain": inits["super-terrain"],

  "log-spirals": inits["log-spirals"],

  "voronoi-pulse": inits["voronoi-pulse"],

  "golden-flow": inits["golden-flow"],

  "hex-flow": inits["hex-flow"],

  "fourier": inits["fourier"],

  "parallax": inits["parallax"],

  "turing": inits["turing"],

  "strange-map": inits["strange-map"],

  "torus-knot": inits["torus-knot"],

  "wavelet": inits["wavelet"],

  "caustic-grid": inits["caustic-grid"],

  "kaleid-voronoi": inits["kaleid-voronoi"],

  "roots-garden": inits["roots-garden"],

  "orbit-rings": inits["orbit-rings"],

  "chladni": inits["chladni"],

  "polar-labyrinth": inits["polar-labyrinth"],

  "delaunay": inits["delaunay"],

  "edge-react": inits["edge-react"],

  "raymarch-2d": inits["raymarch-2d"],

  "sdf-play": inits["sdf-play"],

  "harmonics": inits["harmonics"],

  "moire-checker": inits["moire-checker"],

  "sinewarp-text": inits["sinewarp-text"],

  "flames": inits["flames"],

  "amoeba": inits["amoeba"],

  "shadow-text": inits["shadow-text"],

  "bilateral": inits["bilateral"],

  "nbody": inits["nbody"],

  "penrose": inits["penrose"],

  "svg-mesh": inits["svg-mesh"],

  "escher-tiles": inits["escher-tiles"],

  "bezier-foam": inits["bezier-foam"],

  "eikonal": inits["eikonal"],

  "anamorph": inits["anamorph"],

  "polar-zipper": inits["polar-zipper"],

  "glyph-drift": inits["glyph-drift"],

  "warp-grids": inits["warp-grids"],

  "polar-foam": inits["polar-foam"],

  "tangent-trails": inits["tangent-trails"],

  "arc-weave": inits["arc-weave"],

  "polar-bricks": inits["polar-bricks"],

  "lichtenberg": inits["lichtenberg"],

  "quilt-conics": inits["quilt-conics"],

  "logo-melt": inits["logo-melt"],

  "halftone": inits["halftone"],

  // All effects implemented! No more placeholders.

});

/* Default activate first panel */

activate(49);

// Resolve Multitool links - use localhost in dev, relative path in production
document.querySelectorAll("[data-multitool-link]").forEach((el) => {
  const isDev = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
  el.setAttribute("href", isDev ? "http://localhost:5174" : "/multitool/");
});

</script>
</body>
</html>


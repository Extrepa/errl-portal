<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Curl Noise Rivers - Errl Shape Madness</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #03050c;
      --ink: #cfe7ff;
      --muted: #7f94b3;
      --panel: rgba(8, 12, 22, 0.85);
      --accent: #7cf6ff;
      --accent2: #ffaeff;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      background: radial-gradient(circle at 20% 30%, rgba(124,246,255,0.18), transparent 55%),
                  radial-gradient(circle at 80% 0%, rgba(255,174,255,0.14), transparent 60%),
                  var(--bg);
      color: var(--ink);
      font-family: 'JetBrains Mono', ui-monospace, SFMono-Regular, system-ui;
      min-height: 100vh;
    }
    .layout {
      width: min(1200px, 94vw);
      margin: 0 auto;
      padding: clamp(1rem, 4vw, 3rem);
      display: grid;
      gap: 1.5rem;
      grid-template-columns: minmax(260px, 320px) 1fr;
    }
    @media (max-width: 900px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }
    .panel {
      background: var(--panel);
      border: 1px solid rgba(124,246,255,0.18);
      border-radius: 16px;
      padding: 1.25rem;
      box-shadow: 0 25px 60px rgba(2, 4, 10, 0.65);
      backdrop-filter: blur(12px);
    }
    h1 {
      font-size: clamp(1.7rem, 4vw, 2.4rem);
      margin: 0 0 0.6rem;
      letter-spacing: -0.01em;
    }
    p { margin: 0 0 1rem; color: var(--muted); line-height: 1.5; }
    canvas {
      width: 100%;
      border-radius: 20px;
      border: 1px solid rgba(124,246,255,0.12);
      background: #01040b;
      display: block;
      box-shadow: 0 35px 90px rgba(1, 3, 8, 0.85);
      min-height: 420px;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .control {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    label {
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 0.72rem;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 0.4rem;
    }
    label span { color: var(--accent); }
    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      height: 4px;
      border-radius: 999px;
      background: rgba(255,255,255,0.1);
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: linear-gradient(130deg, var(--accent), var(--accent2));
      border: 2px solid #050711;
      box-shadow: 0 0 12px rgba(124,246,255,0.5);
      cursor: pointer;
    }
    .hint { font-size: 0.78rem; color: var(--muted); line-height: 1.4; }
  </style>
</head>
<body>
  <div class="layout">
    <div class="panel">
      <h1>Curl Noise Rivers</h1>
      <p>Sample value noise, take the perpendicular gradient, and push thousands of particles through that divergence-free field. Dial in how hard the flow warps, how long trails linger, and how many tracers you drop.</p>
      <div class="controls">
        <div class="control">
          <label>Particle Count <span data-label="count">900</span></label>
          <input type="range" min="200" max="1400" step="50" value="900" data-param="count">
        </div>
        <div class="control">
          <label>Field Strength <span data-label="strength">1.50</span></label>
          <input type="range" min="20" max="260" step="5" value="150" data-param="strength">
        </div>
        <div class="control">
          <label>Step Size <span data-label="step">0.65</span></label>
          <input type="range" min="5" max="160" step="5" value="65" data-param="step">
        </div>
        <div class="control">
          <label>Color Drift <span data-label="hue">180 deg</span></label>
          <input type="range" min="0" max="360" step="1" value="180" data-param="hue">
        </div>
        <div class="control">
          <label>Trail Fade <span data-label="fade">0.08</span></label>
          <input type="range" min="2" max="35" step="1" value="8" data-param="fade">
        </div>
      </div>
      <p class="hint">Pro tip: crank the field strength + lower the step size for tight whirlpools, or go the other way for slow aurora bands.</p>
    </div>
    <canvas id="riverCanvas" width="900" height="540" aria-label="Curl noise particle field"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('riverCanvas');
    const ctx = canvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const baseWidth = 900;
    const baseHeight = 540;
    canvas.style.width = '100%';
    canvas.width = baseWidth * dpr;
    canvas.height = baseHeight * dpr;
    ctx.scale(dpr, dpr);

    const params = {
      count: 900,
      strength: 150,
      step: 65,
      hue: 180,
      fade: 8
    };

    document.querySelectorAll('[data-param]').forEach((input) => {
      const key = input.dataset.param;
      input.addEventListener('input', () => {
        params[key] = parseFloat(input.value);
        updateLabel(key);
        if (key === 'count') rebuildParticles();
      });
    });

    function updateLabel(key) {
      const label = document.querySelector(`[data-label="${key}"]`);
      if (!label) return;
      switch (key) {
        case 'strength':
          label.textContent = (params.strength / 100).toFixed(2);
          break;
        case 'step':
          label.textContent = (params.step / 100).toFixed(2);
          break;
        case 'fade':
          label.textContent = (params.fade / 100).toFixed(2);
          break;
        case 'count':
          label.textContent = Math.round(params.count);
          break;
        case 'hue':
          label.textContent = `${Math.round(params.hue)} deg`;
          break;
        default:
          label.textContent = params[key];
      }
    }
    ['count','strength','step','hue','fade'].forEach(updateLabel);

    const particles = [];
    const noiseScale = 0.0015;
    const timeScale = 0.0003;
    let lastTime = 0;

    function rebuildParticles() {
      particles.length = 0;
      for (let i = 0; i < params.count; i++) {
        particles.push(spawnParticle());
      }
    }

    function spawnParticle() {
      const x = Math.random() * baseWidth;
      const y = Math.random() * baseHeight;
      return {
        x,
        y,
        prevX: x,
        prevY: y,
        life: Math.random() * 220 + 60
      };
    }

    function hash(x, y, z) {
      return fract(Math.sin(x * 127.1 + y * 311.7 + z * 74.7) * 43758.5453);
    }
    function fract(n) { return n - Math.floor(n); }

    function noise(x, y, z) {
      const xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
      const xf = x - xi, yf = y - yi, zf = z - zi;
      const u = fade(xf), v = fade(yf), w = fade(zf);
      let accum = 0;
      for (let dx = 0; dx <= 1; dx++) {
        for (let dy = 0; dy <= 1; dy++) {
          for (let dz = 0; dz <= 1; dz++) {
            const weight = ((dx ? u : 1 - u) * (dy ? v : 1 - v) * (dz ? w : 1 - w));
            accum += weight * hash(xi + dx, yi + dy, zi + dz);
          }
        }
      }
      return accum;
    }
    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }

    function curlNoise(x, y, t) {
      const eps = 0.0005;
      const n1 = noise(x, y + eps, t);
      const n2 = noise(x, y - eps, t);
      const n3 = noise(x + eps, y, t);
      const n4 = noise(x - eps, y, t);
      const gradY = (n1 - n2) / (2 * eps);
      const gradX = (n3 - n4) / (2 * eps);
      return [gradY, -gradX];
    }

    function stepParticles(delta) {
      const speed = params.strength / 6000;
      const stepSize = params.step / 9000;
      for (const p of particles) {
        p.prevX = p.x;
        p.prevY = p.y;
        const flow = curlNoise(p.x * noiseScale, p.y * noiseScale, lastTime * timeScale);
        p.x += flow[0] * speed * delta * 60 + (flow[1] * stepSize * 60);
        p.y += flow[1] * speed * delta * 60 - (flow[0] * stepSize * 60);
        p.life -= delta * 60;
        if (p.x < -10 || p.x > baseWidth + 10 || p.y < -10 || p.y > baseHeight + 10 || p.life <= 0) {
          Object.assign(p, spawnParticle());
        }
      }
    }

    function render() {
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = `rgba(3,7,16,${params.fade / 600})`;
      ctx.fillRect(0, 0, baseWidth, baseHeight);
      ctx.globalCompositeOperation = 'lighter';
      particles.forEach((p, idx) => {
        const hue = (params.hue + idx * 0.1 + lastTime * 0.02) % 360;
        ctx.strokeStyle = `hsla(${hue}, 85%, 65%, 0.35)`;
        ctx.lineWidth = 0.8;
        ctx.beginPath();
        ctx.moveTo(p.prevX, p.prevY);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      });
      ctx.restore();
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const delta = (timestamp - lastTime) / 1000 || 0.016;
      lastTime = timestamp;
      stepParticles(delta);
      render();
      requestAnimationFrame(loop);
    }

    rebuildParticles();
    requestAnimationFrame(loop);
  </script>
</body>
</html>

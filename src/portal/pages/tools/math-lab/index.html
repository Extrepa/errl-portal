<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Psychedelic Math Lab — 100 Toys | Errl</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<style>

  :root{

    --bg:#0a0c12; --ink:#eaf2ff; --mut:#8fa3bf; --accent:#56c2ff; --accent2:#b8ff3b;

    --card:#0f141d; --tab:#111826; --btn:#152033; --stage:#0b0f16;

  }

  html,body{margin:0;background:var(--bg);color:var(--ink);font:500 14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}

  .bar{position:sticky;top:0;z-index:10;background:var(--tab);display:flex;flex-wrap:wrap;gap:.5rem;padding:.6rem;border-bottom:1px solid #0d1522}

  .tab{appearance:none;border:0;border-radius:.6rem;background:var(--btn);color:var(--ink);padding:.5rem .7rem;font-weight:600}

  .tab.active{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#04101a}

  .wrap{padding:.6rem}

  .panel{display:none;background:var(--card);border:1px solid #0d1522;border-radius:.8rem;overflow:hidden;margin-bottom:.8rem}

  .panel.active{display:block}

  header{padding:.8rem 1rem;border-bottom:1px solid #0d1522;display:flex;align-items:center;justify-content:space-between;gap:.5rem}

  header h2{margin:0;font-size:1rem}

  header small{color:var(--mut)}

  .tools{display:flex;gap:.5rem;flex-wrap:wrap}

  .tool{display:flex;align-items:center;gap:.4rem;background:#0c1420;border:1px solid #0e1a2a;border-radius:.5rem;padding:.35rem .5rem}

  .tool input, .tool select{accent-color:var(--accent);color:var(--ink)}

  .stage{background:var(--stage)}

  canvas,svg,.stage div{display:block;width:100%;height:60vh}

  .code{background:#0b0f16;color:#cde;padding:.8rem 1rem;font:500 12px/1.4 ui-monospace;overflow:auto}

  .desc{padding:.6rem 1rem;color:var(--mut);border-top:1px solid #0d1522}

  .hint{padding:.6rem 1rem;color:#9fb3cc;border-top:1px solid #0d1522}

  @media (prefers-reduced-motion: reduce){ *{animation-duration:0.001ms!important;animation-iteration-count:1!important;transition-duration:0.001ms!important} }

  /* Portal header styles */
  .errl-header {
    position: sticky; top: 0; width: 100%;
    background:
      linear-gradient(135deg, rgba(220,220,240,0.95) 0%, rgba(180,180,200,0.9) 25%, rgba(160,160,180,0.9) 50%, rgba(180,180,200,0.9) 75%, rgba(220,220,240,0.95) 100%),
      linear-gradient(45deg, rgba(255,255,255,0.3) 0%, transparent 30%, transparent 70%, rgba(255,255,255,0.3) 100%);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 1px 0 rgba(255,255,255,0.4) inset, 0 -1px 0 rgba(0,0,0,0.2) inset;
    border-bottom: 1px solid rgba(120,120,140,0.6);
    padding: 0.75rem 1rem; z-index: 999; letter-spacing: -0.03em;
  }
  .errl-header-content { display:flex; align-items:center; justify-content:space-between; max-width:1200px; margin:0 auto; }
  .errl-home-btn{ display:inline-flex; align-items:center; gap:.5rem; color:#fff; background: linear-gradient(135deg, #ff0080 0%, #8000ff 25%, #0080ff 50%, #00ff80 75%, #ff8000 100%); background-size:200% 200%; border:1px solid rgba(255,255,255,0.3); border-radius:999px; font-size:.8rem; font-weight:600; line-height:1; padding:.55rem .9rem .6rem; box-shadow:0 4px 12px rgba(0,0,0,0.3), 0 1px 0 rgba(255,255,255,0.3) inset; text-decoration:none; text-shadow:0 1px 2px rgba(0,0,0,0.8); animation: rainbow-flow 3s linear infinite; }
  @keyframes rainbow-flow{ 0%{background-position:0% 50%} 50%{background-position:100% 50%} 100%{background-position:0% 50%} }
  @media (max-width: 640px){ .errl-home-btn{ width:38px; height:38px; padding:0; border-radius:999px; display:inline-grid; place-items:center; overflow:hidden; font-size:0; } .errl-home-btn::before{ content:'←'; font-size:16px; line-height:1; filter: drop-shadow(0 1px 2px rgba(0,0,0,.8)); } }
  .errl-nav{ display:flex; gap:.5rem; align-items:center; }
  .errl-bubble-btn{ position:relative; display:inline-flex; align-items:center; justify-content:center; min-width:6.5rem; max-width:10rem; padding:.6rem .9rem .7rem; border-radius:999px; font-size:.8rem; font-weight:600; line-height:1.1; text-align:center; color:#e8e8e8; text-decoration:none; white-space:nowrap; text-shadow:0 1px 3px rgba(0,0,0,0.8); background: linear-gradient(135deg, rgba(100,100,120,0.9) 0%, rgba(60,60,80,0.9) 25%, rgba(40,40,60,0.9) 50%, rgba(60,60,80,0.9) 75%, rgba(100,100,120,0.9) 100%), linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 30%, transparent 70%, rgba(255,255,255,0.1) 100%); border:2px solid transparent; background-clip:padding-box; box-shadow: 0 4px 12px rgba(0,0,0,0.3), 0 1px 0 rgba(255,255,255,0.2) inset, 0 -1px 0 rgba(0,0,0,0.3) inset; }
  .errl-bubble-btn::before{ content:""; position:absolute; inset:-2px; border-radius:999px; padding:2px; background: linear-gradient(90deg, rgba(0,255,255,0.6) 0%, rgba(255,0,255,0.6) 25%, rgba(255,255,0,0.6) 50%, rgba(0,255,0,0.6) 75%, rgba(0,255,255,0.6) 100%); background-size:200% 100%; mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0); mask-composite:xor; -webkit-mask-composite:xor; animation: led-flow 2s linear infinite; opacity:.7; }
  @keyframes led-flow{ 0%{background-position:0% 50%} 100%{background-position:200% 50%} }
  .errl-bubble-btn.active{ background: linear-gradient(135deg, rgba(140,140,160,0.95) 0%, rgba(100,100,130,0.95) 25%, rgba(80,80,110,0.95) 50%, rgba(100,100,130,0.95) 75%, rgba(140,140,160,0.95) 100%), linear-gradient(45deg, rgba(255,255,255,0.2) 0%, transparent 30%, transparent 70%, rgba(255,255,255,0.2) 100%); color:#fff; font-weight:700; text-shadow:0 1px 3px rgba(0,0,0,0.9); box-shadow: 0 6px 16px rgba(0,0,0,0.4), 0 1px 0 rgba(255,255,255,0.3) inset, 0 -1px 0 rgba(0,0,0,0.4) inset; }
  .errl-bubble-btn.active::before{ background: radial-gradient(circle at 0% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 25% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 50% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 75% 50%, rgba(255,255,255,0.8) 0%, transparent 25%), radial-gradient(circle at 100% 50%, rgba(255,255,255,0.8) 0%, transparent 25%); background-size:20% 100%; animation: led-pulse 1s ease-in-out infinite alternate; opacity:.9; }
  @keyframes led-pulse{ 0%{opacity:.5} 100%{opacity:1} }

</style>
</head>
<body>
  <header class="errl-header">
    <div class="errl-header-content">
      <a class="errl-home-btn" href="../../index.html">← Back to Portal</a>
      <nav class="errl-nav">
        <a class="errl-bubble-btn" href="../../about/index.html">About Errl</a>
        <a class="errl-bubble-btn" href="../../gallery/index.html">Gallery</a>
        <a class="errl-bubble-btn" href="../../projects/index.html">Projects</a>
        <a class="errl-bubble-btn" href="../../studio.html">Studio</a>
        <a class="errl-bubble-btn" href="../../pin-designer/index.html">Pin Designer</a>
        <a class="errl-bubble-btn active" href="../index.html">Tools</a>
      </nav>
    </div>
  </header>

<div class="bar" id="tabs"></div>

<div class="wrap" id="panels"></div>

<script>

/* ---------- UTILITIES ---------- */

const tabs = document.getElementById('tabs');

const panels = document.getElementById('panels');

const registry = []; // specs for 100 toys

const inits = {};    // init functions by key

function addSpec(spec){

  registry.push(spec);

  const b=document.createElement('button'); b.className='tab'; b.textContent=`${spec.id}. ${spec.title}`; b.onclick=()=>activate(spec.id); tabs.appendChild(b);

  const p=document.createElement('section'); p.className='panel'; p.id='panel-'+spec.id;

  p.innerHTML=`

    <header>

      <div><h2>${spec.id}. ${spec.title}</h2><small>${spec.desc}</small></div>

      <div class="tools" id="tools-${spec.id}"></div>

    </header>

    <div class="stage" id="stage-${spec.id}"></div>

    <pre class="code" id="code-${spec.id}"></pre>

    <div class="desc">${spec.notes}</div>

    <div class="hint">Tip: Drag, tap, and tweak. Code block shows the core generator behind the preview.</div>

  `;

  panels.appendChild(p);

}

function activate(id){

  [...document.querySelectorAll('.tab')].forEach((t,i)=>t.classList.toggle('active', registry[i].id===id));

  [...document.querySelectorAll('.panel')].forEach(p=>p.classList.remove('active'));

  const el=document.getElementById('panel-'+id); el.classList.add('active');

  if(!el.dataset.init){ inits[registry.find(r=>r.id===id).key]({id}); el.dataset.init=1; }

}

function appendStage(id,node){ document.getElementById('stage-'+id).appendChild(node); }

function appendTool(id,node){ document.getElementById('tools-'+id).appendChild(node); }

function setCode(id,src){ document.getElementById('code-'+id).textContent = src.trim(); }

/* ---------- PRIMITIVES ---------- */

/* Canvas animation host with requestAnimationFrame */

function makeCanvas(id){

  const c=document.createElement('canvas'); appendStage(id,c);

  const ctx=c.getContext('2d',{alpha:true,desynchronized:true});

  function resize(){c.width=c.clientWidth; c.height=c.clientHeight}

  resize(); addEventListener('resize',resize, {passive:true});

  return {c,ctx};

}

/* Particle field primitive */

function particleField({id, params}){

  const {c,ctx}=makeCanvas(id);

  const P=Array(params.count).fill().map(_=>({

    x:Math.random()*c.width, y:Math.random()*c.height,

    vx:(Math.random()*2-1)*params.speed, vy:(Math.random()*2-1)*params.speed,

    size: params.sizeMin + Math.random()*(params.sizeMax-params.sizeMin),

    hue: Math.random()*360

  }));

  const state={mouse:{x:c.width/2,y:c.height/2}, running:true};

  function step(){

    ctx.fillStyle=`rgba(11,13,18,${params.fade})`; ctx.fillRect(0,0,c.width,c.height);

    const r = params.radius;

    for(const p of P){

      const dx=p.x-state.mouse.x, dy=p.y-state.mouse.y, d=Math.hypot(dx,dy);

      if(d<r){ const force=(r-d)/r*params.strength; const ang=Math.atan2(dy,dx);

        p.vx += Math.cos(ang)*force*params.accel; p.vy += Math.sin(ang)*force*params.accel; p.size += 0.02;}

      p.vx*=params.drag; p.vy*=params.drag; p.x+=p.vx; p.y+=p.vy;

      if(p.x<-80||p.x>c.width+80||p.y<-80||p.y>c.height+80){ p.x=Math.random()*c.width; p.y=Math.random()*c.height; }

      ctx.beginPath(); const col=`hsl(${(p.hue+=params.hueDrift)%360},90%,60%)`; ctx.fillStyle=col; ctx.shadowColor=col; ctx.shadowBlur=12; ctx.arc(p.x,p.y,p.size,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;

    }

    if(state.running) requestAnimationFrame(step);

  }

  step();

  c.addEventListener('pointermove',e=>{const r=c.getBoundingClientRect(); state.mouse.x=e.clientX-r.left; state.mouse.y=e.clientY-r.top});

  return {code: particleField.toString()};

}

/* Supershape primitive */

function supershape({id, params}){

  const {c,ctx}=makeCanvas(id);

  function r(phi,m,a,b,n1,n2,n3){

    const t1=Math.pow(Math.abs(Math.cos(m*phi/4)/a),n2), t2=Math.pow(Math.abs(Math.sin(m*phi/4)/b),n3);

    return Math.pow(t1+t2,-1/n1);

  }

  let t=0;

  function draw(){

    t+=params.tSpeed;

    const m=params.mBase+params.mAmp*Math.sin(t*params.mRate),

          n1=params.n1Base+params.nAmp*(0.5+0.5*Math.sin(t*params.n1Rate)),

          n2=params.n2Base+params.nAmp*(0.5+0.5*Math.sin(t*params.n2Rate+1.2)),

          n3=params.n3Base+params.nAmp*(0.5+0.5*Math.sin(t*params.n3Rate-0.9));

    ctx.clearRect(0,0,c.width,c.height); ctx.save(); ctx.translate(c.width/2,c.height/2);

    const S=Math.min(c.width,c.height)*params.scale; ctx.scale(S,S);

    ctx.beginPath(); const steps=params.steps;

    for(let i=0;i<=steps;i++){const phi=i/steps*Math.PI*2; const rad=r(phi,m,1,1,n1,n2,n3); const x=rad*Math.cos(phi), y=rad*Math.sin(phi); i?ctx.lineTo(x,y):ctx.moveTo(x,y);}

    ctx.closePath(); const hue=(t*params.hueRate)%360; ctx.fillStyle=`hsla(${hue},70%,55%,${params.fillAlpha})`; ctx.strokeStyle=`hsla(${(hue+180)%360},80%,70%,${params.strokeAlpha})`; ctx.lineWidth=params.lineWidth; ctx.fill(); ctx.stroke(); ctx.restore();

    requestAnimationFrame(draw);

  }

  draw();

  return {code: supershape.toString()};

}

/* Domain coloring primitive for polynomial f(z)=z^n - 1 (n>=2) */

function domainColorPoly({id, params}){

  const {c,ctx}=makeCanvas(id);

  function hsl(h,s,l){s/=100;l/=100;const C=(1-Math.abs(2*l-1))*s,hh=h/60,X=C*(1-Math.abs(hh%2-1));let r=0,g=0,b=0;

    if(hh>=0&&hh<1){r=C;g=X}else if(hh<2){r=X;g=C}else if(hh<3){g=C;b=X}else if(hh<4){g=X;b=C}else if(hh<5){r=X;b=C}else{r=C;b=X}

    const m=l-C/2; return [(r+m)*255,(g+m)*255,(b+m)*255];

  }

  function powN(a,b,n){ // (a+ib)^n

    let ar=a, br=b; for(let k=2;k<=n;k++){

      const na=ar*a - br*b, nb=ar*b + br*a; ar=na; br=nb;

    }

    return [ar,br];

  }

  function plot(){

    const W=c.width,H=c.height, img=ctx.createImageData(W,H), d=img.data, scale=params.scale/Math.min(W,H), cx=W/2, cy=H/2;

    for(let y=0;y<H;y++)for(let x=0;x<W;x++){

      const re=(x-cx)*scale, im=(y-cy)*scale; const z=powN(re,im,params.n); const fr=z[0]-1, fi=z[1];

      const mag=Math.hypot(fr,fi), arg=Math.atan2(fi,fr), hue=((arg/(2*Math.PI))+0.5)*360*params.hueMul;

      const bands=Math.log2(mag+1e-9)*params.bandMul; const light=params.lightBase + params.lightAmp*Math.sin(bands*Math.PI);

      const col=hsl(hue, params.sat, light); const i=(y*W+x)*4; d[i]=col[0]; d[i+1]=col[1]; d[i+2]=col[2]; d[i+3]=255;

    }

    ctx.putImageData(img,0,0);

  }

  plot();

  return {code: domainColorPoly.toString(), rerender: plot};

}

/* Cellular automaton primitive (Rule mask 8-bit) */

function automaton1D({id, params}){

  const {c,ctx}=makeCanvas(id);

  const cell=params.cell, cols=Math.floor(c.width/cell), rows=Math.floor(c.height/cell);

  let row = Array(cols).fill(0).map(()=>Math.random()<params.seed?1:0);

  function nextRow(){

    const next = Array(cols).fill(0);

    for(let x=0;x<cols;x++){

      const a=row[(x-1+cols)%cols], b=row[x], c2=row[(x+1)%cols];

      const n=(a<<2)|(b<<1)|c2; next[x] = (params.rule >> n) & 1;

    }

    row=next;

  }

  let y=0; function step(){

    nextRow();

    for(let x=0;x<cols;x++){

      const v=row[x]?255:0; ctx.fillStyle=`rgb(${v},${v*params.gRatio},${v*params.bRatio})`;

      ctx.fillRect(x*cell,y*cell,cell,cell);

    }

    y++; if(y>=rows){y=0; ctx.clearRect(0,0,c.width,c.height);}

    requestAnimationFrame(step);

  } step();

  return {code: automaton1D.toString()};

}

/* SVG grid warp primitive (conformal-ish) */

function svgGridWarp({id, params}){

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('viewBox','-1 -1 2 2'); svg.style.width='100%'; svg.style.height='60vh'; svg.style.background='var(--stage)';

  function f([x,y]){ const r2=x*x+y*y, inv=r2>1e-6?[x/r2,y/r2]:[0,0]; return [x + params.alpha*inv[0], y + params.alpha*inv[1]]; }

  function line(u0,u1,steps=params.steps){

    const pts=[]; for(let i=0;i<=steps;i++){ const t=i/steps; const x=u0[0]*(1-t)+u1[0]*t, y=u0[1]*(1-t)+u1[1]*t; const [X,Y]=f([x,y]); pts.push(`${X},${Y}`); }

    const el=document.createElementNS(svg.namespaceURI,'polyline'); el.setAttribute('points',pts.join(' ')); el.setAttribute('fill','none'); el.setAttribute('stroke',params.stroke); el.setAttribute('stroke-width',params.sw); el.setAttribute('opacity',params.op); return el;

  }

  for(let i=0;i<params.N;i++){const s=-0.95+1.9*i/(params.N-1); svg.appendChild(line([-0.95,s],[0.95,s])); svg.appendChild(line([s,-0.95],[s,0.95]));}

  appendStage(id,svg);

  return {code: svgGridWarp.toString()};

}

/* CSS gradient block primitive */

function cssBlock({id, params}){

  const div=document.createElement('div'); div.style.width='100%'; div.style.height='60vh'; div.style.background=params.background; div.style.borderRadius=params.radius||'0';

  if(params.overlay){ const ov=document.createElement('div'); ov.style.position='relative'; ov.style.inset='0'; ov.style.width='100%'; ov.style.height='100%'; ov.style.mixBlendMode=params.blend||'screen'; ov.style.background=params.overlay; div.appendChild(ov); }

  appendStage(id,div);

  return {code: cssBlock.toString()};

}

/* Poincaré arcs primitive */

function poincareArcs({id, params}){

  const svg=document.createElementNS('http://www.w3.org/2000/svg','svg'); svg.setAttribute('viewBox','-1 -1 2 2'); svg.style.width='100%'; svg.style.height='60vh'; svg.style.background='var(--stage)';

  const circ=document.createElementNS(svg.namespaceURI,'circle'); circ.setAttribute('cx',0); circ.setAttribute('cy',0); circ.setAttribute('r',1); circ.setAttribute('fill','none'); circ.setAttribute('stroke','#446'); circ.setAttribute('stroke-width','.01'); svg.appendChild(circ);

  function arcThrough(p1,p2){const [x1,y1]=p1,[x2,y2]=p2; const den=x1*y2-x2*y1;

    if(Math.abs(den)<1e-6){const el=document.createElementNS(svg.namespaceURI,'line'); el.setAttribute('x1',x1); el.setAttribute('y1',y1); el.setAttribute('x2',x2); el.setAttribute('y2',y2); el.setAttribute('stroke',params.stroke); el.setAttribute('stroke-width','.01'); return el;}

    const s1=(1+x1*x1+y1*y1)/2, s2=(1+x2*x2+y2*y2)/2; const cx=(s1*y2-s2*y1)/den, cy=(x1*s2-x2*s1)/den; const r=Math.sqrt(cx*cx+cy*cy-1);

    const steps=params.steps, pts=[]; const tA=Math.atan2(y1-cy,x1-cx), tB=Math.atan2(y2-cy,x2-cx); let d=tB-tA; if(d>Math.PI) d-=2*Math.PI; if(d<-Math.PI) d+=2*Math.PI;

    for(let i=0;i<=steps;i++){const t=tA+d*i/steps; const x=cx+r*Math.cos(t), y=cy+r*Math.sin(t); pts.push(`${x},${y}`);}

    const el=document.createElementNS(svg.namespaceURI,'polyline'); el.setAttribute('points',pts.join(' ')); el.setAttribute('fill','none'); el.setAttribute('stroke',params.stroke); el.setAttribute('stroke-width','.01'); return el;

  }

  const P=params.P, pts=[]; for(let i=0;i<P;i++){const a=i/P*2*Math.PI; pts.push([Math.cos(a)*params.r, Math.sin(a)*params.r]);}

  for(let i=0;i<P;i++){svg.appendChild(arcThrough(pts[i], pts[(i+params.k1)%P])); svg.appendChild(arcThrough(pts[i], pts[(i+params.k2)%P]));}

  appendStage(id,svg);

  return {code: poincareArcs.toString()};

}

/* ---------- HELPER UTILITIES ---------- */

// Simple 2D noise (value noise)
function noise2D(x, y, seed = 0) {
  const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
  return n - Math.floor(n);
}

// Fractional Brownian Motion (fBm)
function fbm(x, y, octaves = 4, lacunarity = 2, gain = 0.5) {
  let value = 0, amplitude = 1, frequency = 1;
  for (let i = 0; i < octaves; i++) {
    value += amplitude * (noise2D(x * frequency, y * frequency) * 2 - 1);
    amplitude *= gain;
    frequency *= lacunarity;
  }
  return value * 0.5 + 0.5;
}

// Complex number operations
function complexMul(a, b) { return [a[0]*b[0] - a[1]*b[1], a[0]*b[1] + a[1]*b[0]]; }
function complexAdd(a, b) { return [a[0]+b[0], a[1]+b[1]]; }
function complexPow(z, n) {
  let r = Math.hypot(z[0], z[1]), theta = Math.atan2(z[1], z[0]);
  const rn = Math.pow(r, n), thetan = theta * n;
  return [rn * Math.cos(thetan), rn * Math.sin(thetan)];
}

// Voronoi helper
function voronoi(x, y, points) {
  let minDist = Infinity, closest = 0;
  for (let i = 0; i < points.length; i++) {
    const dx = x - points[i][0], dy = y - points[i][1], d = dx*dx + dy*dy;
    if (d < minDist) { minDist = d; closest = i; }
  }
  return { index: closest, dist: Math.sqrt(minDist) };
}

// Circle packing helper
function packCircles(width, height, minR, maxR, attempts = 1000) {
  const circles = [];
  for (let i = 0; i < attempts; i++) {
    const r = minR + Math.random() * (maxR - minR);
    let x = Math.random() * (width - 2*r) + r;
    let y = Math.random() * (height - 2*r) + r;
    let overlaps = false;
    for (const c of circles) {
      const dx = x - c.x, dy = y - c.y, d = Math.hypot(dx, dy);
      if (d < c.r + r) { overlaps = true; break; }
    }
    if (!overlaps) circles.push({x, y, r});
  }
  return circles;
}

/* Helper: make slider */

function slider(id,label,min,max,step,val,onchange){

  const w=document.createElement('div'); w.className='tool'; const inp=document.createElement('input'); inp.type='range'; inp.min=min; inp.max=max; inp.step=step; inp.value=val;

  const lab=document.createElement('label'); lab.textContent=label; const out=document.createElement('span'); out.textContent=val;

  inp.oninput=e=>{out.textContent=e.target.value; onchange(+e.target.value);}; w.appendChild(lab); w.appendChild(inp); w.appendChild(out); appendTool(id,w);

}

function select(id,label,options,val,onchange){

  const w=document.createElement('div'); w.className='tool'; const lab=document.createElement('label'); lab.textContent=label; const sel=document.createElement('select');

  for(const o of options){const opt=document.createElement('option'); opt.value=o.value; opt.textContent=o.label; if(o.value===val) opt.selected=true; sel.appendChild(opt);}

  sel.onchange=e=>onchange(e.target.value); w.appendChild(lab); w.appendChild(sel); appendTool(id,w);

}

/* ---------- INIT FUNCTIONS (mapped keys) ---------- */

/* 49 Reaction–Diffusion (Fake) via feedback blur/high-pass/threshold */

inits["rd-fake"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={seed:0.004, blur:2, hp:0.9, th:0.52, decay:0.995};

  const kernel=[1,2,1,2,4,2,1,2,1];

  function blur(img){const out=ctx.createImageData(img.width,img.height); const w=img.width,h=img.height,d=img.data,o=out.data; const norm=kernel.reduce((a,b)=>a+b,0);

    for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){let acc=0,i=(y*w+x)*4,k=0; for(let j=-1;j<=1;j++)for(let i2=-1;i2<=1;i2++){const p=((y+j)*w+(x+i2))*4; acc+=d[p]*kernel[k++];}

      const v=acc/norm; o[i]=o[i+1]=o[i+2]=v; o[i+3]=255;} return out;}

  function seedImg(){const img=ctx.createImageData(c.width,c.height),d=img.data; for(let i=0;i<d.length;i+=4){const n=Math.random()<params.seed?255:0; d[i]=d[i+1]=d[i+2]=n; d[i+3]=255;} return img;}

  let base=seedImg();

  function step(){let img=ctx.getImageData(0,0,c.width,c.height); for(let p=0;p<params.blur;p++) img=blur(img);

    const d=base.data,b=img.data; for(let i=0;i<d.length;i+=4){const hp=Math.max(0,d[i]*params.hp-b[i]*(1-params.hp)); const v=hp*params.decay+(Math.random()<params.seed*0.2?16:0);

      const t=v/255; const out=t>params.th?255:(t>params.th*0.9?180:24); d[i]=out; d[i+1]=out*0.95; d[i+2]=out*0.8;} ctx.putImageData(base,0,0); requestAnimationFrame(step);}

  ctx.putImageData(base,0,0); step();

  slider(id,"Blur",0,5,1,params.blur,v=>{params.blur=v});

  slider(id,"Threshold",0.1,0.9,0.01,params.th,v=>{params.th=v});

  setCode(id, step.toString());

};

/* 50 Soap Film (CSS conics + highlights) */

inits["soap-film"]=({id})=>{

  const background=`

    conic-gradient(from 0deg,

      rgba(255,255,255,.0) 0 10%, rgba(255,255,255,.15) 12% 14%, transparent 16% 100%),

    conic-gradient(from 210deg,

      #ff0068 0 11%, #ffd500 12% 23%, #66ff00 24% 35%, #00e1ff 36% 47%, #b100ff 48% 59%, #ff0068 60% 71%, #ffd500 72% 83%, #66ff00 84% 95%, #00e1ff 96% 100%)

  `;

  const overlay=`

    radial-gradient(120% 120% at 15% 20%, rgba(255,255,255,.5), transparent 40%),

    radial-gradient(80% 80% at 70% 75%, rgba(255,255,255,.35), transparent 45%)

  `;

  const {code}=cssBlock({id, params:{background, overlay, radius:'50%', blend:'screen'}});

  setCode(id, cssBlock.toString());

};

/* 51 Conformal Grid Lens (SVG warp) */

inits["conformal-grid"]=({id})=>{

  const {code}=svgGridWarp({id, params:{alpha:0.18, N:22, steps:120, stroke:"#8fd", sw:".01", op:".9"}});

  setCode(id, svgGridWarp.toString());

};

/* 52 Iso Cubes (CSS repeating linear-gradients) */

inits["iso-cubes"]=({id})=>{

  const sz=36;

  const background=`

    repeating-linear-gradient(150deg, #15253e 0 ${sz}px, transparent ${sz}px ${sz*2}px),

    repeating-linear-gradient(30deg,  #1f3a5f  0 ${sz}px, transparent ${sz}px ${sz*2}px),

    repeating-linear-gradient(90deg,  #2b4f7f  0 ${sz}px, transparent ${sz}px ${sz*2}px)

  `;

  const {code}=cssBlock({id, params:{background}});

  slider(id,"Tile size",16,80,2,sz,v=>{

    const bg=`

      repeating-linear-gradient(150deg, #15253e 0 ${v}px, transparent ${v}px ${v*2}px),

      repeating-linear-gradient(30deg,  #1f3a5f  0 ${v}px, transparent ${v}px ${v*2}px),

      repeating-linear-gradient(90deg,  #2b4f7f  0 ${v}px, transparent ${v}px ${v*2}px)

    `;

    document.getElementById('stage-'+id).firstChild.style.background=bg;

  });

  setCode(id, cssBlock.toString());

};

/* 53 Supershape Flowers */

inits["supershape"]=({id})=>{

  const {code}=supershape({id, params:{

    tSpeed:0.008, mBase:3, mAmp:3, mRate:0.37, n1Base:0.2, n2Base:0.2, n3Base:0.2, nAmp:1.1,

    n1Rate:0.23, n2Rate:0.31, n3Rate:0.29, scale:0.35, steps:800, hueRate:40, fillAlpha:0.4, strokeAlpha:0.9, lineWidth:0.01

  }});

  setCode(id, supershape.toString());

};

/* 54 Domain Coloring z^n - 1 */

inits["domain-coloring"]=({id})=>{

  const params={n:3, scale:3, hueMul:1, bandMul:1, lightBase:50, lightAmp:25, sat:95};

  const inst=domainColorPoly({id, params});

  slider(id,"Power n",2,6,1,params.n,v=>{params.n=v; inst.rerender();});

  slider(id,"Scale",1,6,0.1,params.scale,v=>{params.scale=v; inst.rerender();});

  setCode(id, domainColorPoly.toString());

};

/* 55 Rule 110 Automaton */

inits["rule110"]=({id})=>{

  const {code}=automaton1D({id, params:{cell:2, seed:0.5, rule:0b01101110, gRatio:0.6, bRatio:0.2}});

  slider(id,"Cell size",1,6,1,2,v=>{}); // visual; recreates on resize naturally

  setCode(id, automaton1D.toString());

};

/* 56 Impossible Triangle (CSS clip-path + gradients) */

inits["impossible-triangle"]=({id})=>{

  const background=`

    linear-gradient(135deg,#7bd 0 50%,transparent 0),

    linear-gradient(315deg,#59a 0 50%,transparent 0),

    linear-gradient(45deg,#9fe  0 50%,transparent 0)

  `;

  const div=document.createElement('div'); div.style.width='100%'; div.style.height='60vh'; div.style.background=background; div.style.clipPath='polygon(50% 4%, 96% 29%, 96% 31%, 55% 8%, 55% 42%, 53% 43%, 53% 8%, 9% 32%, 9% 29%)'; div.style.filter='drop-shadow(0 2vmin 3vmin rgba(0,0,0,.5))';

  appendStage(id,div);

  setCode(id, inits["impossible-triangle"].toString());

};

/* 57 Magnetic Orbs (particle field) */

inits["magnetic-orbs"]=({id})=>{

  const {code}=particleField({id, params:{count:220, speed:1.2, sizeMin:1.4, sizeMax:3.2, hueDrift:0.6, fade:0.18, radius:120, strength:10, accel:0.03, drag:0.98}});

  slider(id,"Count",60,400,10,220,v=>{}); // demo keeps fixed count at init for perf; can reinit for changes if needed

  setCode(id, particleField.toString());

};

/* 58 Chromaburst Text (CSS bg-clip:text + conics) */

inits["chromaburst"]=({id})=>{

  const div=document.createElement('div'); div.style.display='grid'; div.style.placeItems='center'; div.style.height='60vh'; div.style.background='#0a0e14';

  const h=document.createElement('h1'); h.textContent='CHROMABURST'; h.style.font='900 14vmin/1 system-ui'; h.style.letterSpacing='.02em'; h.style.color='transparent'; h.style.webkitBackgroundClip='text'; h.style.backgroundClip='text';

  function setBG(x='50%',y='50%',zoom=300){

    h.style.background=`

      conic-gradient(from 270deg at ${x} ${y}, #fff 265deg, #ff647f 269deg 271deg, #fff 275deg) left/0% 1em no-repeat,

      radial-gradient(circle at ${x} ${y}, hsl(200 100% 60% / .5), hsl(280 100% 60% / .5), hsl(60 100% 60% / .5)) 0/${zoom}% ${zoom}%

    `;

  }

  setBG();

  div.appendChild(h); appendStage(id,div);

  div.onpointermove=e=>{const r=h.getBoundingClientRect(), x=((e.clientX-r.left)/r.width*100).toFixed(2)+'%', y=((e.clientY-r.top)/r.height*100).toFixed(2)+'%'; setBG(x,y,300);}

  setCode(id, inits["chromaburst"].toString());

};

/* 59 Recursive Mask Tunnel (CSS radial XOR) */

inits["mask-tunnel"]=({id})=>{

  const box=document.createElement('div'); box.style.width='100%'; box.style.height='60vh'; box.style.display='grid'; box.style.placeItems='center'; box.style.background='#05070a';

  const hole=document.createElement('div'); hole.style.width='70vmin'; hole.style.aspectRatio='1'; hole.style.animation='spinTunnel 12s linear infinite';

  const style=document.createElement('style'); style.textContent=`@keyframes spinTunnel{to{transform:rotate(360deg)}}`; document.head.appendChild(style);

  hole.style.webkitMaskComposite='xor';

  hole.style.webkitMaskImage=`

    radial-gradient(closest-side, transparent 35%, black 36%),

    radial-gradient(closest-side, transparent 45%, black 46%),

    radial-gradient(closest-side, transparent 55%, black 56%),

    radial-gradient(closest-side, transparent 65%, black 66%),

    radial-gradient(closest-side, transparent 75%, black 76%),

    radial-gradient(closest-side, transparent 85%, black 86%)

  `;

  hole.style.webkitMaskPosition='50% 50%'; hole.style.webkitMaskRepeat='no-repeat';

  const inner=document.createElement('div'); inner.style.width='100%'; inner.style.height='100%';

  inner.style.background=`

    radial-gradient(closest-side,#0e1623,transparent 60%),

    conic-gradient(from 0deg, #1a2b44, #0e1623, #1a2b44)

  `;

  inner.style.filter='contrast(120%) saturate(120%)';

  hole.appendChild(inner); box.appendChild(hole); appendStage(id,box);

  setCode(id, inits["mask-tunnel"].toString());

};

/* 60 Poincaré Vibes (hyperbolic arcs) */

inits["poincare"]=({id})=>{

  const {code}=poincareArcs({id, params:{P:12, r:0.98, k1:2, k2:3, steps:120, stroke:'#58c'}});

  setCode(id, poincareArcs.toString());

};

/* 61 Radial Moiré */

inits["moire-lines"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={angle1:0, angle2:0.3, density:80, speed:0.01};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=1;

    const cx=c.width/2, cy=c.height/2, maxR=Math.hypot(cx,cy);

    params.angle1+=params.speed; params.angle2-=params.speed*0.7;

    for(let r=0;r<maxR;r+=params.density){

      const steps=Math.floor(r*0.1)+8;

      for(let i=0;i<steps;i++){

        const a1=i/steps*Math.PI*2+params.angle1, a2=i/steps*Math.PI*2+params.angle2;

        const x1=cx+Math.cos(a1)*r, y1=cy+Math.sin(a1)*r;

        const x2=cx+Math.cos(a2)*r, y2=cy+Math.sin(a2)*r;

        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Density",20,150,5,params.density,v=>{params.density=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 67 Lissajous Lace */

inits["lissajous"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={Ax:3, Ay:2, phase:0, speed:0.02, steps:800};

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    ctx.beginPath();

    params.phase+=params.speed;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.3;

    for(let i=0;i<=params.steps;i++){

      const t=i/params.steps*Math.PI*2;

      const x=cx+Math.cos(params.Ax*t+params.phase)*scale;

      const y=cy+Math.sin(params.Ay*t)*scale;

      i?ctx.lineTo(x,y):ctx.moveTo(x,y);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Ax",1,8,1,params.Ax,v=>{params.Ax=v});

  slider(id,"Ay",1,8,1,params.Ay,v=>{params.Ay=v});

  slider(id,"Speed",0,0.1,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 68 Superellipse Frames */

inits["superellipse"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={n:2.5, a:1, b:1, count:8, rotation:0, speed:0.01};

  function superellipse(phi,n,a,b){

    const cos=Math.cos(phi), sin=Math.sin(phi);

    const r=Math.pow(Math.pow(Math.abs(cos/a),n)+Math.pow(Math.abs(sin/b),n),-1/n);

    return [r*cos, r*sin];

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    params.rotation+=params.speed;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.35;

    for(let layer=0;layer<params.count;layer++){

      const s=scale*(1-layer*0.12), hue=(layer*30+params.rotation*50)%360;

      ctx.strokeStyle=`hsl(${hue},80%,60%)`; ctx.lineWidth=2;

      ctx.beginPath();

      const steps=200;

      for(let i=0;i<=steps;i++){

        const phi=i/steps*Math.PI*2+params.rotation;

        const [x,y]=superellipse(phi,params.n,params.a,params.b);

        const px=cx+x*s, py=cy+y*s;

        i?ctx.lineTo(px,py):ctx.moveTo(px,py);

      }

      ctx.closePath(); ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Exponent n",0.5,5,0.1,params.n,v=>{params.n=v});

  slider(id,"Count",3,15,1,params.count,v=>{params.count=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 99 Modulus Bands */

inits["mod-bands"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={mod:8, angle:0.3, speed:0.01};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    params.angle+=params.speed;

    const cx=c.width/2, cy=c.height/2;

    ctx.strokeStyle='rgba(86,194,255,0.7)'; ctx.lineWidth=1;

    for(let y=0;y<c.height;y+=2){

      for(let x=0;x<c.width;x+=2){

        const dx=x-cx, dy=y-cy;

        const dist=Math.hypot(dx,dy);

        const angle=Math.atan2(dy,dx)+params.angle;

        const band=Math.floor((dist*0.1+angle*params.mod)%params.mod);

        if(band%2===0){

          ctx.fillStyle=`hsla(${(band*45)%360},70%,60%,0.6)`;

          ctx.fillRect(x-1,y-1,3,3);

        }

      }

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Mod k",2,20,1,params.mod,v=>{params.mod=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 104 Polar Roses */

inits["polar-roses"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={k:3, n:5, d:7, thickness:0.02, speed:0.01};

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.15)'; ctx.fillRect(0,0,c.width,c.height);

    params.k+=params.speed*0.1;

    const cx=c.width/2, cy=c.height/2, scale=Math.min(c.width,c.height)*0.4;

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=params.thickness*scale;

    ctx.beginPath();

    const steps=800;

    for(let i=0;i<=steps;i++){

      const theta=i/steps*Math.PI*2*params.d;

      const r=Math.cos(params.k*theta/params.n)*scale;

      const x=cx+r*Math.cos(theta), y=cy+r*Math.sin(theta);

      i?ctx.lineTo(x,y):ctx.moveTo(x,y);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"k",1,10,0.5,params.k,v=>{params.k=v});

  slider(id,"n",1,10,1,params.n,v=>{params.n=v});

  slider(id,"d",1,10,1,params.d,v=>{params.d=v});

  slider(id,"Thickness",0.005,0.05,0.001,params.thickness,v=>{params.thickness=v});

  setCode(id, draw.toString());

};

/* 105 Hypnotic Conics */

inits["conics"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={eccentricity:0.7, count:12, phase:0, speed:0.01};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    params.phase+=params.speed;

    const cx=c.width/2, cy=c.height/2, a=Math.min(c.width,c.height)*0.3;

    for(let i=0;i<params.count;i++){

      const phi=i/params.count*Math.PI*2+params.phase;

      const b=a*Math.sqrt(1-params.eccentricity*params.eccentricity);

      const hue=(i*30)%360;

      ctx.strokeStyle=`hsl(${hue},80%,60%)`; ctx.lineWidth=2;

      ctx.beginPath();

      const steps=200;

      for(let j=0;j<=steps;j++){

        const t=j/steps*Math.PI*2;

        const x=cx+Math.cos(phi)*a*Math.cos(t)-Math.sin(phi)*b*Math.sin(t);

        const y=cy+Math.sin(phi)*a*Math.cos(t)+Math.cos(phi)*b*Math.sin(t);

        j?ctx.lineTo(x,y):ctx.moveTo(x,y);

      }

      ctx.closePath(); ctx.stroke();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Eccentricity",0.1,0.95,0.05,params.eccentricity,v=>{params.eccentricity=v});

  slider(id,"Count",3,24,1,params.count,v=>{params.count=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 89 Spirograph Engines */

inits["spirograph"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={R:120, r:40, d:60, speed:0.02};

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    params.speed+=0;

    const cx=c.width/2, cy=c.height/2;

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    ctx.beginPath();

    const steps=1000;

    for(let i=0;i<=steps;i++){

      const t=i/steps*Math.PI*2*10;

      const x=cx+(params.R-params.r)*Math.cos(t)+params.d*Math.cos((params.R-params.r)/params.r*t);

      const y=cy+(params.R-params.r)*Math.sin(t)-params.d*Math.sin((params.R-params.r)/params.r*t);

      i?ctx.lineTo(x,y):ctx.moveTo(x,y);

    }

    ctx.stroke();

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"R",50,200,5,params.R,v=>{params.R=v});

  slider(id,"r",10,100,5,params.r,v=>{params.r=v});

  slider(id,"d",10,100,5,params.d,v=>{params.d=v});

  setCode(id, draw.toString());

};

/* 121 Radial Gradient Weave */

inits["radial-weave"]=({id})=>{

  const div=document.createElement('div'); div.style.width='100%'; div.style.height='60vh';

  const params={stops:8, phase:0, speed:0.01};

  function update(){

    const stops=[];

    for(let i=0;i<params.stops;i++){

      const offset=i/params.stops*100;

      const hue=(i*360/params.stops+params.phase*100)%360;

      stops.push(`hsl(${hue},80%,50%) ${offset}%`);

      stops.push(`hsl(${hue},80%,30%) ${offset+50/params.stops}%`);

    }

    div.style.background=`radial-gradient(circle, ${stops.join(', ')})`;

    params.phase+=params.speed;

    requestAnimationFrame(update);

  }

  update();

  appendStage(id,div);

  slider(id,"Stops",4,16,1,params.stops,v=>{params.stops=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, update.toString());

};

/* 62 Perlin Smoke Sheets */

inits["perlin-smoke"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={freq:0.02, octaves:3, contrast:1.2, speed:0.005, time:0};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n=fbm(x*params.freq, y*params.freq+params.time, params.octaves, 2, 0.5);

        const v=Math.pow(n, params.contrast)*255;

        const i=(y*c.width+x)*4;

        d[i]=v*0.8; d[i+1]=v*0.9; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Frequency",0.005,0.05,0.001,params.freq,v=>{params.freq=v});

  slider(id,"Octaves",1,6,1,params.octaves,v=>{params.octaves=v});

  slider(id,"Contrast",0.5,2,0.1,params.contrast,v=>{params.contrast=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 87 Topo Contour Lines */

inits["contours"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={freq:0.03, levels:12, lineWidth:1.5};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const heights=[];

    for(let y=0;y<c.height;y+=2){

      heights[y]=[];

      for(let x=0;x<c.width;x+=2){

        heights[y][x]=fbm(x*params.freq, y*params.freq, 4, 2, 0.5);

      }

    }

    ctx.strokeStyle='rgba(86,194,255,0.6)'; ctx.lineWidth=params.lineWidth;

    for(let level=0;level<=params.levels;level++){

      const threshold=level/params.levels;

      for(let y=0;y<c.height-2;y+=2){

        for(let x=0;x<c.width-2;x+=2){

          const h=heights[y][x], hx=heights[y][x+2]||h, hy=heights[y+2]?heights[y+2][x]:h;

          if((h<threshold && (hx>=threshold||hy>=threshold)) || (h>=threshold && (hx<threshold||hy<threshold))){

            ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+2,y); ctx.stroke();

          }

        }

      }

    }

  }

  draw();

  slider(id,"Frequency",0.01,0.1,0.005,params.freq,v=>{params.freq=v; draw();});

  slider(id,"Levels",4,24,1,params.levels,v=>{params.levels=v; draw();});

  setCode(id, draw.toString());

};

/* 102 Worley Noise Cells */

inits["worley"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={points:20, metric:2, time:0, speed:0.002};

  const points=Array(params.points).fill().map(()=>({x:Math.random(), y:Math.random(), vx:Math.random()*0.002-0.001, vy:Math.random()*0.002-0.001}));

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const px=x/c.width, py=y/c.height;

        let minDist=Infinity, secondMin=Infinity;

        for(const p of points){

          let dx=px-p.x, dy=py-p.y;

          if(dx>0.5) dx-=1; if(dx<-0.5) dx+=1;

          if(dy>0.5) dy-=1; if(dy<-0.5) dy+=1;

          const dist=Math.pow(Math.pow(Math.abs(dx),params.metric)+Math.pow(Math.abs(dy),params.metric),1/params.metric);

          if(dist<minDist){ secondMin=minDist; minDist=dist; } else if(dist<secondMin){ secondMin=dist; }

        }

        const v=Math.min(255, (secondMin-minDist)*800);

        const i=(y*c.width+x)*4;

        d[i]=v*0.6; d[i+1]=v*0.8; d[i+2]=v; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const p of points){

      p.x+=p.vx; p.y+=p.vy;

      if(p.x<0||p.x>1){p.vx*=-1; p.x=Math.max(0,Math.min(1,p.x));}

      if(p.y<0||p.y>1){p.vy*=-1; p.y=Math.max(0,Math.min(1,p.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Points",5,50,1,params.points,v=>{params.points=v; points.length=0; for(let i=0;i<v;i++) points.push({x:Math.random(), y:Math.random(), vx:Math.random()*0.002-0.001, vy:Math.random()*0.002-0.001});});

  slider(id,"Metric",1,4,0.5,params.metric,v=>{params.metric=v});

  setCode(id, draw.toString());

};

/* 116 fBm Sky */

inits["fbm-sky"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={octaves:4, lacunarity:2, gain:0.5, time:0, speed:0.003};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n=fbm(x*0.01, y*0.01+params.time, params.octaves, params.lacunarity, params.gain);

        const hue=(n*60+200)%360;

        const i=(y*c.width+x)*4;

        const r=Math.sin(hue*Math.PI/180)*127+128, g=Math.sin((hue+120)*Math.PI/180)*127+128, b=Math.sin((hue+240)*Math.PI/180)*127+128;

        d[i]=r; d[i+1]=g; d[i+2]=b; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Octaves",2,8,1,params.octaves,v=>{params.octaves=v});

  slider(id,"Lacunarity",1.5,3,0.1,params.lacunarity,v=>{params.lacunarity=v});

  slider(id,"Gain",0.3,0.7,0.05,params.gain,v=>{params.gain=v});

  slider(id,"Speed",0,0.01,0.0005,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 125 Signed Noise Marble */

inits["marble"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={warp:2, freq:0.02, time:0, speed:0.005};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const wx=x+Math.sin(y*params.freq+params.time)*params.warp;

        const wy=y+Math.cos(x*params.freq+params.time)*params.warp;

        const n=fbm(wx*params.freq, wy*params.freq, 4, 2, 0.5);

        const v=Math.sin(n*Math.PI*8)*0.5+0.5;

        const i=(y*c.width+x)*4;

        const col=v*255;

        d[i]=col*0.9; d[i+1]=col*0.95; d[i+2]=col; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Warp",0.5,5,0.1,params.warp,v=>{params.warp=v});

  slider(id,"Frequency",0.005,0.05,0.001,params.freq,v=>{params.freq=v});

  slider(id,"Speed",0,0.02,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 146 Hypershift Gradient Nebula */

inits["nebula"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={octaves:3, speed:0.003, time:0};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const n1=fbm(x*0.01, y*0.01+params.time, params.octaves, 2, 0.5);

        const n2=fbm(x*0.015+params.time*0.5, y*0.015, params.octaves, 2, 0.5);

        const hue=(n1*120+200)%360, sat=n2*50+50, light=n1*30+40;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=sat/100, l=light/100, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Octaves",2,6,1,params.octaves,v=>{params.octaves=v});

  slider(id,"Speed",0,0.01,0.0005,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 92 Newton Fractal z³−1 */

inits["newton"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={maxIters:50, zoom:2, n:3};

  function newton(z){

    const [re,im]=z;

    let zr=re, zi=im;

    for(let i=0;i<params.maxIters;i++){

      const mag2=zr*zr+zi*zi;

      if(mag2<1e-10) return {iter:i, root:0};

      const [znr, zni]=complexPow([zr,zi], params.n);

      const [znr1, zni1]=complexPow([zr,zi], params.n-1);

      const denom=params.n*(znr1*znr1+zni1*zni1);

      if(denom<1e-10) return {iter:i, root:0};

      zr=zr-(znr-1)*znr1/denom+(zni-0)*zni1/denom;

      zi=zi-(zni-0)*znr1/denom-(znr-1)*zni1/denom;

      if(zr*zr+zi*zi>100) return {iter:i, root:Math.floor(Math.atan2(zi,zr)*params.n/Math.PI/2+params.n)%params.n};

    }

    return {iter:params.maxIters, root:Math.floor(Math.atan2(zi,zr)*params.n/Math.PI/2+params.n)%params.n};

  }

  function draw(){

    const img=ctx.createImageData(c.width,c.height), d=img.data, scale=params.zoom/Math.min(c.width,c.height), cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const re=(x-cx)*scale, im=(y-cy)*scale;

        const {iter, root}=newton([re,im]);

        const hue=(root*360/params.n+iter*5)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.8, l=0.3+iter/params.maxIters*0.4, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

  }

  draw();

  slider(id,"Max Iters",10,100,5,params.maxIters,v=>{params.maxIters=v; draw();});

  slider(id,"Zoom",0.5,5,0.1,params.zoom,v=>{params.zoom=v; draw();});

  slider(id,"Power n",2,6,1,params.n,v=>{params.n=v; draw();});

  setCode(id, draw.toString());

};

/* 93 Barnsley Fern */

inits["fern"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={iterations:50000, blur:true};

  const transforms=[

    {p:0.01, a:0, b:0, c:0, d:0.16, e:0, f:0},

    {p:0.85, a:0.85, b:0.04, c:-0.04, d:0.85, e:0, f:1.6},

    {p:0.07, a:0.2, b:-0.26, c:0.23, d:0.22, e:0, f:1.6},

    {p:0.07, a:-0.15, b:0.28, c:0.26, d:0.24, e:0, f:0.44}

  ];

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    let x=0, y=0;

    for(let i=0;i<params.iterations;i++){

      const r=Math.random();

      let sum=0, t=transforms[0];

      for(const tr of transforms){

        sum+=tr.p;

        if(r<sum){ t=tr; break; }

      }

      const nx=t.a*x+t.b*y+t.e;

      const ny=t.c*x+t.d*y+t.f;

      x=nx; y=ny;

      const px=Math.floor((x+2.5)/5*c.width);

      const py=Math.floor((1-y/10)*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        const idx=(py*c.width+px)*4;

        d[idx]=Math.min(255, d[idx]+8);

        d[idx+1]=Math.min(255, d[idx+1]+12);

        d[idx+2]=Math.min(255, d[idx+2]+4);

        d[idx+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

  }

  draw();

  slider(id,"Iterations",10000,100000,5000,params.iterations,v=>{params.iterations=v; draw();});

  setCode(id, draw.toString());

};

/* 94 Koch Snowflake */

inits["koch"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:4};

  function kochLine(x1,y1,x2,y2,depth){

    if(depth===0){

      ctx.lineTo(x2,y2);

      return;

    }

    const dx=x2-x1, dy=y2-y1;

    const x3=x1+dx/3, y3=y1+dy/3;

    const x4=x2-dx/3, y4=y2-dy/3;

    const mx=(x1+x2)/2, my=(y1+y2)/2;

    const len=Math.hypot(dx,dy)/3;

    const angle=Math.atan2(dy,dx);

    const x5=mx+Math.cos(angle+Math.PI/3)*len;

    const y5=my+Math.sin(angle+Math.PI/3)*len;

    kochLine(x1,y1,x3,y3,depth-1);

    kochLine(x3,y3,x5,y5,depth-1);

    kochLine(x5,y5,x4,y4,depth-1);

    kochLine(x4,y4,x2,y2,depth-1);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.35;

    const x1=cx, y1=cy-size;

    const x2=cx+size*Math.cos(Math.PI*2/3), y2=cy+size*Math.sin(Math.PI*2/3);

    const x3=cx+size*Math.cos(-Math.PI*2/3), y3=cy+size*Math.sin(-Math.PI*2/3);

    ctx.beginPath();

    ctx.moveTo(x1,y1);

    kochLine(x1,y1,x2,y2,params.depth);

    kochLine(x2,y2,x3,y3,params.depth);

    kochLine(x3,y3,x1,y1,params.depth);

    ctx.closePath();

    ctx.stroke();

  }

  draw();

  slider(id,"Depth",0,6,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 95 Dragon Curve Ribbon */

inits["dragon"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:12, thickness:2};

  function dragon(x1,y1,x2,y2,depth,turn){

    if(depth===0){

      ctx.beginPath();

      ctx.moveTo(x1,y1);

      ctx.lineTo(x2,y2);

      ctx.stroke();

      return;

    }

    const dx=x2-x1, dy=y2-y1;

    const mx=(x1+x2)/2, my=(y1+y2)/2;

    const perpx=-dy, perpy=dx;

    const len=Math.hypot(dx,dy);

    const x3=mx+perpx*0.5*len/Math.hypot(perpx,perpy)*(turn?1:-1);

    const y3=my+perpy*0.5*len/Math.hypot(perpx,perpy)*(turn?1:-1);

    dragon(x1,y1,x3,y3,depth-1,true);

    dragon(x3,y3,x2,y2,depth-1,false);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=params.thickness;

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.4;

    dragon(cx-size,cy, cx+size,cy, params.depth, true);

  }

  draw();

  slider(id,"Depth",5,15,1,params.depth,v=>{params.depth=v; draw();});

  slider(id,"Thickness",1,5,0.5,params.thickness,v=>{params.thickness=v; ctx.lineWidth=v; draw();});

  setCode(id, draw.toString());

};

/* 96 Hilbert Space Fill */

inits["hilbert"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={order:5};

  function hilbert(x,y,xi,yi,xj,yj,n){

    if(n<=0){

      const px=(x+(xi+yi)/2)*c.width;

      const py=(y+(xj+yj)/2)*c.height;

      ctx.lineTo(px,py);

    } else {

      hilbert(x,y,yj/2,yi/2,xj/2,xi/2,n-1);

      hilbert(x+xi/2,y+xj/2,xi/2,yi/2,xj/2,yj/2,n-1);

      hilbert(x+xi/2+yi/2,y+xj/2+yj/2,xi/2,yi/2,xj/2,yj/2,n-1);

      hilbert(x+xi/2+yi,y+xj/2+yj,-yj/2,-yi/2,-xj/2,-xi/2,n-1);

    }

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1.5;

    ctx.beginPath();

    hilbert(0,0,1,0,0,1,params.order);

    ctx.stroke();

  }

  draw();

  slider(id,"Order",2,8,1,params.order,v=>{params.order=v; draw();});

  setCode(id, draw.toString());

};

/* 134 Sierpinski Tri Tiles */

inits["sierpinski"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:5};

  function sierpinski(x1,y1,x2,y2,x3,y3,depth){

    if(depth===0){

      ctx.beginPath();

      ctx.moveTo(x1,y1);

      ctx.lineTo(x2,y2);

      ctx.lineTo(x3,y3);

      ctx.closePath();

      ctx.fill();

      return;

    }

    const mx1=(x1+x2)/2, my1=(y1+y2)/2;

    const mx2=(x2+x3)/2, my2=(y2+y3)/2;

    const mx3=(x3+x1)/2, my3=(y3+y1)/2;

    sierpinski(x1,y1,mx1,my1,mx3,my3,depth-1);

    sierpinski(mx1,my1,x2,y2,mx2,my2,depth-1);

    sierpinski(mx3,my3,mx2,my2,x3,y3,depth-1);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.fillStyle='#56c2ff';

    const cx=c.width/2, cy=c.height/2, size=Math.min(c.width,c.height)*0.4;

    const x1=cx, y1=cy-size;

    const x2=cx-size*Math.cos(Math.PI/6), y2=cy+size*Math.sin(Math.PI/6);

    const x3=cx+size*Math.cos(Math.PI/6), y3=cy+size*Math.sin(Math.PI/6);

    sierpinski(x1,y1,x2,y2,x3,y3,params.depth);

  }

  draw();

  slider(id,"Depth",0,7,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 91 Menger Carpet Cuts */

inits["menger"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:3, cell:Math.min(c.width,c.height)/3};

  function menger(x,y,size,depth){

    if(depth===0){

      ctx.fillRect(x,y,size,size);

      return;

    }

    const s=size/3;

    for(let i=0;i<3;i++){

      for(let j=0;j<3;j++){

        if(i===1&&j===1) continue;

        menger(x+i*s, y+j*s, s, depth-1);

      }

    }

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.fillStyle='#56c2ff';

    const cx=c.width/2, cy=c.height/2, size=params.cell;

    menger(cx-size/2, cy-size/2, size, params.depth);

  }

  draw();

  slider(id,"Depth",0,4,1,params.depth,v=>{params.depth=v; draw();});

  slider(id,"Cell size",50,300,10,params.cell,v=>{params.cell=v; draw();});

  setCode(id, draw.toString());

};

/* 66 Apollonian Gasket */

inits["apollonian"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={depth:5};

  function apollonian(x1,y1,r1, x2,y2,r2, x3,y3,r3, depth){

    if(depth===0) return;

    const k1=1/r1, k2=1/r2, k3=1/r3;

    const s=k1+k2+k3+2*Math.sqrt(k1*k2+k2*k3+k3*k1);

    const k4=s;

    const r4=1/k4;

    const d12=Math.hypot(x2-x1,y2-y1), d13=Math.hypot(x3-x1,y3-y1), d23=Math.hypot(x3-x2,y3-y2);

    const x4=(k1*x1+k2*x2+k3*x3+Math.sqrt(k1*k2*(d12*d12-r1*r1-r2*r2)+k2*k3*(d23*d23-r2*r2-r3*r3)+k3*k1*(d13*d13-r1*r1-r3*r3)))/k4;

    const y4=(k1*y1+k2*y2+k3*y3)/k4;

    ctx.beginPath();

    ctx.arc(x4,y4,r4,0,Math.PI*2);

    ctx.stroke();

    apollonian(x1,y1,r1, x2,y2,r2, x4,y4,r4, depth-1);

    apollonian(x1,y1,r1, x4,y4,r4, x3,y3,r3, depth-1);

    apollonian(x4,y4,r4, x2,y2,r2, x3,y3,r3, depth-1);

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    ctx.strokeStyle='#56c2ff'; ctx.lineWidth=1;

    const cx=c.width/2, cy=c.height/2, r=Math.min(c.width,c.height)*0.3;

    ctx.beginPath();

    ctx.arc(cx,cy,r,0,Math.PI*2);

    ctx.stroke();

    const r1=r*0.5, r2=r*0.3, r3=r*0.2;

    const x1=cx, y1=cy-r+r1;

    const x2=cx-r*0.6, y2=cy+r*0.4;

    const x3=cx+r*0.6, y3=cy+r*0.4;

    apollonian(x1,y1,r1, x2,y2,r2, x3,y3,r3, params.depth);

  }

  draw();

  slider(id,"Depth",1,6,1,params.depth,v=>{params.depth=v; draw();});

  setCode(id, draw.toString());

};

/* 75 Circle Packing Waves */

inits["circle-pack"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={minR:5, maxR:30, pulse:0, speed:0.02};

  const circles=packCircles(c.width, c.height, params.minR, params.maxR, 200);

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    params.pulse+=params.speed;

    for(const circ of circles){

      const pulse=Math.sin(params.pulse+circ.x*0.01)*0.3+1;

      const r=circ.r*pulse;

      const hue=(circ.x/c.width*360+params.pulse*50)%360;

      ctx.fillStyle=`hsla(${hue},80%,60%,0.6)`;

      ctx.beginPath();

      ctx.arc(circ.x,circ.y,r,0,Math.PI*2);

      ctx.fill();

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Speed",0,0.1,0.01,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 147 Voronoi Bloom */

inits["voronoi"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={sites:30, jitter:0.1, time:0, speed:0.002};

  const sites=Array(params.sites).fill().map(()=>({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1}));

  function draw(){

    params.time+=params.speed;

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        let minDist=Infinity, closest=0;

        for(let i=0;i<sites.length;i++){

          const dx=x-sites[i].x, dy=y-sites[i].y, dist=dx*dx+dy*dy;

          if(dist<minDist){ minDist=dist; closest=i; }

        }

        const v=Math.min(255, Math.sqrt(minDist)*2);

        const hue=(closest*360/sites.length)%360;

        const i=(y*c.width+x)*4;

        const h=hue/60, c2=0.6, l=v/255*0.5+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r=0,g=0,b=0;

        if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

        d[i]=(r+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    for(const s of sites){

      s.x+=s.vx; s.y+=s.vy;

      if(s.x<0||s.x>c.width){s.vx*=-1; s.x=Math.max(0,Math.min(c.width,s.x));}

      if(s.y<0||s.y>c.height){s.vy*=-1; s.y=Math.max(0,Math.min(c.height,s.y));}

    }

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Sites",10,60,1,params.sites,v=>{params.sites=v; sites.length=0; for(let i=0;i<v;i++) sites.push({x:Math.random()*c.width, y:Math.random()*c.height, vx:Math.random()*2-1, vy:Math.random()*2-1});});

  setCode(id, draw.toString());

};

/* 100 Phyllotaxis Seeds */

inits["phyllotaxis"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={angle:137.508, spacing:4, count:500, size:3};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2;

    for(let i=0;i<params.count;i++){

      const a=i*params.angle*Math.PI/180;

      const r=Math.sqrt(i)*params.spacing;

      const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;

      const hue=(i*10)%360;

      ctx.fillStyle=`hsl(${hue},80%,60%)`;

      ctx.beginPath();

      ctx.arc(x,y,params.size,0,Math.PI*2);

      ctx.fill();

    }

  }

  draw();

  slider(id,"Angle",100,200,1,params.angle,v=>{params.angle=v; draw();});

  slider(id,"Spacing",2,8,0.5,params.spacing,v=>{params.spacing=v; draw();});

  slider(id,"Count",100,1000,50,params.count,v=>{params.count=v; draw();});

  setCode(id, draw.toString());

};

/* 69 Clifford Attractor Glow */

inits["clifford"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={a:-1.4, b:1.6, c:1.0, d:0.7, points:50000, decay:0.98};

  const density=Array(c.width*c.height).fill(0);

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.05)'; ctx.fillRect(0,0,c.width,c.height);

    let x=0, y=0;

    for(let i=0;i<params.points;i++){

      const nx=Math.sin(params.a*y)+params.c*Math.cos(params.a*x);

      const ny=Math.sin(params.b*x)+params.d*Math.cos(params.b*y);

      x=nx; y=ny;

      const px=Math.floor((x+2)/4*c.width);

      const py=Math.floor((y+2)/4*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        const idx=py*c.width+px;

        density[idx]=Math.min(255, density[idx]+2);

      }

    }

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<density.length;i++){

      density[i]*=params.decay;

      const v=density[i];

      const idx=i*4;

      d[idx]=v*0.6; d[idx+1]=v*0.8; d[idx+2]=v; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"a",-2,2,0.1,params.a,v=>{params.a=v});

  slider(id,"b",-2,2,0.1,params.b,v=>{params.b=v});

  slider(id,"Points",10000,100000,5000,params.points,v=>{params.points=v});

  setCode(id, draw.toString());

};

/* 70 Ikeda Map Mist */

inits["ikeda"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={u:0.918, points:30000, decay:0.995};

  const density=Array(c.width*c.height).fill(0);

  function draw(){

    ctx.fillStyle='rgba(11,15,22,0.1)'; ctx.fillRect(0,0,c.width,c.height);

    let x=0.1, y=0.1;

    for(let i=0;i<params.points;i++){

      const t=0.4-6/(1+x*x+y*y);

      const nx=1+params.u*(x*Math.cos(t)-y*Math.sin(t));

      const ny=params.u*(x*Math.sin(t)+y*Math.cos(t));

      x=nx; y=ny;

      const px=Math.floor((x+2)/4*c.width);

      const py=Math.floor((y+2)/4*c.height);

      if(px>=0&&px<c.width&&py>=0&&py<c.height){

        const idx=py*c.width+px;

        density[idx]=Math.min(255, density[idx]+3);

      }

    }

    const img=ctx.createImageData(c.width,c.height), d=img.data;

    for(let i=0;i<density.length;i++){

      density[i]*=params.decay;

      const v=density[i];

      const idx=i*4;

      const hue=(v*2)%360;

      const h=hue/60, c2=0.7, l=v/255*0.4+0.3, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

      let r=0,g=0,b=0;

      if(h<1){r=c2;g=X}else if(h<2){r=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r=X;b=c2}else{r=c2;b=X}

      d[idx]=(r+m)*255; d[idx+1]=(g+m)*255; d[idx+2]=(b+m)*255; d[idx+3]=255;

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"u",0.5,1.2,0.01,params.u,v=>{params.u=v});

  slider(id,"Points",10000,50000,5000,params.points,v=>{params.points=v});

  setCode(id, draw.toString());

};

/* 84 Wave Interference Flowers */

inits["interference"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={freq1:0.02, freq2:0.025, phase:0, speed:0.01};

  function draw(){

    params.phase+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy);

        const a=Math.atan2(dy,dx);

        const w1=Math.sin(r*params.freq1+params.phase);

        const w2=Math.sin(r*params.freq2+a*3+params.phase*0.7);

        const v=(w1+w2)*0.5+0.5;

        const i=(y*c.width+x)*4;

        const hue=(v*120+200)%360;

        const h=hue/60, c2=0.8, l=v*0.3+0.4, X=c2*(1-Math.abs((h%2)-1)), m=l-c2/2;

        let r2=0,g=0,b=0;

        if(h<1){r2=c2;g=X}else if(h<2){r2=X;g=c2}else if(h<3){g=c2;b=X}else if(h<4){g=X;b=c2}else if(h<5){r2=X;b=c2}else{r2=c2;b=X}

        d[i]=(r2+m)*255; d[i+1]=(g+m)*255; d[i+2]=(b+m)*255; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Freq1",0.01,0.05,0.001,params.freq1,v=>{params.freq1=v});

  slider(id,"Freq2",0.01,0.05,0.001,params.freq2,v=>{params.freq2=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 64 Quasicrystal Starfield */

inits["quasicrystal"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={waves:8, threshold:0.3, time:0, speed:0.01};

  function draw(){

    params.time+=params.speed;

    const img=ctx.createImageData(c.width,c.height), d=img.data, cx=c.width/2, cy=c.height/2;

    for(let y=0;y<c.height;y++){

      for(let x=0;x<c.width;x++){

        const dx=x-cx, dy=y-cy;

        const r=Math.hypot(dx,dy), a=Math.atan2(dy,dx);

        let sum=0;

        for(let i=0;i<params.waves;i++){

          const angle=a+i*Math.PI*2/params.waves;

          sum+=Math.sin(r*0.05*Math.cos(angle)+params.time);

        }

        const v=sum/params.waves;

        const i=(y*c.width+x)*4;

        const col=v>params.threshold?255:0;

        d[i]=col*0.8; d[i+1]=col*0.9; d[i+2]=col; d[i+3]=255;

      }

    }

    ctx.putImageData(img,0,0);

    requestAnimationFrame(draw);

  }

  draw();

  slider(id,"Waves",4,16,1,params.waves,v=>{params.waves=v});

  slider(id,"Threshold",-1,1,0.05,params.threshold,v=>{params.threshold=v});

  slider(id,"Speed",0,0.05,0.001,params.speed,v=>{params.speed=v});

  setCode(id, draw.toString());

};

/* 97 Bitmask Quilt */

inits["bitmask"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={tile:16, pattern:0b10110110};

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    for(let y=0;y<c.height;y+=params.tile){

      for(let x=0;x<c.width;x+=params.tile){

        const tx=Math.floor(x/params.tile), ty=Math.floor(y/params.tile);

        const bit=(tx^ty)&params.pattern;

        if(bit){

          const hue=((tx+ty)*30)%360;

          ctx.fillStyle=`hsl(${hue},80%,60%)`;

          ctx.fillRect(x,y,params.tile,params.tile);

        }

      }

    }

  }

  draw();

  slider(id,"Tile size",8,32,2,params.tile,v=>{params.tile=v; draw();});

  setCode(id, draw.toString());

};

/* 98 Prime Spiral Constellations */

inits["primes"]=({id})=>{

  const {c,ctx}=makeCanvas(id);

  const params={density:2, glow:true};

  function isPrime(n){

    if(n<2) return false;

    for(let i=2;i*i<=n;i++) if(n%i===0) return false;

    return true;

  }

  function draw(){

    ctx.fillStyle='#0b0f16'; ctx.fillRect(0,0,c.width,c.height);

    const cx=c.width/2, cy=c.height/2, maxN=2000;

    for(let n=1;n<maxN;n+=params.density){

      if(isPrime(n)){

        const a=n*0.1;

        const r=Math.sqrt(n)*2;

        const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r;

        if(x>=0&&x<c.width&&y>=0&&y<c.height){

          const hue=(n*10)%360;

          ctx.fillStyle=`hsla(${hue},80%,70%,0.8)`;

          ctx.beginPath();

          ctx.arc(x,y,2,0,Math.PI*2);

          ctx.fill();

          if(params.glow){

            ctx.shadowColor=`hsl(${hue},80%,70%)`;

            ctx.shadowBlur=8;

            ctx.fill();

            ctx.shadowBlur=0;

          }

        }

      }

    }

  }

  draw();

  slider(id,"Density",1,5,1,params.density,v=>{params.density=v; draw();});

  setCode(id, draw.toString());

};

/* ---------- REGISTRY: 100 TOYS ---------- */

/* Batch 1 (49-58 already asked previously, included; extending to 100) */

const specs = [

  // Batch 1

  {id:49, key:"rd-fake", title:"Reaction–Diffusion (Fake)", desc:"Feedback blur + high-pass + threshold → living zebra-coral skins.", notes:"Seeds + blur feedback approximate RD. Tweak seed, blur, threshold, decay."},

  {id:50, key:"soap-film", title:"Soap Film Shimmer", desc:"Multi-conic spectral bubble with highlights.", notes:"Conic gradients + screen-blended highlights mimic interference patterns."},

  {id:51, key:"conformal-grid", title:"Conformal Grid Lens", desc:"SVG lattice warped by f(z)=z+α/z.", notes:"Approximate conformal effect—lines bend near the origin via inverse term."},

  {id:52, key:"iso-cubes", title:"Iso Cubes Field", desc:"Three repeating-linear-gradients interlock.", notes:"Adjust tile size and colors for isometric cube illusions."},

  {id:53, key:"supershape", title:"Supershape Flowers", desc:"Gielis superformula drifting through flora modes.", notes:"m,n1,n2,n3 control lobes and curvature. Hue cycles; scale sets radius."},

  {id:54, key:"domain-coloring", title:"Domain Coloring z^n−1", desc:"Phase→hue, magnitude→bands.", notes:"See zeros and rays. Increase n for richer separatrices."},

  {id:55, key:"rule110", title:"Rule 110 Weave", desc:"Edge-of-chaos cellular automaton.", notes:"Row-by-row evolution. Change rule mask for other automata."},

  {id:56, key:"impossible-triangle", title:"Impossible Triangle", desc:"Clip-path + gradients fake an Escher limb.", notes:"Adjust gradient faces, polygon points, and drop-shadow for depth."},

  {id:57, key:"magnetic-orbs", title:"Magnetic Orbs", desc:"Particles repel cursor, ease back like mercury.", notes:"Tweak count, radius, strength, drag, hue drift."},

  {id:58, key:"chromaburst", title:"Chromaburst Text", desc:"bg-clip:text with conic diffraction and tilt.", notes:"Move pointer to tilt the diffraction focus; tweak zoom and colors."},

  // Batch 2 (59–68)

  {id:59, key:"mask-tunnel", title:"Recursive Mask Tunnel", desc:"XOR radial masks spinning into a void.", notes:"Stacked radial gradients as mask layers; spin via CSS animation."},

  {id:60, key:"poincare", title:"Poincaré Vibes", desc:"Arcs orthogonal to unit circle hint hyperbolic tilings.", notes:"Connect boundary points with orthogonal circle arcs."},

  {id:61, key:"moire-lines", title:"Radial Moiré", desc:"Overlaid line fields bloom interference.", notes:"Two rotating line fields; adjust angle and density."},

  {id:62, key:"perlin-smoke", title:"Perlin Smoke Sheets", desc:"Flowing noise wisps.", notes:"2D noise advected; tweak frequency, octaves, contrast."},

  {id:63, key:"curl-rivers", title:"Curl Noise Rivers", desc:"Particles drift on curl field.", notes:"Vector field integration with seeded particles."},

  {id:64, key:"quasicrystal", title:"Quasicrystal Starfield", desc:"Sum of rotated sinusoids.", notes:"Threshold creates aperiodic tilings; tweak angles and waves."},

  {id:65, key:"penrose", title:"Penrose Kite-Dart", desc:"Aperiodic tiling.", notes:"Inflation/deflation steps and matching rules."},

  {id:66, key:"apollonian", title:"Apollonian Gasket", desc:"Packed tangent circles.", notes:"Recursive circle inversions; depth and stroke."},

  {id:67, key:"lissajous", title:"Lissajous Lace", desc:"Parametric harmonics weave knots.", notes:"Adjust Ax/Ay and phase for complex figures."},

  {id:68, key:"superellipse", title:"Superellipse Frames", desc:"Minkowski rounded curves.", notes:"Exponent n controls squareness; rotate for frames."},

  // Batch 3 (69–78)

  {id:69, key:"clifford", title:"Clifford Attractor Glow", desc:"Strange attractor density render.", notes:"Params a,b,c,d; draw many points with decay."},

  {id:70, key:"ikeda", title:"Ikeda Map Mist", desc:"Chaotic map wisps.", notes:"Iterate map, plot density; tweak u and blur."},

  {id:71, key:"lorenz", title:"Lorenz Ribbon", desc:"Butterfly attractor trails.", notes:"Integrate ODE, draw ribbons; σ,ρ,β."},

  {id:72, key:"edge-react", title:"Reaction Rings", desc:"Edge detect feedback rings.", notes:"Kernel + threshold; feedback gain."},

  {id:73, key:"kaleidoscope", title:"Kaleidoscope Shader", desc:"Mirror N-fold tessellation.", notes:"Sector count, reflect offset, zoom."},

  {id:74, key:"hex-flow", title:"Hex Flow Field", desc:"Velocity vectors on hex lattice.", notes:"Noise → vector; sample and drift."},

  {id:75, key:"circle-pack", title:"Circle Packing Waves", desc:"Greedy packing with pulses.", notes:"Pack radius, pulse cadence."},

  {id:76, key:"fourier", title:"Fourier Drawing", desc:"Epicycles reconstruct a path.", notes:"Coeff count, speed, path source."},

  {id:77, key:"phase-carpets", title:"Complex Phase Carpets", desc:"Phase-only coloring.", notes:"Map f(z)→hue on grid."},

  {id:78, key:"parallax", title:"Heightmap Parallax", desc:"Tilted layers for depth.", notes:"Depth scale, lighting angle."},

  // Batch 4 (79–88)

  {id:79, key:"conic-caustics", title:"Conic Caustics", desc:"Simulated light caustics.", notes:"Conic stops and blend."},

  {id:80, key:"turing", title:"Turing Stripe Garden", desc:"Gray–Scott RD.", notes:"Feed/kill, diffusion ratio."},

  {id:81, key:"hyper-grid", title:"Hyperbolic Grid Warp", desc:"Curved grid lines.", notes:"Curvature k, stroke."},

  {id:82, key:"sdf-play", title:"SDF Shape Playground", desc:"Smooth unions of shapes.", notes:"Blend radius, thresholds."},

  {id:83, key:"raymarch-2d", title:"Raymarch Glow Orbs", desc:"Soft min blending.", notes:"Orb count, falloff, blend."},

  {id:84, key:"interference", title:"Wave Interference Flowers", desc:"Radial wave sums.", notes:"Frequency pairs, phase."},

  {id:85, key:"strange-map", title:"Strange Map Scroll", desc:"Iterated complex maps.", notes:"Function, iterations."},

  {id:86, key:"trefoil", title:"Trefoil Tube", desc:"3D-like curve projection.", notes:"Tube radius, param speed."},

  {id:87, key:"contours", title:"Topo Contour Lines", desc:"Heightmap contours.", notes:"Noise freq, levels."},

  {id:88, key:"diffraction-text", title:"Diffraction Text Grids", desc:"Text + rotating grids.", notes:"Grid angle, cell size."},

  // Batch 5 (89–98)

  {id:89, key:"spirograph", title:"Spirograph Engines", desc:"Hypotrochoids/epitrochoids.", notes:"R,r, phase, pen offset."},

  {id:90, key:"bedforms", title:"Butterfly Field Dunes", desc:"Vector field ripples.", notes:"Directional bias, steps."},

  {id:91, key:"menger", title:"Menger Carpet Cuts", desc:"Recursive holes.", notes:"Depth, cell size."},

  {id:92, key:"newton", title:"Newton Fractal z³−1", desc:"Basins of attraction.", notes:"Max iters, zoom."},

  {id:93, key:"fern", title:"Barnsley Fern", desc:"IFS rendering.", notes:"Iter count, color, blur."},

  {id:94, key:"koch", title:"Koch Snowflake", desc:"Recursive edge growth.", notes:"Depth, stroke."},

  {id:95, key:"dragon", title:"Dragon Curve Ribbon", desc:"Self-similar folds.", notes:"Depth, thickness."},

  {id:96, key:"hilbert", title:"Hilbert Space Fill", desc:"Space-filling curve.", notes:"Order, palette."},

  {id:97, key:"bitmask", title:"Bitmask Quilt", desc:"Cellular bitwise textures.", notes:"Bit ops, tile size."},

  {id:98, key:"primes", title:"Prime Spiral Constellations", desc:"Primes on spirals.", notes:"Layout, density, glow."},

  // Batch 6 (99–108)

  {id:99, key:"mod-bands", title:"Modulus Bands", desc:"Striped modulus patterns.", notes:"Mod k, angle."},

  {id:100, key:"phyllotaxis", title:"Phyllotaxis Seeds", desc:"Sunflower spirals.", notes:"Angle, spacing, color."},

  {id:101, key:"super-terrain", title:"Superformula Terrain", desc:"Radial height field.", notes:"m,n fields, height."},

  {id:102, key:"worley", title:"Worley Noise Cells", desc:"Cellular noise textures.", notes:"Points, metric."},

  {id:103, key:"metaballs", title:"Metaballs Pool", desc:"Soft merging blobs.", notes:"Count, iso threshold."},

  {id:104, key:"polar-roses", title:"Polar Roses", desc:"r=cos(kθ) petals.", notes:"k, n/d, thickness."},

  {id:105, key:"conics", title:"Hypnotic Conics", desc:"Ellipses/hyperbolas.", notes:"Eccentricity, phase."},

  {id:106, key:"harmonics", title:"Spherical Harmonics Heat", desc:"2D projection of Yₗᵐ.", notes:"l,m, palette."},

  {id:107, key:"moire-checker", title:"Moiré Checker Warps", desc:"Offset grids produce beats.", notes:"Angles, scale, phase."},

  {id:108, key:"log-spirals", title:"Complex Log Spirals", desc:"Families of growth spirals.", notes:"Rate, rotation."},

  // Batch 7 (109–118)

  {id:109, key:"torus-knot", title:"Torus Knot Map", desc:"Parametric p,q knot.", notes:"Thickness, speed."},

  {id:110, key:"wavelet", title:"Wavelet Tapestry", desc:"Localized wave sum.", notes:"Basis count, scale."},

  {id:111, key:"voronoi-pulse", title:"Pulsing Voronoi Rings", desc:"Annular cells pulsing.", notes:"Ring count, rate."},

  {id:112, key:"svg-mesh", title:"Gradient Mesh Beasts", desc:"SVG mesh blend.", notes:"Mesh density, colors."},

  {id:113, key:"escher-tiles", title:"Escherized Tessellations", desc:"Morph tiles onto lattice.", notes:"Morph, orientation."},

  {id:114, key:"sinewarp-text", title:"Sinewarp Text", desc:"BG-position wave warp.", notes:"Amplitude, freq, speed."},

  {id:115, key:"bezier-foam", title:"Bezier Foam", desc:"Bubble-like bezier cells.", notes:"Control jitter, tension."},

  {id:116, key:"fbm-sky", title:"fBm Sky", desc:"Layered noise clouds.", notes:"Octaves, lacunarity."},

  {id:117, key:"dla", title:"Diffusion-Limited Aggregation", desc:"Random walker crystals.", notes:"Walkers, stick prob."},

  {id:118, key:"caustic-grid", title:"Sunken Grid Caustics", desc:"Refractive displacement.", notes:"Refraction strength, flow."},

  // Batch 8 (119–128)

  {id:119, key:"eikonal", title:"Eikonal Rays", desc:"Variable medium rays.", notes:"Speed field, ray count."},

  {id:120, key:"anamorph", title:"Anamorphic Stretch", desc:"Transform illusions.", notes:"Perspective, skew."},

  {id:121, key:"radial-weave", title:"Radial Gradient Weave", desc:"Interlaced radials.", notes:"Stops, blend, phase."},

  {id:122, key:"golden-flow", title:"Golden Angle Flow", desc:"Phyllotaxis streamlines.", notes:"Angle drift, density."},

  {id:123, key:"kaleid-voronoi", title:"Kaleid Voronoi Mirror", desc:"Voronoi in mirrored sectors.", notes:"Sector count, sites."},

  {id:124, key:"roots-garden", title:"Complex Roots Garden", desc:"Basins and critical lines.", notes:"Polynomial, zoom."},

  {id:125, key:"marble", title:"Signed Noise Marble", desc:"Turbulence veins.", notes:"Warp strength, freq."},

  {id:126, key:"orbit-rings", title:"Gradient Orbit Rings", desc:"Conic rings in orbit.", notes:"Count, thickness, spin."},

  {id:127, key:"flames", title:"Fractal Flames 2D", desc:"Variations with densities.", notes:"Transforms, gamma."},

  {id:128, key:"amoeba", title:"Amoeba Marchers", desc:"Elastic contour followers.", notes:"March speed, squish."},

  // Batch 9 (129–138)

  {id:129, key:"shadow-text", title:"Shadow March Text", desc:"Moving shadow tunnels.", notes:"Layers, offset curve."},

  {id:130, key:"polar-zipper", title:"Polar SDF Zipper", desc:"Stitched radial shapes.", notes:"Blend radius, spin."},

  {id:131, key:"glyph-drift", title:"Bezier Glyph Drift", desc:"Text outlines drift.", notes:"Noise drift, stroke."},

  {id:132, key:"warp-grids", title:"Complex Warp Grids", desc:"Sample grids through maps.", notes:"f(z) family, density."},

  {id:133, key:"polar-foam", title:"Polar Foam Packing", desc:"Circular foam with fill.", notes:"Layers, size, jitter."},

  {id:134, key:"sierpinski", title:"Sierpinski Tri Tiles", desc:"Recursive tri removal.", notes:"Depth, rule, rotation."},

  {id:135, key:"tangent-trails", title:"Tangent Bundle Trails", desc:"Trails align to field.", notes:"Curvature bias, length."},

  {id:136, key:"arc-weave", title:"Arc Lattice Weave", desc:"Over/under arc weaving.", notes:"Arc families, spacing."},

  {id:137, key:"polar-bricks", title:"Polar Brickwork", desc:"Concentric bricks.", notes:"Ring count, brick size."},

  {id:138, key:"lichtenberg", title:"Gasket Lightning", desc:"Stochastic branching.", notes:"Charge map, glow."},

  // Batch 10 (139–148)

  {id:139, key:"chladni", title:"Chladni Plate Nodes", desc:"Nodal vibration patterns.", notes:"m,n modes, threshold."},

  {id:140, key:"quilt-conics", title:"Quilted Conics", desc:"Patchwork conic tiles.", notes:"Seam width, palette."},

  {id:141, key:"bilateral", title:"Bilateral Symmetry Paint", desc:"Rorschach mirroring.", notes:"Mirror line, decay."},

  {id:142, key:"nbody", title:"Orbital Flow Trails", desc:"N-body-ish trails.", notes:"Masses, drag."},

  {id:143, key:"polar-labyrinth", title:"Polar Sine Labyrinth", desc:"Thresholded polar sine.", notes:"Cell size, amplitude."},

  {id:144, key:"logo-melt", title:"Conformal Logo Melt", desc:"Warp logo via map.", notes:"Strength, frequency."},

  {id:145, key:"halftone", title:"Halftone Warp Portrait", desc:"Live halftone + flow.", notes:"Dot scale, contrast."},

  {id:146, key:"nebula", title:"Hypershift Gradient Nebula", desc:"Layered gradients + noise.", notes:"Octave hues, speed."},

  {id:147, key:"voronoi", title:"Voronoi Bloom", desc:"Relaxed cells mosaic.", notes:"Site count, jitter."},

  {id:148, key:"delaunay", title:"Delaunay Wireframe", desc:"Triangulated mesh jitter.", notes:"Points, thickness."},

];

/* Register all specs */

for(const s of specs) addSpec(s);

/* ---------- SIMPLE PLACEHOLDER INIT FOR MANY KEYS ---------- */

/* For brevity, effects not explicitly implemented by a primitive above get a friendly placeholder panel that describes tweak plans. 

   You can ask me to wire any of these next ones explicitly. */

function placeholderInit(title){

  return ({id})=>{

    const box=document.createElement('div'); box.style.display='grid'; box.style.placeItems='center'; box.style.color='#9fb3cc'; box.style.font='600 16px/1.4 system-ui';

    box.innerHTML=`<div style="padding:1rem; text-align:center">"${title}" ready for wiring. Tap a slider to imagine:<br><small>Ask to activate this with a live primitive now.</small></div>`;

    appendStage(id,box);

    setCode(id, placeholderInit.toString());

  };

}

/* Map keys to init functions */

Object.assign(inits, {

  "rd-fake": inits["rd-fake"],

  "soap-film": inits["soap-film"],

  "conformal-grid": inits["conformal-grid"],

  "iso-cubes": inits["iso-cubes"],

  "supershape": inits["supershape"],

  "domain-coloring": inits["domain-coloring"],

  "rule110": inits["rule110"],

  "impossible-triangle": inits["impossible-triangle"],

  "magnetic-orbs": inits["magnetic-orbs"],

  "chromaburst": inits["chromaburst"],

  "mask-tunnel": inits["mask-tunnel"],

  "poincare": inits["poincare"],

  // Implemented effects:

  "moire-lines": inits["moire-lines"],

  "lissajous": inits["lissajous"],

  "superellipse": inits["superellipse"],

  "mod-bands": inits["mod-bands"],

  "polar-roses": inits["polar-roses"],

  "conics": inits["conics"],

  "spirograph": inits["spirograph"],

  "radial-weave": inits["radial-weave"],

  // More implemented effects:

  "perlin-smoke": inits["perlin-smoke"],

  "contours": inits["contours"],

  "worley": inits["worley"],

  "fbm-sky": inits["fbm-sky"],

  "marble": inits["marble"],

  "nebula": inits["nebula"],

  "newton": inits["newton"],

  "fern": inits["fern"],

  "koch": inits["koch"],

  "dragon": inits["dragon"],

  "hilbert": inits["hilbert"],

  "sierpinski": inits["sierpinski"],

  "menger": inits["menger"],

  "apollonian": inits["apollonian"],

  "circle-pack": inits["circle-pack"],

  "voronoi": inits["voronoi"],

  "phyllotaxis": inits["phyllotaxis"],

  "clifford": inits["clifford"],

  "ikeda": inits["ikeda"],

  "interference": inits["interference"],

  "quasicrystal": inits["quasicrystal"],

  "bitmask": inits["bitmask"],

  "primes": inits["primes"],

  // Placeholders for the rest; request any to be wired live next:

  "curl-rivers": placeholderInit("Curl Noise Rivers"),

  "penrose": placeholderInit("Penrose Kite-Dart"),

  "lorenz": placeholderInit("Lorenz Ribbon"),

  "edge-react": placeholderInit("Reaction Rings"),

  "kaleidoscope": placeholderInit("Kaleidoscope Shader"),

  "hex-flow": placeholderInit("Hex Flow Field"),

  "circle-pack": placeholderInit("Circle Packing Waves"),

  "fourier": placeholderInit("Fourier Drawing"),

  "phase-carpets": placeholderInit("Complex Phase Carpets"),

  "parallax": placeholderInit("Heightmap Parallax"),

  "conic-caustics": placeholderInit("Conic Caustics"),

  "turing": placeholderInit("Turing Stripe Garden"),

  "hyper-grid": placeholderInit("Hyperbolic Grid Warp"),

  "sdf-play": placeholderInit("SDF Shape Playground"),

  "raymarch-2d": placeholderInit("Raymarch Glow Orbs"),

  "interference": placeholderInit("Wave Interference Flowers"),

  "strange-map": placeholderInit("Strange Map Scroll"),

  "trefoil": placeholderInit("Trefoil Tube"),

  "diffraction-text": placeholderInit("Diffraction Text Grids"),

  "bedforms": placeholderInit("Butterfly Field Dunes"),

  "bitmask": placeholderInit("Bitmask Quilt"),

  "primes": placeholderInit("Prime Spiral Constellations"),

  "phyllotaxis": placeholderInit("Phyllotaxis Seeds"),

  "super-terrain": placeholderInit("Superformula Terrain"),

  "worley": placeholderInit("Worley Noise Cells"),

  "metaballs": placeholderInit("Metaballs Pool"),

  "polar-roses": placeholderInit("Polar Roses"),

  "conics": placeholderInit("Hypnotic Conics"),

  "harmonics": placeholderInit("Spherical Harmonics Heat"),

  "moire-checker": placeholderInit("Moiré Checker Warps"),

  "log-spirals": placeholderInit("Complex Log Spirals"),

  "torus-knot": placeholderInit("Torus Knot Map"),

  "wavelet": placeholderInit("Wavelet Tapestry"),

  "voronoi-pulse": placeholderInit("Pulsing Voronoi Rings"),

  "svg-mesh": placeholderInit("Gradient Mesh Beasts"),

  "escher-tiles": placeholderInit("Escherized Tessellations"),

  "sinewarp-text": placeholderInit("Sinewarp Text"),

  "bezier-foam": placeholderInit("Bezier Foam"),

  "fbm-sky": placeholderInit("fBm Sky"),

  "dla": placeholderInit("Diffusion-Limited Aggregation"),

  "caustic-grid": placeholderInit("Sunken Grid Caustics"),

  "eikonal": placeholderInit("Eikonal Rays"),

  "anamorph": placeholderInit("Anamorphic Stretch"),

  "radial-weave": placeholderInit("Radial Gradient Weave"),

  "golden-flow": placeholderInit("Golden Angle Flow"),

  "kaleid-voronoi": placeholderInit("Kaleid Voronoi Mirror"),

  "roots-garden": placeholderInit("Complex Roots Garden"),

  "marble": placeholderInit("Signed Noise Marble"),

  "orbit-rings": placeholderInit("Gradient Orbit Rings"),

  "flames": placeholderInit("Fractal Flames 2D"),

  "amoeba": placeholderInit("Amoeba Marchers"),

  "shadow-text": placeholderInit("Shadow March Text"),

  "polar-zipper": placeholderInit("Polar SDF Zipper"),

  "glyph-drift": placeholderInit("Bezier Glyph Drift"),

  "warp-grids": placeholderInit("Complex Warp Grids"),

  "polar-foam": placeholderInit("Polar Foam Packing"),

  "sierpinski": placeholderInit("Sierpinski Tri Tiles"),

  "tangent-trails": placeholderInit("Tangent Bundle Trails"),

  "arc-weave": placeholderInit("Arc Lattice Weave"),

  "polar-bricks": placeholderInit("Polar Brickwork"),

  "lichtenberg": placeholderInit("Gasket Lightning"),

  "chladni": placeholderInit("Chladni Plate Nodes"),

  "quilt-conics": placeholderInit("Quilted Conics"),

  "bilateral": placeholderInit("Bilateral Symmetry Paint"),

  "nbody": placeholderInit("Orbital Flow Trails"),

  "polar-labyrinth": placeholderInit("Polar Sine Labyrinth"),

  "logo-melt": placeholderInit("Conformal Logo Melt"),

  "halftone": placeholderInit("Halftone Warp Portrait"),

  "nebula": placeholderInit("Hypershift Gradient Nebula"),

  "voronoi": placeholderInit("Voronoi Bloom"),

  "delaunay": placeholderInit("Delaunay Wireframe"),

});

/* Default activate first panel */

activate(49);

</script>
</body>
</html>


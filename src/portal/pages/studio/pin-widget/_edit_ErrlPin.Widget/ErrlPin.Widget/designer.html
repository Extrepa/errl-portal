<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Errl Widget — v2.2 (parser‑safe, clickable, flexible import)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet"/>
<style>
:root{
  --ink:#e5eaf1;
  --line:#ffffff22;
  --rainbow: conic-gradient(from 0deg,#ff004c,#ffa300,#ffee00,#53f900,#00e5ff,#7b5cff,#ff00b1,#ff004c);
}
*{box-sizing:border-box}
html,body{height:100%;width:100%;margin:0}
body{background:transparent;overflow:hidden;color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
.card{width:100%;height:100%;position:relative;max-width:none;max-height:none}
.stage{position:absolute;inset:0 0 52px 0; z-index:0}
svg{width:100%;height:100%;display:block;touch-action:none}

/* Buttons */
#randomBtn{position:absolute; right:10px; top:10px; height:28px; padding:0 10px; border-radius:10px; border:1px solid var(--line); cursor:pointer; overflow:hidden; z-index:1000; background:rgba(15,22,32,.35); backdrop-filter:saturate(110%) blur(2px); display:grid; place-items:center}
#randomBtn .spinFill{position:absolute; inset:2px; border-radius:8px; background:var(--rainbow); animation:spin 3.2s linear infinite; opacity:.6; filter:brightness(.95) contrast(.95); pointer-events:none}
@keyframes spin{to{transform:rotate(1turn)}}
#loadBtn{position:absolute; left:6px; top:6px; height:28px; padding:0 10px; border-radius:10px; border:1px solid var(--line); background:rgba(15,22,32,.35); color:#dbe2ea; cursor:pointer; z-index:1000}
#autoLoadBtn{position:absolute; left:70px; top:6px; height:28px; padding:0 10px; border-radius:10px; border:1px solid var(--line); background:rgba(15,22,32,.35); color:#dbe2ea; cursor:pointer; z-index:1000}
#fileInput{display:none}

/* Context panel */
.ctx{position:absolute; min-width:180px; padding:10px; border-radius:10px; border:1px solid var(--line); background:rgba(15,22,32,.95); color:#dbe2ea; z-index:50; box-shadow:0 8px 24px rgba(0,0,0,.35); display:none}
.ctx label{display:block; font-size:11px; opacity:.9; margin:.25rem 0 .15rem}
.ctx input[type="range"]{width:170px}
.ctx .row{display:flex; gap:8px; align-items:center}
.ctx .row > *{flex:1}
.ctx .btns{display:flex; gap:8px; margin-top:8px}
.ctx button{height:28px; padding:0 10px; border-radius:8px; border:1px solid var(--line); background:rgba(255,255,255,.06); color:#e7ecf5; cursor:pointer}
.ctx .danger{border-color:#ff4d4d44; background:rgba(255,77,77,.08)}
</style>
</head>
<body>
  <div class="card">
    <button id="loadBtn" type="button" title="Load custom SVG">Load</button>
    <button id="autoLoadBtn" type="button" title="Auto-load ERRL SVG">Auto ERRL</button>
    <input id="fileInput" type="file" accept="image/svg+xml,.svg"/>

    <div class="stage" data-stage="1">
      <!-- Parser‑safe default silhouette embedded directly to avoid DOMParser parse errors at boot -->
      <svg id="pinSVG" viewBox="0 0 600 820" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="gitd" x="-40%" y="-40%" width="180%" height="180%">
            <feGaussianBlur stdDeviation="10" result="b"/>
            <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
          </filter>
          <filter id="glitterSparkle" x="-10%" y="-10%" width="120%" height="120%">
            <feTurbulence id="glitNoise" type="fractalNoise" baseFrequency="0.95" numOctaves="2" seed="3" result="noise"/>
            <feColorMatrix id="glitMatrix" in="noise" type="matrix" values="0 0 0 0 0   0 0 0 0 0   0 0 0 0 0   0 0 0 6 -3" result="spark"/>
            <feComponentTransfer in="spark" result="dense"><feFuncA id="glitterSlopeA" type="linear" slope="0.6"/></feComponentTransfer>
            <feComposite in="dense" in2="SourceAlpha" operator="in" result="clipped"/>
            <feBlend in="SourceGraphic" in2="clipped" mode="screen"/>
            <animate attributeName="opacity" values="1;0.7;1" dur="1.2s" repeatCount="indefinite"/>
          </filter>
        </defs>
        <g id="g-body">
          <path data-region="body" d="M65,410 C65,190 240,40 360,60 C510,85 555,210 555,325 C555,510 460,615 345,695 C285,740 210,775 155,740 C110,711 65,630 65,410 Z"/>
        </g>
        <g id="g-face">
          <ellipse data-region="face" cx="320" cy="290" rx="110" ry="95"/>
        </g>
        <g id="g-eyeL"><ellipse data-region="eyeL" cx="285" cy="270" rx="16" ry="28"/></g>
        <g id="g-eyeR"><ellipse data-region="eyeR" cx="355" cy="270" rx="16" ry="28"/></g>
        <g id="g-mouth"><ellipse data-region="mouth" cx="320" cy="330" rx="42" ry="18"/></g>
        <path id="outline" d="M65,410 C65,190 240,40 360,60 C510,85 555,210 555,325 C555,510 460,615 345,695 C285,740 210,775 155,740 C110,711 65,630 65,410 Z" fill="none" stroke="#0a0a0c" stroke-width="3" stroke-linejoin="round" stroke-linecap="round"/>
      </svg>
    </div>

    <!-- Context panel -->
    <div id="ctx" class="ctx">
      <div style="font-size:12px;opacity:.8" id="ctxTitle">Region</div>
      <label>Enamel color</label>
      <div class="row"><input id="ctxColor" type="color" value="#00e5ff"/></div>
      <label>Finish</label>
      <div class="row"><select id="ctxFinish">
        <option value="solid">Solid</option>
        <option value="glitter">Glitter</option>
        <option value="glow">Glow</option>
        <option value="none">None</option>
      </select></div>
      <label>Wire thickness</label>
      <input id="ctxWire" type="range" min="0.5" max="6" step="0.5" value="2"/>
      <label>Outline thickness</label>
      <input id="ctxOutline" type="range" min="1" max="8" step="0.5" value="3"/>
      <div class="btns">
        <button id="ctxApply" type="button">Apply</button>
        <button id="ctxCancel" type="button" class="danger">Close</button>
      </div>
    </div>

    <button id="randomBtn" type="button" aria-label="Randomize"><span class="spinFill" aria-hidden="true"></span></button>
  </div>

<script>
'use strict';
(function(){
  // ===== tiny helpers =====
  var $=function(s){return document.querySelector(s)};
  var $$=function(s){return Array.prototype.slice.call(document.querySelectorAll(s))};
  function parseSVGText(txt){return(new DOMParser()).parseFromString(txt,'image/svg+xml');}

  // ===== elements (late-bound) =====
  var svg,gB,gF,gL,gR,gM,outline,loadBtn,fileInput,ctx,ctxColor,ctxFinish,ctxWire,ctxOutline,randomBtn;
// importer compatibility vars
var regionGs = {}, regionElems = {}; 

  // ===== state =====
  var regions=['body','face','eyeL','eyeR','mouth'];
  var idToRegion={'#g-body':'body','#g-face':'face','#g-eyeL':'eyeL','#g-eyeR':'eyeR','#g-mouth':'mouth'};
  var state={
    plating:'#0a0a0c',
    outlineW:3,
    wireW:{body:2,face:2,eyeL:2,eyeR:2,mouth:2},
    fill:{
      body:{finish:'solid',color:'#00e5ff'},
      face:{finish:'none', color:'#ffffff'},
      eyeL:{finish:'solid',color:'#0a0a0a'},
      eyeR:{finish:'solid',color:'#0a0a0a'},
      mouth:{finish:'solid',color:'#0a0a0a'}
    }
  };
  // curated bright palette
  var palette=['#ffffff','#00e5ff','#22d3ee','#3b82f6','#60a5fa','#a78bfa','#8b5cf6','#f472b6','#ec4899','#fb7185','#f87171','#ef4444','#f97316','#f59e0b','#fbbf24','#fde047','#c3ff00','#53f900','#34d399','#4ade80','#86efac','#bbf7d0','#fef9c3','#fde68a','#facc15','#fda4af','#fbcfe8','#e0e7ff','#c7d2fe'];
  var metals=['#0a0a0c','#4b5563','#cbd5e1','#d6b356','#d07c6c','#6e43ff'];
  var finishes=['solid','glitter','glow']; // random never uses 'none'

  // ===== geometry + paint =====
  function fitToOutline(){ try{ var b=outline.getBBox(); if(!b||!isFinite(b.width)||b.width===0) return; var pad=Math.max(b.width,b.height)*0.08; svg.setAttribute('viewBox',[b.x-pad,b.y-pad,b.width+2*pad,b.height+2*pad].join(' ')); }catch(e){}}
  function regionNodes(r){ var map={body:'#g-body *',face:'#g-face *',eyeL:'#g-eyeL *',eyeR:'#g-eyeR *',mouth:'#g-mouth *'}; return svg?Array.prototype.slice.call(svg.querySelectorAll(map[r])):[]; }
  function applyPlating(){ if(!outline) return; outline.setAttribute('stroke',state.plating); ['#g-face *','#g-eyeL *','#g-eyeR *','#g-mouth *'].forEach(function(sel){ $$(sel).forEach(function(n){ n.setAttribute('stroke',state.plating); }); }); }
  function applyRegion(r){ var nodes=regionNodes(r); if(nodes.length===0) return; var f=state.fill[r]; nodes.forEach(function(n){ n.setAttribute('stroke-width', state.wireW[r]||2); n.setAttribute('stroke',state.plating); n.setAttribute('pointer-events','all'); if(f.finish==='none'){ n.setAttribute('fill','none'); n.removeAttribute('filter'); } else if(f.finish==='solid'){ n.setAttribute('fill',f.color); n.removeAttribute('filter'); } else if(f.finish==='glow'){ n.setAttribute('fill',f.color); n.setAttribute('filter','url(#gitd)'); } else if(f.finish==='glitter'){ n.setAttribute('fill',f.color); n.setAttribute('filter','url(#glitterSparkle)'); } }); }
  function applyAll(){ ['body','face','eyeL','eyeR','mouth'].forEach(applyRegion); }

  // ===== randomizers =====
  function rand(arr){return arr[Math.floor(Math.random()*arr.length)]}
  function randColor(){return rand(palette)}
  function randomizeAll(){ state.plating=rand(metals); applyPlating(); var eyeMouthColor=randColor(); ['body','face','eyeL','eyeR','mouth'].forEach(function(r){ state.fill[r].finish=rand(finishes); state.fill[r].color=(r==='eyeL'||r==='eyeR'||r==='mouth')?eyeMouthColor:randColor(); applyRegion(r); }); }
  function randomizeRegion(r){ if(['body','face','eyeL','eyeR','mouth'].indexOf(r)===-1) return; state.fill[r].finish=rand(finishes); state.fill[r].color=randColor(); applyRegion(r); }

  // ===== Importer (user-specified signature) =====
// shims for the user's snippet
var regionGs = {};            // filled in bind()
var regionElems = {};         // stores target elements per region
function fitView(){ fitToOutline(); } // alias to our viewbox fitter

// importer
function importFromDoc(doc){
  const q = sel => doc.querySelector(sel);
  const outlinePath = q('[data-region="outline"], #outline, #outline-plating, svg>path');
  if(outlinePath && outlinePath.getAttribute('d')) outline.setAttribute('d', outlinePath.getAttribute('d'));
  const map = {
    body:  q('[data-region="body"], #body, #fill-body, path#body-fill'),
    face:  q('[data-region="face"], #face, #fill-face, path#face-fill'),
    eyeL:  q('[data-region="eyeL"], #eyeL, #left-eye, #fill-eyeL, path#eyeL-fill'),
    eyeR:  q('[data-region="eyeR"], #eyeR, #right-eye, #fill-eyeR, path#eyeR-fill'),
    mouth: q('[data-region="mouth"], #mouth, #fill-mouth, path#mouth-fill')
  };
  Object.keys(map).forEach(k=>{
    const g=regionGs[k]; if(!g) return; g.innerHTML='';
    const src=map[k]; if(!src){ regionElems[k]=null; return; }
    const clone=src.cloneNode(true); clone.removeAttribute('id'); g.appendChild(clone);
    const target=clone.querySelector('path,ellipse,circle,polygon,rect')||clone;
    regionElems[k]=target;
    (clone.querySelectorAll('*').length?clone.querySelectorAll('*'):[clone]).forEach(el=>{
      el.setAttribute('stroke', state.plating);
      // map user's state.wires to our state.wireW
      el.setAttribute('stroke-width', (state.wireW && state.wireW[k]) ? state.wireW[k] : 6);
      el.setAttribute('stroke-linejoin','round');
      el.setAttribute('stroke-linecap','round');
    });
  });
  applyAll(); fitView();
}

  // ===== bind after DOM ready =====
  function bind(){
    // cache
    svg=$('#pinSVG'); gB=$('#g-body'); gF=$('#g-face'); gL=$('#g-eyeL'); gR=$('#g-eyeR'); gM=$('#g-mouth'); outline=$('#outline');
    loadBtn=$('#loadBtn'); fileInput=$('#fileInput'); randomBtn=$('#randomBtn');
    ctx=$('#ctx'); ctxColor=$('#ctxColor'); ctxFinish=$('#ctxFinish'); ctxWire=$('#ctxWire'); ctxOutline=$('#ctxOutline');
    if(!svg||!outline||!loadBtn||!fileInput||!randomBtn){ console.error('Init failed: missing nodes'); return; }

    // fill importer maps
    regionGs = { body:gB, face:gF, eyeL:gL, eyeR:gR, mouth:gM };
    // user snippet expects state.wires; alias to our wireW
    state.wires = state.wireW;

    // init paint
    applyPlating(); applyAll(); fitToOutline();

    // buttons
    loadBtn.addEventListener('click', function(){ fileInput.click(); });
    fileInput.addEventListener('change', function(e){ var f=e.target.files[0]; if(!f) return; var rd=new FileReader(); rd.onload=function(){ try{ var doc=parseSVGText(rd.result); importFromDoc(doc); }catch(err){ console.error('SVG load error',err); } }; rd.readAsText(f); });
    // Auto-load built-in ERRL SVGs (tries local errl_fixed.svg first)
    (function(){ var btn=document.getElementById('autoLoadBtn'); if(!btn) return; btn.addEventListener('click', async function(){
      try{
        btn.disabled=true; var urls=['errl_fixed.svg','errl-painted-2.svg','errl-painted.svg']; var ok=false;
        for(var i=0;i<urls.length && !ok;i++){
          try{
            var res = await fetch(urls[i], { cache:'no-cache' });
            if(res && res.ok){ var txt = await res.text(); var doc = parseSVGText(txt); importFromDoc(doc); ok=true; }
          }catch(e){ /* try next */ }
        }
        btn.textContent = ok ? 'Loaded' : 'Not found';
        setTimeout(function(){ btn.textContent='Auto ERRL'; btn.disabled=false; }, 1400);
      }catch(e){ console.warn('Auto-load failed', e); btn.disabled=false; }
    });
    // auto-run on startup to replace placeholder silhouette
    setTimeout(function(){ try{ btn.click(); }catch(_){} }, 0);
    })();
    randomBtn.addEventListener('click', function(){ randomizeAll(); this.style.transform='scale(0.96)'; setTimeout(()=>this.style.transform='',120); });

    // per‑region interactions
    svg.addEventListener('dblclick', function(e){ var el=e.target.closest('#g-body, #g-face, #g-eyeL, #g-eyeR, #g-mouth'); if(!el) return; randomizeRegion(idToRegion['#'+el.id]); });
    svg.addEventListener('contextmenu', function(e){ var el=e.target.closest('#g-body, #g-face, #g-eyeL, #g-eyeR, #g-mouth'); if(!el) return; e.preventDefault(); var region=idToRegion['#'+el.id]; var rect=document.body.getBoundingClientRect(); var panel=ctx; panel.style.display='block'; panel.style.left=(e.clientX-rect.left+4)+'px'; panel.style.top=(e.clientY-rect.top+4)+'px'; var f=state.fill[region]||{finish:'none',color:'#ffffff'}; ctxColor.value=f.color||'#ffffff'; ctxFinish.value=f.finish||'none'; ctxWire.value=(state.wireW[region]||2); ctxOutline.value=state.outlineW; $('#ctxTitle').textContent=region.toUpperCase(); panel.dataset.region=region; });
    $('#ctxApply').addEventListener('click', function(){ var r=ctx.dataset.region; if(!r) return; state.fill[r].color=ctxColor.value; state.fill[r].finish=ctxFinish.value; state.wireW[r]=parseFloat(ctxWire.value); state.outlineW=parseFloat(ctxOutline.value); outline.setAttribute('stroke-width', state.outlineW); applyRegion(r); ctx.style.display='none'; delete ctx.dataset.region; });
    $('#ctxCancel').addEventListener('click', function(){ ctx.style.display='none'; delete ctx.dataset.region; });
    document.addEventListener('click', function(e){ if(!ctx.contains(e.target) && e.target!==ctx) { ctx.style.display='none'; delete ctx.dataset.region; } });
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', bind); else bind();

  // ===== basic self‑tests (console) =====
  (function tests(){ try{ randomizeAll(); var ok1=['body','face','eyeL','eyeR','mouth'].every(r=>state.fill[r].finish!=='none'); if(!ok1) console.warn('Test fail: finish none after randomizeAll'); randomizeRegion('face'); if(state.fill.face.finish==='none') console.warn('Test fail: face none after randomizeRegion'); }catch(e){ console.warn('Self-tests error',e); } })();
})();
</script>
</body>
</html>

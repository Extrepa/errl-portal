# Safari Layers Audit — Results Log

> Created: 2025-11-09  
> Context: `perf/layer-audit-portal-landing-2025-11-09`

Use this file to capture every measurement pass (Safari layers panel, graphics memory, compositing reasons, FPS notes, screenshots placed in `docs/perf/2025-11-09-safari-layers/`).

## Baseline Template

- Date / build:
- Safari version / hardware:
- Layer count:
- Graphics memory:
- Compositing hot spots:
- Notes & screenshots:

---

Append new sections as work progresses; keep chronological order.

## Baseline — 2025-11-09

- Date / build: 2025-11-09 / `de9819b`
- Safari version / hardware: Safari (DevTools audit export `Audit.audit` on local Mac — version not recorded)
- Layer count: 27 (per Layers panel)
- Graphics memory: ≈ **5.1 GB** total (dominant layers at ~544 MB each ×7, plus several 100 MB range entries)
- Compositing hot spots:
  - Seven layers at **544.64 MB** each (likely repeated backing surfaces for the WebGL canvas / DOM blending)
  - Additional large surfaces at 495.62 MB, 117.97 MB, 104–105 MB, 91.64 MB, 88.16 MB, 87.58 MB, 80.04 MB, 78.88 MB
  - Highest paint count observed: 17 paints on a 4.66 MB surface; most heavy memory layers show 1–3 paints
- Notes & screenshots: `docs/perf/2025-11-09-safari-layers/Audit.audit`, `.../Demo Audit.audit`, and the PNG set `Screenshot 2025-11-09 at 02.05.48.png` → `Screenshot 2025-11-09 at 02.06.26.png`

Baseline takeaway: Safari is allocating multiple ~0.5 GB backing layers, pushing composite memory above 5 GB before any optimisations. This confirms the need to clamp DPR, remove duplicate overlays, and reduce full-bleed compositing surfaces.

## Measurement — 2025-11-09 (All layers ON, after DPR cap wiring)

Raw top entries (Paints / Memory MB):
- 2 / 12.08
- 6 / 10.56
- 3 / 10.56
- 3 / 10.56
- 17 / 4.66
- 1 / 2.07
- 3 / 544.64 (x7 layers)
- 2 / 495.62
- 1 / 117.97
- 2 / 104.98
- 3 / 104.40
- 3 / 91.64
- 3 / 88.16
- 3 / 87.58
- 3 / 80.04
- 3 / 78.88

Approx total ≈ 5.1 GB.

Interpretation
- The seven 544.64 MB layers and the 495.62 MB layer are full-bleed backing stores likely caused by overlapping full-screen elements with filters/blending (GL overlay sprite + DOM vignette + canvases + fxRoot filter).
- Next step is isolation by toggling sources to determine which combination spawns the extra surfaces.

Action checklist for next run
1) Toggle GL overlay sprite off: ERRL.toggle.overlayNode(false) → record layer/memory totals
2) Keep overlay off, toggle DOM vignette off: ERRL.toggle.vignette(false) → record
3) Re-enable vignette, keep overlay off; then re-enable overlay and disable fxRoot filter: ERRL.toggle.fxFilter(false) → record
4) Toggle rising canvas off: ERRL.toggle.riseBubbles(false) → record

Paste each result below with “After overlay off”, “After vignette off”, etc., and attach screenshots.

> Note: Rising bubbles boot visible now (`#riseBubbles` no longer ship with `display:none`). If they still appear hidden, run `ERRL.toggle.riseBubbles(true)` or clear `localStorage.errl_debug_state_v1`.

### After overlay off (GL sprite hidden)
- Layer count: _todo_
- Graphics memory: _todo_
- Notes / screenshot: _todo_

### After vignette off (DOM overlay hidden)
- Layer count: _todo_
- Graphics memory: _todo_
- Notes / screenshot: _todo_

### After fxRoot filter disabled (overlay on, vignette on)
- Layer count: _todo_
- Graphics memory: _todo_
- Notes / screenshot: _todo_

### After rising bubbles off (DOM canvas hidden)
- Layer count: _todo_
- Graphics memory: _todo_
- Notes / screenshot: _todo_

## Stage Audit — 2025-11-09 (Plan Item 9)

- Current Pixi graph:
  - `app.stage`  
    - `ParticleContainer` (GL bubbles)  
    - `fxRoot` (`PIXI.Container`)  
      - `overlay` sprite (gradient render texture + `overlayFilter`)  
      - Errl sprite (primary goo filter)  
      - `orbContainer` (mirror of DOM nav orbs, optional hue filter)  
- No filters applied directly to `app.stage`; everything hangs off `fxRoot` or individual sprites (good—avoids stage-wide promotion).
- Potential hot spots:
  - `gradientTexture()` regenerates a full-size render texture on every resize; at 1920×1080 this creates another ~8 MB RGBA surface each time. Consider caching/rescaling or reusing a smaller gradient.
  - Seven ~544 MB backing layers in Safari likely correspond to repeated composited surfaces for the overlay + WebGL canvas + DOM stacking. Reducing DPR and ensuring only one overlay layer should cut these down.
- Follow-up actions (separate tasks):
  - Reuse a single overlay render texture or switch to CSS gradient where possible.
  - Ensure renderer DPR cap is applied before first render (work in progress under plan items 10–12).

## DPR Clamp & Resize Guard Plan — 2025-11-09 (Plan Items 10–12)

**Goals**
- Reduce Safari’s ~544 MB backing layers by lowering the default WebGL renderer DPR on macOS/iOS.
- Eliminate resize thrash (0×0 canvases during orientation/viewport changes).

**Proposed Implementation**

1. **Default DPR policy**
   - Detect Safari (`/Safari/` in UA + no `Chrome/`).  
   - Use `Math.min(1.5, window.devicePixelRatio || 1)` for Safari; keep existing `Math.min(2, devicePixelRatio || 1)` elsewhere.  
   - Store the chosen cap in `currentResolutionCap` before instantiating Pixi so the first render uses the lower DPR.
   - Persist the auto-selected cap in `localStorage.errl_debug_dpr_auto` for telemetry (distinct from user overrides).

2. **Runtime override & recovery**
   - Keep the existing `window.errlGLSetDprCap` pathway (used by `window.errlDebug.setDprCap`).  
   - When toggling back to “auto”, recompute using the Safari-aware default and apply immediately.  
   - Log a console message when the cap changes (`[errlGL] resolution set to …`) to assist future audits.

3. **Resize throttling**
   - Wrap the current `window.addEventListener('resize', onResize)` handler with a RAF throttle:  
     - On resize, store the latest width/height and, if no RAF is pending, schedule one.  
     - Inside the RAF callback, bail out if width/height < 2 (Safari sometimes reports 0 during rotation); retry via `setTimeout` 100 ms later.
   - Reuse a single render texture for the overlay gradient: cache the last texture and call `.resize` when dimensions change instead of regenerating a brand new texture.

4. **DOM canvases**
   - Ensure CSS width/height remain 100 vw/vh (already enforced) and verify the JS resize handlers don’t set 0×0.  
   - For Safari-specific behaviour, consider delaying DOM canvas resizes via `setTimeout` 0 to match the Pixi throttling.

**Validation strategy**
- After implementation, repeat the Safari audit and compare the layer/memory numbers. Target: reduce each large backing layer to ≤200 MB (with the hope of consolidating duplicates), total memory target <2 GB.
- Keep the debug harness toggles to isolate individual layers when re-testing.

## Implementation — 2025-11-09 (DPR clamp & resize guards)

- `src/webgl.js`
  - Auto-computes a Safari-specific DPR cap (1.5) and persists manual overrides with `window.errlGLSetDprCap(null|value)`.
  - Applies the cap before Pixi init, logs the chosen resolution, and reuses a cached render texture for the overlay gradient.
  - Adds a RAF-throttled resize handler with minimum-size guards and reuses the gradient texture on resize.
- `src/rise-bubbles.js`
  - Matches the Safari DPR cap for the DOM canvas and throttles resize events to avoid 0×0 thrash.
- Next step: rerun Safari Layers profiling with all toggles “on”, then capture overlay/vignette/bubble permutations per the checklist above.

